 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 1 - 12/29/2022 20:41:36


       1/       0 :                     ;	MS-BASIC for 8080
       2/       0 :                     ;	inported from SBC8080 data pack written by Tetsuya Suzuki
       3/       0 :                     ;	http://www.amy.hi-ho.ne.jp/officetetsu/storage/sbc8080_datapack.zip
       4/       0 :                     ;
       5/       0 :                     ;	Modified by Gazelle 2022 Nov. 12
       6/       0 :                     ;	remove console I/O and add org 2200h for merge with extended monitor
       7/       0 :                     ;	added "CPU Z80" for use ASW.EXE
       8/       0 :                     
       9/       0 :                     	CPU	Z80
      10/    3200 :                     	ORG	3200h
      11/    3200 :                     ;==================================================================================
      12/    3200 :                     ; The updates to the original BASIC within this file are copyright Grant Searle
      13/    3200 :                     ;
      14/    3200 :                     ; You have permission to use this for NON COMMERCIAL USE ONLY
      15/    3200 :                     ; If you wish to use it elsewhere, please include an acknowledgement to myself.
      16/    3200 :                     ;
      17/    3200 :                     ; http://searle.hostei.com/grant/index.html
      18/    3200 :                     ;
      19/    3200 :                     ; eMail: home.micros01@btinternet.com
      20/    3200 :                     ;
      21/    3200 :                     ; If the above don't work, please perform an Internet search to see if I have
      22/    3200 :                     ; updated the web page hosting service.
      23/    3200 :                     ;
      24/    3200 :                     ;==================================================================================
      25/    3200 :                     ;
      26/    3200 :                     ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
      27/    3200 :                     ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
      28/    3200 :                     ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
      29/    3200 :                     ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
      30/    3200 :                     ; the original ROM code (checksum A934H). PA
      31/    3200 :                     ;
      32/    3200 :                     ; GENERAL EQUATES
      33/    3200 :                     ;
      34/    3200 : =3H                  CTRLC	EQU	03H		; Control "C"
      35/    3200 : =7H                  CTRLG	EQU	07H		; Control "G"
      36/    3200 : =8H                  BKSP	EQU	08H		; Back space
      37/    3200 : =0AH                 LF	EQU	0AH		; Line feed
      38/    3200 : =0CH                 CS	EQU	0CH		; Clear screen
      39/    3200 : =0DH                 CR	EQU	0DH		; Carriage return
      40/    3200 : =0FH                 CTRLO	EQU	0FH		; Control "O"
      41/    3200 : =11H                 CTRLQ	EQU	11H		; Control "Q"
      42/    3200 : =12H                 CTRLR	EQU	12H		; Control "R"
      43/    3200 : =13H                 CTRLS	EQU	13H		; Control "S"
      44/    3200 : =15H                 CTRLU	EQU	15H		; Control "U"
      45/    3200 : =1BH                 ESC	EQU	1BH		; Escape
      46/    3200 : =7FH                 DEL	EQU	7FH		; Delete
      47/    3200 :                     ;
      48/    3200 :                     ; BASIC WORK SPACE LOCATIONS
      49/    3200 :                     ;
      50/    3200 : =8045H               WRKSPC	EQU	8045H		; BASIC Work space
      51/    3200 : =8048H               USR	EQU	WRKSPC+3H	; "USR (x)" jump
      52/    3200 : =804BH               OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
      53/    3200 : =804CH               OTPORT	EQU	WRKSPC+7H	; Port (p)
      54/    3200 : =804EH               DIVSUP	EQU	WRKSPC+9H	; Division support routine
      55/    3200 : =804FH               DIV1	EQU	WRKSPC+0AH	; <- Values
      56/    3200 : =8053H               DIV2	EQU	WRKSPC+0EH	; <- to
      57/    3200 : =8057H               DIV3	EQU	WRKSPC+12H	; <- be
      58/    3200 : =805AH               DIV4	EQU	WRKSPC+15H	; <- inserted
      59/    3200 : =805CH               SEED	EQU	WRKSPC+17H	; Random number seed
      60/    3200 : =807FH               LSTRND	EQU	WRKSPC+3AH	; Last random number
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 2 - 12/29/2022 20:41:36


      61/    3200 : =8083H               INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
      62/    3200 : =8084H               INPORT	EQU	WRKSPC+3FH	; PORT (x)
      63/    3200 : =8086H               NULLS	EQU	WRKSPC+41H	; Number of nulls
      64/    3200 : =8087H               LWIDTH	EQU	WRKSPC+42H	; Terminal width
      65/    3200 : =8088H               COMMAN	EQU	WRKSPC+43H	; Width for commas
      66/    3200 : =8089H               NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
      67/    3200 : =808AH               CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
      68/    3200 : =808BH               LINESC	EQU	WRKSPC+46H	; Lines counter
      69/    3200 : =808DH               LINESN	EQU	WRKSPC+48H	; Lines number
      70/    3200 : =808FH               CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
      71/    3200 : =8091H               NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
      72/    3200 : =8092H               BRKFLG	EQU	WRKSPC+4DH	; Break flag
      73/    3200 : =8093H               RINPUT	EQU	WRKSPC+4EH	; Input reflection
      74/    3200 : =8096H               POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
      75/    3200 : =8099H               PSET	EQU	WRKSPC+54H	; "SET"	reflection
      76/    3200 : =809CH               RESET	EQU	WRKSPC+57H	; "RESET" reflection
      77/    3200 : =809FH               STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
      78/    3200 : =80A1H               LINEAT	EQU	WRKSPC+5CH	; Current line number
      79/    3200 : =80A3H               BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
      80/    3200 : =80A6H               BUFFER	EQU	WRKSPC+61H	; Input buffer
      81/    3200 : =80ABH               STACK	EQU	WRKSPC+66H	; Initial stack
      82/    3200 : =80F0H               CURPOS	EQU	WRKSPC+0ABH	; Character position on line
      83/    3200 : =80F1H               LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
      84/    3200 : =80F2H               TYPE	EQU	WRKSPC+0ADH	; Data type flag
      85/    3200 : =80F3H               DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
      86/    3200 : =80F4H               LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
      87/    3200 : =80F6H               TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
      88/    3200 : =80F8H               TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
      89/    3200 : =8104H               TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
      90/    3200 : =8108H               STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
      91/    3200 : =810AH               CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
      92/    3200 : =810CH               LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
      93/    3200 : =810EH               DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
      94/    3200 : =8110H               FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
      95/    3200 : =8111H               LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
      96/    3200 : =8112H               READFG	EQU	WRKSPC+0CDH	; Read/Input flag
      97/    3200 : =8113H               BRKLIN	EQU	WRKSPC+0CEH	; Line of break
      98/    3200 : =8115H               NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
      99/    3200 : =8117H               ERRLIN	EQU	WRKSPC+0D2H	; Line of error
     100/    3200 : =8119H               CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
     101/    3200 : =811BH               PROGND	EQU	WRKSPC+0D6H	; End of program
     102/    3200 : =811DH               VAREND	EQU	WRKSPC+0D8H	; End of variables
     103/    3200 : =811FH               ARREND	EQU	WRKSPC+0DAH	; End of arrays
     104/    3200 : =8121H               NXTDAT	EQU	WRKSPC+0DCH	; Next data item
     105/    3200 : =8123H               FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
     106/    3200 : =8125H               FNARG	EQU	WRKSPC+0E0H	; FN argument value
     107/    3200 : =8129H               FPREG	EQU	WRKSPC+0E4H	; Floating point register
     108/    3200 : =812CH               FPEXP	EQU	FPREG+3		; Floating point exponent
     109/    3200 : =812DH               SGNRES	EQU	WRKSPC+0E8H	; Sign of result
     110/    3200 : =812EH               PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
     111/    3200 : =813BH               MULVAL	EQU	WRKSPC+0F6H	; Multiplier
     112/    3200 : =813EH               PROGST	EQU	WRKSPC+0F9H	; Start of program text area
     113/    3200 : =81A2H               STLOOK	EQU	WRKSPC+15DH	; Start of memory test
     114/    3200 :                     ;
     115/    3200 :                     ; BASIC ERROR CODE VALUES
     116/    3200 :                     ;
     117/    3200 : =0H                  NF	EQU	00H		; NEXT without FOR
     118/    3200 : =2H                  SN	EQU	02H		; Syntax error
     119/    3200 : =4H                  RG	EQU	04H		; RETURN without GOSUB
     120/    3200 : =6H                  OD	EQU	06H		; Out of DATA
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 3 - 12/29/2022 20:41:36


     121/    3200 : =8H                  FC	EQU	08H		; Function call error
     122/    3200 : =0AH                 OV	EQU	0AH		; Overflow
     123/    3200 : =0CH                 OM	EQU	0CH		; Out of memory
     124/    3200 : =0EH                 UL	EQU	0EH		; Undefined line number
     125/    3200 : =10H                 BS	EQU	10H		; Bad subscript
     126/    3200 : =12H                 RD	EQU	12H		; Re-DIMensioned array
     127/    3200 : =14H                 DZ	EQU	14H		; Division by zero (/0)
     128/    3200 : =16H                 ID	EQU	16H		; Illegal direct
     129/    3200 : =18H                 TM	EQU	18H		; Type miss-match
     130/    3200 : =1AH                 OS	EQU	1AH		; Out of string space
     131/    3200 : =1CH                 LS	EQU	1CH		; String too long
     132/    3200 : =1EH                 ST	EQU	1EH		; String formula too complex
     133/    3200 : =20H                 CN	EQU	20H		; Can't CONTinue
     134/    3200 : =22H                 UF	EQU	22H		; UnDEFined FN function
     135/    3200 : =24H                 MO	EQU	24H		; Missing operand
     136/    3200 : =26H                 HX	EQU	26H		; HEX error
     137/    3200 : =28H                 BN	EQU	28H		; BIN error
     138/    3200 :                     ;
     139/    3200 : C3 06 32            COLD:	JP	STARTB		; Jump for cold start
     140/    3203 : C3 7B 32            WARM:	JP	WARMST		; Jump for warm start
     141/    3206 : C3 0D 32            STARTB: JP	CSTART		; Jump to initialise
     142/    3209 :                     ;
     143/    3209 : CC 3A               	DW	DEINT		; Get integer -32768 to 32767
     144/    320B : 43 42               	DW	ABPASS		; Return integer in AB
     145/    320D :                     ;
     146/    320D : 21 45 80            CSTART: LD	HL,WRKSPC	; Start of workspace RAM
     147/    3210 : F9                  	LD	SP,HL		; Set up a temporary stack
     148/    3211 : C3 74 4E            	JP	INITST		; Go to initialise
     149/    3214 :                     ;
     150/    3214 : 11 EB 34            INIT:	LD	DE,INITAB	; Initialise workspace
     151/    3217 : 06 63               	LD	B,INITBE-INITAB+3; Bytes to copy
     152/    3219 : 21 45 80            	LD	HL,WRKSPC	; Into workspace RAM
     153/    321C : 1A                  COPY:	LD	A,(DE)		; Get source
     154/    321D : 77                  	LD	(HL),A		; To destination
     155/    321E : 23                  	INC	HL		; Next destination
     156/    321F : 13                  	INC	DE		; Next source
     157/    3220 : 05                  	DEC	B		; Count bytes
     158/    3221 : C2 1C 32            	JP	NZ,COPY		; More to move
     159/    3224 : F9                  	LD	SP,HL		; Temporary stack
     160/    3225 : CD EC 36            	CALL	CLREG		; Clear registers and stack
     161/    3228 : CD C2 3C            	CALL	PRCRLF		; Output CRLF
     162/    322B : 32 EF 80            	LD	(BUFFER+72+1),A	; Mark end of buffer
     163/    322E : 32 3E 81            	LD	(PROGST),A	; Initialise program area
     164/    3231 : 21 A2 81            MSIZE:	LD	HL,STLOOK	; Point to start of RAM
     165/    3234 : 23                  MLOOP:	INC	HL		; Next byte
     166/    3235 : 7C                  	LD	A,H		; Above address FFFF ?
     167/    3236 : B5                  	OR	L
     168/    3237 : CA 43 32            	JP	Z,SETTOP	; Yes - 64K RAM
     169/    323A : 7E                  	LD	A,(HL)		; Get contents
     170/    323B : 47                  	LD	B,A		; Save it
     171/    323C : 2F                  	CPL			; Flip all bits
     172/    323D : 77                  	LD	(HL),A		; Put it back
     173/    323E : BE                  	CP	(HL)		; RAM there if same
     174/    323F : 70                  	LD	(HL),B		; Restore old contents
     175/    3240 : CA 34 32            	JP	Z,MLOOP		; If RAM - test next byte
     176/    3243 :                     ;
     177/    3243 : 2B                  SETTOP: DEC	HL		; Back one byte
     178/    3244 : 11 A1 81            	LD	DE,STLOOK-1	; See if enough RAM
     179/    3247 : CD 82 38            	CALL	CPDEHL		; Compare DE with HL
     180/    324A : DA 84 32            	JP	C,NEMEM		; If not enough RAM
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 4 - 12/29/2022 20:41:36


     181/    324D : 11 CE FF            	LD	DE,0-50		; 50 Bytes string space
     182/    3250 : 22 F4 80            	LD	(LSTRAM),HL	; Save last available RAM
     183/    3253 : 19                  	ADD	HL,DE		; Allocate string space
     184/    3254 : 22 9F 80            	LD	(STRSPC),HL	; Save string space
     185/    3257 : CD C7 36            	CALL	CLRPTR		; Clear program area
     186/    325A : 2A 9F 80            	LD	HL,(STRSPC)	; Get end of memory
     187/    325D : 11 EF FF            	LD	DE,0-17		; Offset for free bytes
     188/    3260 : 19                  	ADD	HL,DE		; Adjust HL
     189/    3261 : 11 3E 81            	LD	DE,PROGST	; Start of program text
     190/    3264 : 7D                  	LD	A,L		; Get LSB
     191/    3265 : 93                  	SUB	E		; Adjust it
     192/    3266 : 6F                  	LD	L,A		; Re-save
     193/    3267 : 7C                  	LD	A,H		; Get MSB
     194/    3268 : 9A                  	SBC	A,D		; Adjust it
     195/    3269 : 67                  	LD	H,A		; Re-save
     196/    326A : E5                  	PUSH	HL		; Save bytes free
     197/    326B : 21 9C 32            	LD	HL,SIGNON	; Sign-on message
     198/    326E : CD 61 43            	CALL	PRS		; Output string
     199/    3271 : E1                  	POP	HL		; Get bytes free back
     200/    3272 : CD 06 4A            	CALL	PRNTHL		; Output amount of free memory
     201/    3275 : 21 8D 32            	LD	HL,BFREE	; " Bytes free" message
     202/    3278 : CD 61 43            	CALL	PRS		; Output string
     203/    327B :                     ;
     204/    327B : 31 AB 80            WARMST: LD	SP,STACK	; Temporary stack
     205/    327E : CD EC 36            BRKRET: CALL	CLREG		; Clear registers and stack
     206/    3281 : C3 05 36            	JP	PRNTOK		; Go to get command line
     207/    3284 :                     ;
     208/    3284 : 21 D9 32            NEMEM:	LD	HL,MEMMSG	; Memory size not enough
     209/    3287 : CD 61 43            	CALL	PRS		; Print it
     210/    328A : C3 8A 32            XXXXX:	JP	XXXXX		; Stop
     211/    328D :                     ;
     212/    328D : 20 42 79 74 65 73   BFREE:	DB	" Bytes free",CR,LF,0,0
             3293 : 20 66 72 65 65 0D 
             3299 : 0A 00 00          
     213/    329C :                     ;
     214/    329C : 49 4E 54 45 4C 38   SIGNON: DB	"INTEL8080 BASIC Ver 4.7b",CR,LF
             32A2 : 30 38 30 20 42 41 
             32A8 : 53 49 43 20 56 65 
             32AE : 72 20 34 2E 37 62 
             32B4 : 0D 0A             
     215/    32B6 : 43 6F 70 79 72 69   	DB	"Copyright ",40,"C",41
             32BC : 67 68 74 20 28 43 
             32C2 : 29                
     216/    32C3 : 20 31 39 37 38 20   	DB	" 1978 by Microsoft",CR,LF,0,0
             32C9 : 62 79 20 4D 69 63 
             32CF : 72 6F 73 6F 66 74 
             32D5 : 0D 0A 00 00       
     217/    32D9 :                     ;
     218/    32D9 : 4D 65 6D 6F 72 79   MEMMSG: DB	"Memory size not enough",CR,LF
             32DF : 20 73 69 7A 65 20 
             32E5 : 6E 6F 74 20 65 6E 
             32EB : 6F 75 67 68 0D 0A 
     219/    32F1 : 54 68 65 20 73 79   	DB	"The system is stopped.",CR,LF,0,0
             32F7 : 73 74 65 6D 20 69 
             32FD : 73 20 73 74 6F 70 
             3303 : 70 65 64 2E 0D 0A 
             3309 : 00 00             
     220/    330B :                     ;
     221/    330B :                     ; FUNCTION ADDRESS TABLE
     222/    330B :                     ;
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 5 - 12/29/2022 20:41:36


     223/    330B : 7B 48               FNCTAB: DW	SGN
     224/    330D : 3F 49               	DW	INT
     225/    330F : 91 48               	DW	ABS
     226/    3311 : 48 80               	DW	USR
     227/    3313 : 21 42               	DW	FRE
     228/    3315 : A8 45               	DW	INP
     229/    3317 : 4F 42               	DW	POS
     230/    3319 : 05 4B               	DW	SQR
     231/    331B : E4 4B               	DW	RND
     232/    331D : 20 47               	DW	LOG
     233/    331F : 53 4B               	DW	EXP
     234/    3321 : 59 4C               	DW	COS
     235/    3323 : 5F 4C               	DW	SIN
     236/    3325 : C0 4C               	DW	TAN
     237/    3327 : D5 4C               	DW	ATN
     238/    3329 : FC 45               	DW	PEEK
     239/    332B : 40 4D               	DW	DEEK
     240/    332D : 96 80               	DW	POINT
     241/    332F : D3 44               	DW	LEN
     242/    3331 : EB 42               	DW	STR
     243/    3333 : 6D 45               	DW	VAL
     244/    3335 : E2 44               	DW	ASC
     245/    3337 : F3 44               	DW	CHR
     246/    3339 : 62 4D               	DW	HEX
     247/    333B : FF 4D               	DW	BIN
     248/    333D : 03 45               	DW	LEFT
     249/    333F : 33 45               	DW	RIGHT
     250/    3341 : 3D 45               	DW	MID
     251/    3343 :                     ;
     252/    3343 :                     ; RESERVED WORD LIST
     253/    3343 :                     ;
     254/    3343 : C5 4E 44            WORDS:	DB	0C5H,"ND"
     255/    3346 : C6 4F 52            	DB	0C6H,"OR"
     256/    3349 : CE 45 58 54         	DB	0CEH,"EXT"
     257/    334D : C4 41 54 41         	DB	0C4H,"ATA"
     258/    3351 : C9 4E 50 55 54      	DB	0C9H,"NPUT"
     259/    3356 : C4 49 4D            	DB	0C4H,"IM"
     260/    3359 : D2 45 41 44         	DB	0D2H,"EAD"
     261/    335D : CC 45 54            	DB	0CCH,"ET"
     262/    3360 : C7 4F 54 4F         	DB	0C7H,"OTO"
     263/    3364 : D2 55 4E            	DB	0D2H,"UN"
     264/    3367 : C9 46               	DB	0C9H,"F"
     265/    3369 : D2 45 53 54 4F 52   	DB	0D2H,"ESTORE"
             336F : 45                
     266/    3370 : C7 4F 53 55 42      	DB	0C7H,"OSUB"
     267/    3375 : D2 45 54 55 52 4E   	DB	0D2H,"ETURN"
     268/    337B : D2 45 4D            	DB	0D2H,"EM"
     269/    337E : D3 54 4F 50         	DB	0D3H,"TOP"
     270/    3382 : CF 55 54            	DB	0CFH,"UT"
     271/    3385 : CF 4E               	DB	0CFH,"N"
     272/    3387 : CE 55 4C 4C         	DB	0CEH,"ULL"
     273/    338B : D7 41 49 54         	DB	0D7H,"AIT"
     274/    338F : C4 45 46            	DB	0C4H,"EF"
     275/    3392 : D0 4F 4B 45         	DB	0D0H,"OKE"
     276/    3396 : C4 4F 4B 45         	DB	0C4H,"OKE"
     277/    339A : D3 43 52 45 45 4E   	DB	0D3H,"CREEN"
     278/    33A0 : CC 49 4E 45 53      	DB	0CCH,"INES"
     279/    33A5 : C3 4C 53            	DB	0C3H,"LS"
     280/    33A8 : D7 49 44 54 48      	DB	0D7H,"IDTH"
     281/    33AD : CD 4F 4E 49 54 4F   	DB	0CDH,"ONITOR"
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 6 - 12/29/2022 20:41:36


             33B3 : 52                
     282/    33B4 : D3 45 54            	DB	0D3H,"ET"
     283/    33B7 : D2 45 53 45 54      	DB	0D2H,"ESET"
     284/    33BC : D0 52 49 4E 54      	DB	0D0H,"RINT"
     285/    33C1 : C3 4F 4E 54         	DB	0C3H,"ONT"
     286/    33C5 : CC 49 53 54         	DB	0CCH,"IST"
     287/    33C9 : C3 4C 45 41 52      	DB	0C3H,"LEAR"
     288/    33CE : C3 4C 4F 41 44      	DB	0C3H,"LOAD"
     289/    33D3 : C3 53 41 56 45      	DB	0C3H,"SAVE"
     290/    33D8 : CE 45 57            	DB	0CEH,"EW"
     291/    33DB :                     ;
     292/    33DB : D4 41 42 28         	DB	0D4H,"AB("
     293/    33DF : D4 4F               	DB	0D4H,"O"
     294/    33E1 : C6 4E               	DB	0C6H,"N"
     295/    33E3 : D3 50 43 28         	DB	0D3H,"PC("
     296/    33E7 : D4 48 45 4E         	DB	0D4H,"HEN"
     297/    33EB : CE 4F 54            	DB	0CEH,"OT"
     298/    33EE : D3 54 45 50         	DB	0D3H,"TEP"
     299/    33F2 :                     ;
     300/    33F2 : AB                  	DB	0ABH
     301/    33F3 : AD                  	DB	0ADH
     302/    33F4 : AA                  	DB	0AAH
     303/    33F5 : AF                  	DB	0AFH
     304/    33F6 : DE                  	DB	0DEH
     305/    33F7 : C1 4E 44            	DB	0C1H,"ND"
     306/    33FA : CF 52               	DB	0CFH,"R"
     307/    33FC : BE                  	DB	0BEH
     308/    33FD : BD                  	DB	0BDH
     309/    33FE : BC                  	DB	0BCH
     310/    33FF :                     ;
     311/    33FF : D3 47 4E            	DB	0D3H,"GN"
     312/    3402 : C9 4E 54            	DB	0C9H,"NT"
     313/    3405 : C1 42 53            	DB	0C1H,"BS"
     314/    3408 : D5 53 52            	DB	0D5H,"SR"
     315/    340B : C6 52 45            	DB	0C6H,"RE"
     316/    340E : C9 4E 50            	DB	0C9H,"NP"
     317/    3411 : D0 4F 53            	DB	0D0H,"OS"
     318/    3414 : D3 51 52            	DB	0D3H,"QR"
     319/    3417 : D2 4E 44            	DB	0D2H,"ND"
     320/    341A : CC 4F 47            	DB	0CCH,"OG"
     321/    341D : C5 58 50            	DB	0C5H,"XP"
     322/    3420 : C3 4F 53            	DB	0C3H,"OS"
     323/    3423 : D3 49 4E            	DB	0D3H,"IN"
     324/    3426 : D4 41 4E            	DB	0D4H,"AN"
     325/    3429 : C1 54 4E            	DB	0C1H,"TN"
     326/    342C : D0 45 45 4B         	DB	0D0H,"EEK"
     327/    3430 : C4 45 45 4B         	DB	0C4H,"EEK"
     328/    3434 : D0 4F 49 4E 54      	DB	0D0H,"OINT"
     329/    3439 : CC 45 4E            	DB	0CCH,"EN"
     330/    343C : D3 54 52 24         	DB	0D3H,"TR$"
     331/    3440 : D6 41 4C            	DB	0D6H,"AL"
     332/    3443 : C1 53 43            	DB	0C1H,"SC"
     333/    3446 : C3 48 52 24         	DB	0C3H,"HR$"
     334/    344A : C8 45 58 24         	DB	0C8H,"EX$"
     335/    344E : C2 49 4E 24         	DB	0C2H,"IN$"
     336/    3452 : CC 45 46 54 24      	DB	0CCH,"EFT$"
     337/    3457 : D2 49 47 48 54 24   	DB	0D2H,"IGHT$"
     338/    345D : CD 49 44 24         	DB	0CDH,"ID$"
     339/    3461 : 80                  	DB	80H		; End of list marker
     340/    3462 :                     ;
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 7 - 12/29/2022 20:41:36


     341/    3462 :                     ; KEYWORD ADDRESS TABLE
     342/    3462 :                     ;
     343/    3462 : 64 3A               WORDTB: DW	PEND
     344/    3464 : 5D 39               	DW	FOR
     345/    3466 : 3C 3E               	DW	NEXT
     346/    3468 : B1 3B               	DW	DATA
     347/    346A : 43 3D               	DW	INPUT
     348/    346C : 79 40               	DW	DIM
     349/    346E : 72 3D               	DW	READ
     350/    3470 : C8 3B               	DW	LET
     351/    3472 : 6E 3B               	DW	GOTO
     352/    3474 : 51 3B               	DW	RUN
     353/    3476 : 40 3C               	DW	IF
     354/    3478 : 26 3A               	DW	RESTOR
     355/    347A : 5D 3B               	DW	GOSUB
     356/    347C : 8C 3B               	DW	RETURN
     357/    347E : B3 3B               	DW	REM
     358/    3480 : 62 3A               	DW	STOP
     359/    3482 : B4 45               	DW	POUT
     360/    3484 : 22 3C               	DW	ON
     361/    3486 : A3 3A               	DW	NULL
     362/    3488 : BA 45               	DW	WAIT
     363/    348A : 57 42               	DW	DEF
     364/    348C : 03 46               	DW	POKE
     365/    348E : 4B 4D               	DW	DOKE
     366/    3490 : B3 3B               	DW	REM
     367/    3492 : 31 4D               	DW	LINES
     368/    3494 : 24 4D               	DW	CLS
     369/    3496 : 29 4D               	DW	WIDTH
     370/    3498 : 70 4E               	DW	MONITR
     371/    349A : 99 80               	DW	PSET
     372/    349C : 9C 80               	DW	RESET
     373/    349E : 64 3C               	DW	PRINT
     374/    34A0 : 90 3A               	DW	CONT
     375/    34A2 : CE 38               	DW	LIST
     376/    34A4 : 0B 3B               	DW	CLEAR
     377/    34A6 : B3 3B               	DW	REM
     378/    34A8 : B3 3B               	DW	REM
     379/    34AA : C6 36               	DW	NEW
     380/    34AC :                     ;
     381/    34AC :                     ; RESERVED WORD TOKEN VALUES
     382/    34AC :                     ;
     383/    34AC : =80H                 ZEND	EQU	080H		; END
     384/    34AC : =81H                 ZFOR	EQU	081H		; FOR
     385/    34AC : =83H                 ZDATA	EQU	083H		; DATA
     386/    34AC : =88H                 ZGOTO	EQU	088H		; GOTO
     387/    34AC : =8CH                 ZGOSUB	EQU	08CH		; GOSUB
     388/    34AC : =8EH                 ZREM	EQU	08EH		; REM
     389/    34AC : =9EH                 ZPRINT	EQU	09EH		; PRINT
     390/    34AC : =0A4H                ZNEW	EQU	0A4H		; NEW
     391/    34AC :                     ;
     392/    34AC : =0A5H                ZTAB	EQU	0A5H		; TAB
     393/    34AC : =0A6H                ZTO	EQU	0A6H		; TO
     394/    34AC : =0A7H                ZFN	EQU	0A7H		; FN
     395/    34AC : =0A8H                ZSPC	EQU	0A8H		; SPC
     396/    34AC : =0A9H                ZTHEN	EQU	0A9H		; THEN
     397/    34AC : =0AAH                ZNOT	EQU	0AAH		; NOT
     398/    34AC : =0ABH                ZSTEP	EQU	0ABH		; STEP
     399/    34AC :                     ;
     400/    34AC : =0ACH                ZPLUS	EQU	0ACH		; +
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 8 - 12/29/2022 20:41:36


     401/    34AC : =0ADH                ZMINUS	EQU	0ADH		; -
     402/    34AC : =0AEH                ZTIMES	EQU	0AEH		; *
     403/    34AC : =0AFH                ZDIV	EQU	0AFH		; /
     404/    34AC : =0B2H                ZOR	EQU	0B2H		; OR
     405/    34AC : =0B3H                ZGTR	EQU	0B3H		; >
     406/    34AC : =0B4H                ZEQUAL	EQU	0B4H		; M
     407/    34AC : =0B5H                ZLTH	EQU	0B5H		; <
     408/    34AC : =0B6H                ZSGN	EQU	0B6H		; SGN
     409/    34AC : =0C7H                ZPOINT	EQU	0C7H		; POINT
     410/    34AC : =0CFH                ZLEFT	EQU	0CDH +2		; LEFT$
     411/    34AC :                     ;
     412/    34AC :                     ; ARITHMETIC PRECEDENCE TABLE
     413/    34AC :                     ;
     414/    34AC : 79                  PRITAB: DB	79H		; Precedence value
     415/    34AD : ED 49               	DW	PADD		; FPREG = <last> + FPREG
     416/    34AF :                     ;
     417/    34AF : 79                  	DB	79H		; Precedence value
     418/    34B0 : 21 46               	DW	PSUB		; FPREG = <last> - FPREG
     419/    34B2 :                     ;
     420/    34B2 : 7C                  	DB	7CH		; Precedence value
     421/    34B3 : 5F 47               	DW	MULT		; PPREG = <last> * FPREG
     422/    34B5 :                     ;
     423/    34B5 : 7C                  	DB	7CH		; Precedence value
     424/    34B6 : C0 47               	DW	DIV		; FPREG = <last> / FPREG
     425/    34B8 :                     ;
     426/    34B8 : 7F                  	DB	7FH		; Precedence value
     427/    34B9 : 0E 4B               	DW	POWER		; FPREG = <last> ^ FPREG
     428/    34BB :                     ;
     429/    34BB : 50                  	DB	50H		; Precedence value
     430/    34BC : D2 3F               	DW	PAND		; FPREG = <last> AND FPREG
     431/    34BE :                     ;
     432/    34BE : 46                  	DB	46H		; Precedence value
     433/    34BF : D1 3F               	DW	POR		; FPREG = <last> OR FPREG
     434/    34C1 :                     ;
     435/    34C1 :                     ; BASIC ERROR CODE LIST
     436/    34C1 :                     ;
     437/    34C1 : 4E 46               ERRORS: DB	"NF"		; NEXT without FOR
     438/    34C3 : 53 4E               	DB	"SN"		; Syntax error
     439/    34C5 : 52 47               	DB	"RG"		; RETURN without GOSUB
     440/    34C7 : 4F 44               	DB	"OD"		; Out of DATA
     441/    34C9 : 46 43               	DB	"FC"		; Illegal function call
     442/    34CB : 4F 56               	DB	"OV"		; Overflow error
     443/    34CD : 4F 4D               	DB	"OM"		; Out of memory
     444/    34CF : 55 4C               	DB	"UL"		; Undefined line
     445/    34D1 : 42 53               	DB	"BS"		; Bad subscript
     446/    34D3 : 44 44               	DB	"DD"		; Re-DIMensioned array
     447/    34D5 : 2F 30               	DB	"/0"		; Division by zero
     448/    34D7 : 49 44               	DB	"ID"		; Illegal direct
     449/    34D9 : 54 4D               	DB	"TM"		; Type mis-match
     450/    34DB : 4F 53               	DB	"OS"		; Out of string space
     451/    34DD : 4C 53               	DB	"LS"		; String too long
     452/    34DF : 53 54               	DB	"ST"		; String formula too complex
     453/    34E1 : 43 4E               	DB	"CN"		; Can't CONTinue
     454/    34E3 : 55 46               	DB	"UF"		; Undefined FN function
     455/    34E5 : 4D 4F               	DB	"MO"		; Missing operand
     456/    34E7 : 48 58               	DB	"HX"		; HEX error
     457/    34E9 : 42 4E               	DB	"BN"		; BIN error
     458/    34EB :                     ;
     459/    34EB :                     ; INITIALISATION TABLE -------------------------------------------------------
     460/    34EB :                     ;
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 9 - 12/29/2022 20:41:36


     461/    34EB : C3 7B 32            INITAB: JP	WARMST		; Warm start jump
     462/    34EE : C3 E1 3A            	JP	FCERR		; "USR (X)" jump (Set to Error)
     463/    34F1 : D3 00               	OUT	(0),A		; "OUT p,n" skeleton
     464/    34F3 : C9                  	RET
     465/    34F4 : D6 00               	SUB	0		; Division support routine
     466/    34F6 : 6F                  	LD	L,A
     467/    34F7 : 7C                  	LD	A,H
     468/    34F8 : DE 00               	SBC	A,0
     469/    34FA : 67                  	LD	H,A
     470/    34FB : 78                  	LD	A,B
     471/    34FC : DE 00               	SBC	A,0
     472/    34FE : 47                  	LD	B,A
     473/    34FF : 3E 00               	LD	A,0
     474/    3501 : C9                  	RET
     475/    3502 : 00 00 00            	DB	0,0,0			; Random number seed table used by RND
     476/    3505 : 35 4A CA 99         	DB	035H,04AH,0CAH,099H	;-2.65145E+07
     477/    3509 : 39 1C 76 98         	DB	039H,01CH,076H,098H	; 1.61291E+07
     478/    350D : 22 95 B3 98         	DB	022H,095H,0B3H,098H	;-1.17691E+07
     479/    3511 : 0A DD 47 98         	DB	00AH,0DDH,047H,098H	; 1.30983E+07
     480/    3515 : 53 D1 99 99         	DB	053H,0D1H,099H,099H	;-2-01612E+07
     481/    3519 : 0A 1A 9F 98         	DB	00AH,01AH,09FH,098H	;-1.04269E+07
     482/    351D : 65 BC CD 98         	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
     483/    3521 : D6 77 3E 98         	DB	0D6H,077H,03EH,098H	; 1.24825E+07
     484/    3525 : 52 C7 4F 80         	DB	052H,0C7H,04FH,080H	; Last random number
     485/    3529 : DB 00               	IN	A,(0)		; INP (x) skeleton
     486/    352B : C9                  	RET
     487/    352C : 01                  	DB	1		; POS (x) number (1)
     488/    352D : FF                  	DB	255		; Terminal width (255 = no auto CRLF)
     489/    352E : 1C                  	DB	28		; Width for commas (3 columns)
     490/    352F : 00                  	DB	0		; No nulls after input bytes
     491/    3530 : 00                  	DB	0		; Output enabled (^O off)
     492/    3531 : 14 00               	DW	20		; Initial lines counter
     493/    3533 : 14 00               	DW	20		; Initial lines number
     494/    3535 : 00 00               	DW	0		; Array load/save check sum
     495/    3537 : 00                  	DB	0		; Break not by NMI
     496/    3538 : 00                  	DB	0		; Break flag
     497/    3539 : C3 FF 37            	JP	TTYLIN		; Input reflection (set to TTY)
     498/    353C : C3 00 00            	JP	0000H		; POINT reflection unused
     499/    353F : C3 00 00            	JP	0000H		; SET reflection
     500/    3542 : C3 00 00            	JP	0000H			; RESET reflection
     501/    3545 : A2 81               	DW	STLOOK		; Temp string space
     502/    3547 : FE FF               	DW	-2		; Current line number (cold)
     503/    3549 : 3F 81               	DW	PROGST+1	; Start of program text
     504/    354B :                     INITBE:			 
     505/    354B :                     ;
     506/    354B :                     ; END OF INITIALISATION TABLE ---------------------------------------------------
     507/    354B :                     ;
     508/    354B : 20 45 72 72 6F 72   ERRMSG: DB	" Error",0
             3551 : 00                
     509/    3552 : 20 69 6E 20 00      INMSG:	DB	" in ",0
     510/    3557 : =3556H               ZERBYT	EQU	$-1		; A zero byte
     511/    3557 : 4F 6B 0D 0A 00 00   OKMSG:	DB	"Ok",CR,LF,0,0
     512/    355D : 42 72 65 61 6B 00   BRKMSG: DB	"Break",0
     513/    3563 :                     ;
     514/    3563 : 21 04 00            BAKSTK: LD	HL,4		; Look for "FOR" block with
     515/    3566 : 39                  	ADD	HL,SP		; same index as specified
     516/    3567 : 7E                  LOKFOR: LD	A,(HL)		; Get block ID
     517/    3568 : 23                  	INC	HL		; Point to index address
     518/    3569 : FE 81               	CP	ZFOR		; Is it a "FOR" token
     519/    356B : C0                  	RET	NZ		; No - exit
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 10 - 12/29/2022 20:41:36


     520/    356C : 4E                  	LD	C,(HL)		; BC = Address of "FOR" index
     521/    356D : 23                  	INC	HL
     522/    356E : 46                  	LD	B,(HL)
     523/    356F : 23                  	INC	HL		; Point to sign of STEP
     524/    3570 : E5                  	PUSH	HL		; Save pointer to sign
     525/    3571 : 69                  	LD	L,C		; HL = address of "FOR" index
     526/    3572 : 60                  	LD	H,B
     527/    3573 : 7A                  	LD	A,D		; See if an index was specified
     528/    3574 : B3                  	OR	E		; DE = 0 if no index specified
     529/    3575 : EB                  	EX	DE,HL		; Specified index into HL
     530/    3576 : CA 7D 35            	JP	Z,INDFND	; Skip if no index given
     531/    3579 : EB                  	EX	DE,HL		; Index back into DE
     532/    357A : CD 82 38            	CALL	CPDEHL		; Compare index with one given
     533/    357D : 01 0D 00            INDFND: LD	BC,16-3		; Offset to next block
     534/    3580 : E1                  	POP	HL		; Restore pointer to sign
     535/    3581 : C8                  	RET	Z		; Return if block found
     536/    3582 : 09                  	ADD	HL,BC		; Point to next block
     537/    3583 : C3 67 35            	JP	LOKFOR		; Keep on looking
     538/    3586 :                     ;
     539/    3586 : CD A0 35            MOVUP:	CALL	ENFMEM		; See if enough memory
     540/    3589 : C5                  MOVSTR: PUSH	BC		; Save end of source
     541/    358A : E3                  	EX	(SP),HL		; Swap source and dest" end
     542/    358B : C1                  	POP	BC		; Get end of destination
     543/    358C : CD 82 38            MOVLP:	CALL	CPDEHL		; See if list moved
     544/    358F : 7E                  	LD	A,(HL)		; Get byte
     545/    3590 : 02                  	LD	(BC),A		; Move it
     546/    3591 : C8                  	RET	Z		; Exit if all done
     547/    3592 : 0B                  	DEC	BC		; Next byte to move to
     548/    3593 : 2B                  	DEC	HL		; Next byte to move
     549/    3594 : C3 8C 35            	JP	MOVLP		; Loop until all bytes moved
     550/    3597 :                     ;
     551/    3597 : E5                  CHKSTK: PUSH	HL		; Save code string address
     552/    3598 : 2A 1F 81            	LD	HL,(ARREND)	; Lowest free memory
     553/    359B : 06 00               	LD	B,0		; BC = Number of levels to test
     554/    359D : 09                  	ADD	HL,BC		; 2 Bytes for each level
     555/    359E : 09                  	ADD	HL,BC
     556/    359F : 3E                  	DB	3EH		; Skip "PUSH HL"
     557/    35A0 : E5                  ENFMEM: PUSH	HL		; Save code string address
     558/    35A1 : 3E D0               	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
     559/    35A3 : 95                  	SUB	L
     560/    35A4 : 6F                  	LD	L,A
     561/    35A5 : 3E FF               	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
     562/    35A7 : 9C                  	SBC	A,H
     563/    35A8 : DA AF 35            	JP	C,OMERR		; Not enough - ?OM Error
     564/    35AB : 67                  	LD	H,A
     565/    35AC : 39                  	ADD	HL,SP		; Test if stack is overflowed
     566/    35AD : E1                  	POP	HL		; Restore code string address
     567/    35AE : D8                  	RET	C		; Return if enough mmory
     568/    35AF : 1E 0C               OMERR:	LD	E,OM		; ?OM Error
     569/    35B1 : C3 CE 35            	JP	ERROR
     570/    35B4 :                     ;
     571/    35B4 : 2A 0E 81            DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
     572/    35B7 : 22 A1 80            	LD	(LINEAT),HL	; Save as current line
     573/    35BA : 1E 02               SNERR:	LD	E,SN		; ?SN Error
     574/    35BC : 01                  	DB	01H		; Skip "LD E,DZ"
     575/    35BD : 1E 14               DZERR:	LD	E,DZ		; ?/0 Error
     576/    35BF : 01                  	DB	01H		; Skip "LD E,NF"
     577/    35C0 : 1E 00               NFERR:	LD	E,NF		; ?NF Error
     578/    35C2 : 01                  	DB	01H		; Skip "LD E,RD"
     579/    35C3 : 1E 12               DDERR:	LD	E,RD		; ?DD Error
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 11 - 12/29/2022 20:41:36


     580/    35C5 : 01                  	DB	01H		; Skip "LD E,UF"
     581/    35C6 : 1E 22               UFERR:	LD	E,UF		; ?UF Error
     582/    35C8 : 01                  	DB	01H		; Skip "LD E,OV
     583/    35C9 : 1E 0A               OVERR:	LD	E,OV		; ?OV Error
     584/    35CB : 01                  	DB	01H		; Skip "LD E,TM"
     585/    35CC : 1E 18               TMERR:	LD	E,TM		; ?TM Error
     586/    35CE :                     ;
     587/    35CE : CD EC 36            ERROR:	CALL	CLREG		; Clear registers and stack
     588/    35D1 : 32 8A 80            	LD	(CTLOFG),A	; Enable output (A is 0)
     589/    35D4 : CD B5 3C            	CALL	STTLIN		; Start new line
     590/    35D7 : 21 C1 34            	LD	HL,ERRORS	; Point to error codes
     591/    35DA : 57                  	LD	D,A		; D = 0 (A is 0)
     592/    35DB : 3E 3F               	LD	A,'?'
     593/    35DD : CD 93 38            	CALL	OUTC		; Output '?'
     594/    35E0 : 19                  	ADD	HL,DE		; Offset to correct error code
     595/    35E1 : 7E                  	LD	A,(HL)		; First character
     596/    35E2 : CD 93 38            	CALL	OUTC		; Output it
     597/    35E5 : CD 16 3A            	CALL	GETCHR		; Get next character
     598/    35E8 : CD 93 38            	CALL	OUTC		; Output it
     599/    35EB : 21 4B 35            	LD	HL,ERRMSG	; "Error" message
     600/    35EE : CD 61 43            ERRIN:	CALL	PRS		; Output message
     601/    35F1 : 2A A1 80            	LD	HL,(LINEAT)	; Get line of error
     602/    35F4 : 11 FE FF            	LD	DE,-2		; Cold start error if -2
     603/    35F7 : CD 82 38            	CALL	CPDEHL		; See if cold start error
     604/    35FA : CA 0D 32            	JP	Z,CSTART	; Cold start error - Restart
     605/    35FD : 7C                  	LD	A,H		; Was it a direct error?
     606/    35FE : A5                  	AND	L		; Line = -1 if direct error
     607/    35FF : 3C                  	INC	A
     608/    3600 : C4 FE 49            	CALL	NZ,LINEIN	; No - output line of error
     609/    3603 : 3E                  	DB	3EH		; Skip "POP BC"
     610/    3604 : C1                  POPNOK: POP	BC		; Drop address in input buffer
     611/    3605 :                     ;
     612/    3605 : AF                  PRNTOK: XOR	A		; Output "Ok" and get command
     613/    3606 : 32 8A 80            	LD	(CTLOFG),A	; Enable output
     614/    3609 : CD B5 3C            	CALL	STTLIN		; Start new line
     615/    360C : 21 57 35            	LD	HL,OKMSG	; "Ok" message
     616/    360F : CD 61 43            	CALL	PRS		; Output "Ok"
     617/    3612 : 21 FF FF            GETCMD: LD	HL,-1		; Flag direct mode
     618/    3615 : 22 A1 80            	LD	(LINEAT),HL	; Save as current line
     619/    3618 : CD FF 37            	CALL	GETLIN		; Get an input line
     620/    361B : DA 12 36            	JP	C,GETCMD	; Get line again if break
     621/    361E : CD 16 3A            	CALL	GETCHR		; Get first character
     622/    3621 : 3C                  	INC	A		; Test if end of line
     623/    3622 : 3D                  	DEC	A		; Without affecting Carry
     624/    3623 : CA 12 36            	JP	Z,GETCMD	; Nothing entered - Get another
     625/    3626 : F5                  	PUSH	AF		; Save Carry status
     626/    3627 : CD E6 3A            	CALL	ATOH		; Get line number into DE
     627/    362A : D5                  	PUSH	DE		; Save line number
     628/    362B : CD 16 37            	CALL	CRUNCH		; Tokenise rest of line
     629/    362E : 47                  	LD	B,A		; Length of tokenised line
     630/    362F : D1                  	POP	DE		; Restore line number
     631/    3630 : F1                  	POP	AF		; Restore Carry
     632/    3631 : D2 F6 39            	JP	NC,EXCUTE	; No line number - Direct mode
     633/    3634 : D5                  	PUSH	DE		; Save line number
     634/    3635 : C5                  	PUSH	BC		; Save length of tokenised line
     635/    3636 : AF                  	XOR	A
     636/    3637 : 32 11 81            	LD	(LSTBIN),A	; Clear last byte input
     637/    363A : CD 16 3A            	CALL	GETCHR		; Get next character
     638/    363D : B7                  	OR	A		; Set flags
     639/    363E : F5                  	PUSH	AF		; And save them
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 12 - 12/29/2022 20:41:36


     640/    363F : CD A6 36            	CALL	SRCHLN		; Search for line number in DE
     641/    3642 : DA 4B 36            	JP	C,LINFND	; Jump if line found
     642/    3645 : F1                  	POP	AF		; Get status
     643/    3646 : F5                  	PUSH	AF		; And re-save
     644/    3647 : CA 87 3B            	JP	Z,ULERR	; Nothing after number - Error
     645/    364A : B7                  	OR	A		; Clear Carry
     646/    364B : C5                  LINFND: PUSH	BC		; Save address of line in prog
     647/    364C : D2 62 36            	JP	NC,INEWLN	; Line not found - Insert new
     648/    364F : EB                  	EX	DE,HL		; Next line address in DE
     649/    3650 : 2A 1B 81            	LD	HL,(PROGND)	; End of program
     650/    3653 : 1A                  SFTPRG: LD	A,(DE)		; Shift rest of program down
     651/    3654 : 02                  	LD	(BC),A
     652/    3655 : 03                  	INC	BC		; Next destination
     653/    3656 : 13                  	INC	DE		; Next source
     654/    3657 : CD 82 38            	CALL	CPDEHL		; All done?
     655/    365A : C2 53 36            	JP	NZ,SFTPRG	; More to do
     656/    365D : 60                  	LD	H,B		; HL - New end of program
     657/    365E : 69                  	LD	L,C
     658/    365F : 22 1B 81            	LD	(PROGND),HL	; Update end of program
     659/    3662 :                     ;
     660/    3662 : D1                  INEWLN: POP	DE		; Get address of line,
     661/    3663 : F1                  	POP	AF		; Get status
     662/    3664 : CA 89 36            	JP	Z,SETPTR	; No text - Set up pointers
     663/    3667 : 2A 1B 81            	LD	HL,(PROGND)	; Get end of program
     664/    366A : E3                  	EX	(SP),HL		; Get length of input line
     665/    366B : C1                  	POP	BC		; End of program to BC
     666/    366C : 09                  	ADD	HL,BC		; Find new end
     667/    366D : E5                  	PUSH	HL		; Save new end
     668/    366E : CD 86 35            	CALL	MOVUP		; Make space for line
     669/    3671 : E1                  	POP	HL		; Restore new end
     670/    3672 : 22 1B 81            	LD	(PROGND),HL	; Update end of program pointer
     671/    3675 : EB                  	EX	DE,HL		; Get line to move up in HL
     672/    3676 : 74                  	LD	(HL),H		; Save MSB
     673/    3677 : D1                  	POP	DE		; Get new line number
     674/    3678 : 23                  	INC	HL		; Skip pointer
     675/    3679 : 23                  	INC	HL
     676/    367A : 73                  	LD	(HL),E		; Save LSB of line number
     677/    367B : 23                  	INC	HL
     678/    367C : 72                  	LD	(HL),D		; Save MSB of line number
     679/    367D : 23                  	INC	HL		; To first byte in line
     680/    367E : 11 A6 80            	LD	DE,BUFFER	; Copy buffer to program
     681/    3681 : 1A                  MOVBUF: LD	A,(DE)		; Get source
     682/    3682 : 77                  	LD	(HL),A		; Save destinations
     683/    3683 : 23                  	INC	HL		; Next source
     684/    3684 : 13                  	INC	DE		; Next destination
     685/    3685 : B7                  	OR	A		; Done?
     686/    3686 : C2 81 36            	JP	NZ,MOVBUF	; No - Repeat
     687/    3689 : CD D2 36            SETPTR: CALL	RUNFST		; Set line pointers
     688/    368C : 23                  	INC	HL		; To LSB of pointer
     689/    368D : EB                  	EX	DE,HL		; Address to DE
     690/    368E : 62                  PTRLP:	LD	H,D		; Address to HL
     691/    368F : 6B                  	LD	L,E
     692/    3690 : 7E                  	LD	A,(HL)		; Get LSB of pointer
     693/    3691 : 23                  	INC	HL		; To MSB of pointer
     694/    3692 : B6                  	OR	(HL)		; Compare with MSB pointer
     695/    3693 : CA 12 36            	JP	Z,GETCMD	; Get command line if end
     696/    3696 : 23                  	INC	HL		; To LSB of line number
     697/    3697 : 23                  	INC	HL		; Skip line number
     698/    3698 : 23                  	INC	HL		; Point to first byte in line
     699/    3699 : AF                  	XOR	A		; Looking for 00 byte
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 13 - 12/29/2022 20:41:36


     700/    369A : BE                  FNDEND: CP	(HL)		; Found end of line?
     701/    369B : 23                  	INC	HL		; Move to next byte
     702/    369C : C2 9A 36            	JP	NZ,FNDEND	; No - Keep looking
     703/    369F : EB                  	EX	DE,HL		; Next line address to HL
     704/    36A0 : 73                  	LD	(HL),E		; Save LSB of pointer
     705/    36A1 : 23                  	INC	HL
     706/    36A2 : 72                  	LD	(HL),D		; Save MSB of pointer
     707/    36A3 : C3 8E 36            	JP	PTRLP		; Do next line
     708/    36A6 :                     ;
     709/    36A6 : 2A A3 80            SRCHLN: LD	HL,(BASTXT)	; Start of program text
     710/    36A9 : 44                  SRCHLP: LD	B,H		; BC = Address to look at
     711/    36AA : 4D                  	LD	C,L
     712/    36AB : 7E                  	LD	A,(HL)		; Get address of next line
     713/    36AC : 23                  	INC	HL
     714/    36AD : B6                  	OR	(HL)		; End of program found?
     715/    36AE : 2B                  	DEC	HL
     716/    36AF : C8                  	RET	Z		; Yes - Line not found
     717/    36B0 : 23                  	INC	HL
     718/    36B1 : 23                  	INC	HL
     719/    36B2 : 7E                  	LD	A,(HL)		; Get LSB of line number
     720/    36B3 : 23                  	INC	HL
     721/    36B4 : 66                  	LD	H,(HL)		; Get MSB of line number
     722/    36B5 : 6F                  	LD	L,A
     723/    36B6 : CD 82 38            	CALL	CPDEHL		; Compare with line in DE
     724/    36B9 : 60                  	LD	H,B		; HL = Start of this line
     725/    36BA : 69                  	LD	L,C
     726/    36BB : 7E                  	LD	A,(HL)		; Get LSB of next line address
     727/    36BC : 23                  	INC	HL
     728/    36BD : 66                  	LD	H,(HL)		; Get MSB of next line address
     729/    36BE : 6F                  	LD	L,A		; Next line to HL
     730/    36BF : 3F                  	CCF
     731/    36C0 : C8                  	RET	Z		; Lines found - Exit
     732/    36C1 : 3F                  	CCF
     733/    36C2 : D0                  	RET	NC		; Line not found,at line after
     734/    36C3 : C3 A9 36            	JP	SRCHLP		; Keep looking
     735/    36C6 :                     ;
     736/    36C6 : C0                  NEW:	RET	NZ		; Return if any more on line
     737/    36C7 : 2A A3 80            CLRPTR: LD	HL,(BASTXT)	; Point to start of program
     738/    36CA : AF                  	XOR	A		; Set program area to empty
     739/    36CB : 77                  	LD	(HL),A		; Save LSB = 00
     740/    36CC : 23                  	INC	HL
     741/    36CD : 77                  	LD	(HL),A		; Save MSB = 00
     742/    36CE : 23                  	INC	HL
     743/    36CF : 22 1B 81            	LD	(PROGND),HL	; Set program end
     744/    36D2 :                     ;
     745/    36D2 : 2A A3 80            RUNFST: LD	HL,(BASTXT)	; Clear all variables
     746/    36D5 : 2B                  	DEC	HL
     747/    36D6 :                     ;
     748/    36D6 : 22 13 81            INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
     749/    36D9 : 2A F4 80            	LD	HL,(LSTRAM)	; Get end of RAM
     750/    36DC : 22 08 81            	LD	(STRBOT),HL	; Clear string space
     751/    36DF : AF                  	XOR	A
     752/    36E0 : CD 26 3A            	CALL	RESTOR		; Reset DATA pointers
     753/    36E3 : 2A 1B 81            	LD	HL,(PROGND)	; Get end of program
     754/    36E6 : 22 1D 81            	LD	(VAREND),HL	; Clear variables
     755/    36E9 : 22 1F 81            	LD	(ARREND),HL	; Clear arrays
     756/    36EC :                     ;
     757/    36EC : C1                  CLREG:	POP	BC		; Save return address
     758/    36ED : 2A 9F 80            	LD	HL,(STRSPC)	; Get end of working RAN
     759/    36F0 : F9                  	LD	SP,HL		; Set stack
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 14 - 12/29/2022 20:41:36


     760/    36F1 : 21 F8 80            	LD	HL,TMSTPL	; Temporary string pool
     761/    36F4 : 22 F6 80            	LD	(TMSTPT),HL	; Reset temporary string ptr
     762/    36F7 : AF                  	XOR	A		; A = 00
     763/    36F8 : 6F                  	LD	L,A		; HL = 0000
     764/    36F9 : 67                  	LD	H,A
     765/    36FA : 22 19 81            	LD	(CONTAD),HL	; No CONTinue
     766/    36FD : 32 10 81            	LD	(FORFLG),A	; Clear FOR flag
     767/    3700 : 22 23 81            	LD	(FNRGNM),HL	; Clear FN argument
     768/    3703 : E5                  	PUSH	HL		; HL = 0000
     769/    3704 : C5                  	PUSH	BC		; Put back return
     770/    3705 : 2A 13 81            DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
     771/    3708 : C9                  	RET			; Return to execution driver
     772/    3709 :                     ;
     773/    3709 : 3E 3F               PROMPT: LD	A,'?'		; '?'
     774/    370B : CD 93 38            	CALL	OUTC		; Output character
     775/    370E : 3E 20               	LD	A,' '		; Space
     776/    3710 : CD 93 38            	CALL	OUTC		; Output character
     777/    3713 : C3 93 80            	JP	RINPUT		; Get input line
     778/    3716 :                     ;
     779/    3716 : AF                  CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
     780/    3717 : 32 F3 80            	LD	(DATFLG),A	; Reset literal flag
     781/    371A : 0E 05               	LD	C,2+3		; 2 byte number and 3 nulls
     782/    371C : 11 A6 80            	LD	DE,BUFFER	; Start of input buffer
     783/    371F : 7E                  CRNCLP: LD	A,(HL)		; Get byte
     784/    3720 : FE 20               	CP	' '		; Is it a space?
     785/    3722 : CA 9E 37            	JP	Z,MOVDIR	; Yes - Copy direct
     786/    3725 : 47                  	LD	B,A		; Save character
     787/    3726 : FE 22               	CP	'"'		; Is it a quote?
     788/    3728 : CA BE 37            	JP	Z,CPYLIT	; Yes - Copy literal string
     789/    372B : B7                  	OR	A		; Is it end of buffer?
     790/    372C : CA C5 37            	JP	Z,ENDBUF	; Yes - End buffer
     791/    372F : 3A F3 80            	LD	A,(DATFLG)	; Get data type
     792/    3732 : B7                  	OR	A		; Literal?
     793/    3733 : 7E                  	LD	A,(HL)		; Get byte to copy
     794/    3734 : C2 9E 37            	JP	NZ,MOVDIR	; Literal - Copy direct
     795/    3737 : FE 3F               	CP	'?'		; Is it '?' short for PRINT
     796/    3739 : 3E 9E               	LD	A,ZPRINT	; "PRINT" token
     797/    373B : CA 9E 37            	JP	Z,MOVDIR	; Yes - replace it
     798/    373E : 7E                  	LD	A,(HL)		; Get byte again
     799/    373F : FE 30               	CP	'0'		; Is it less than '0'
     800/    3741 : DA 49 37            	JP	C,FNDWRD	; Yes - Look for reserved words
     801/    3744 : FE 3C               	CP	60		; ";"+1; Is it "0123456789:;" ?
     802/    3746 : DA 9E 37            	JP	C,MOVDIR	; Yes - copy it direct
     803/    3749 : D5                  FNDWRD: PUSH	DE		; Look for reserved words
     804/    374A : 11 42 33            	LD	DE,WORDS-1	; Point to table
     805/    374D : C5                  	PUSH	BC		; Save count
     806/    374E : 01 9A 37            	LD	BC,RETNAD	; Where to return to
     807/    3751 : C5                  	PUSH	BC		; Save return address
     808/    3752 : 06 7F               	LD	B,ZEND-1	; First token value -1
     809/    3754 : 7E                  	LD	A,(HL)		; Get byte
     810/    3755 : FE 61               	CP	'a'		; Less than 'a' ?
     811/    3757 : DA 62 37            	JP	C,SEARCH	; Yes - search for words
     812/    375A : FE 7B               	CP	'z'+1		; Greater than 'z' ?
     813/    375C : D2 62 37            	JP	NC,SEARCH	; Yes - search for words
     814/    375F : E6 5F               	AND	01011111B	; Force upper case
     815/    3761 : 77                  	LD	(HL),A		; Replace byte
     816/    3762 : 4E                  SEARCH: LD	C,(HL)		; Search for a word
     817/    3763 : EB                  	EX	DE,HL
     818/    3764 : 23                  GETNXT: INC	HL		; Get next reserved word
     819/    3765 : B6                  	OR	(HL)		; Start of word?
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 15 - 12/29/2022 20:41:36


     820/    3766 : F2 64 37            	JP	P,GETNXT	; No - move on
     821/    3769 : 04                  	INC	B		; Increment token value
     822/    376A : 7E                  	LD	A, (HL)		; Get byte from table
     823/    376B : E6 7F               	AND	01111111B	; Strip bit 7
     824/    376D : C8                  	RET	Z		; Return if end of list
     825/    376E : B9                  	CP	C		; Same character as in buffer?
     826/    376F : C2 64 37            	JP	NZ,GETNXT	; No - get next word
     827/    3772 : EB                  	EX	DE,HL
     828/    3773 : E5                  	PUSH	HL		; Save start of word
     829/    3774 :                     ;
     830/    3774 : 13                  NXTBYT: INC	DE		; Look through rest of word
     831/    3775 : 1A                  	LD	A,(DE)		; Get byte from table
     832/    3776 : B7                  	OR	A		; End of word ?
     833/    3777 : FA 96 37            	JP	M,MATCH		; Yes - Match found
     834/    377A : 4F                  	LD	C,A		; Save it
     835/    377B : 78                  	LD	A,B		; Get token value
     836/    377C : FE 88               	CP	ZGOTO		; Is it "GOTO" token ?
     837/    377E : C2 85 37            	JP	NZ,NOSPC	; No - Don't allow spaces
     838/    3781 : CD 16 3A            	CALL	GETCHR		; Get next character
     839/    3784 : 2B                  	DEC	HL		; Cancel increment from GETCHR
     840/    3785 : 23                  NOSPC:	INC	HL		; Next byte
     841/    3786 : 7E                  	LD	A,(HL)		; Get byte
     842/    3787 : FE 61               	CP	'a'		; Less than 'a' ?
     843/    3789 : DA 8E 37            	JP	C,NOCHNG	; Yes - don't change
     844/    378C : E6 5F               	AND	01011111B	; Make upper case
     845/    378E : B9                  NOCHNG: CP	C		; Same as in buffer ?
     846/    378F : CA 74 37            	JP	Z,NXTBYT	; Yes - keep testing
     847/    3792 : E1                  	POP	HL		; Get back start of word
     848/    3793 : C3 62 37            	JP	SEARCH		; Look at next word
     849/    3796 :                     ;
     850/    3796 : 48                  MATCH:	LD	C,B		; Word found - Save token value
     851/    3797 : F1                  	POP	AF		; Throw away return
     852/    3798 : EB                  	EX	DE,HL
     853/    3799 : C9                  	RET			; Return to "RETNAD"
     854/    379A : EB                  RETNAD: EX	DE,HL		; Get address in string
     855/    379B : 79                  	LD	A,C		; Get token value
     856/    379C : C1                  	POP	BC		; Restore buffer length
     857/    379D : D1                  	POP	DE		; Get destination address
     858/    379E : 23                  MOVDIR: INC	HL		; Next source in buffer
     859/    379F : 12                  	LD	(DE),A		; Put byte in buffer
     860/    37A0 : 13                  	INC	DE		; Move up buffer
     861/    37A1 : 0C                  	INC	C		; Increment length of buffer
     862/    37A2 : D6 3A               	SUB	':'		; End of statement?
     863/    37A4 : CA AC 37            	JP	Z,SETLIT	; Jump if multi-statement line
     864/    37A7 : FE 49               	CP	ZDATA-3AH	; Is it DATA statement ?
     865/    37A9 : C2 AF 37            	JP	NZ,TSTREM	; No - see if REM
     866/    37AC : 32 F3 80            SETLIT: LD	(DATFLG),A	; Set literal flag
     867/    37AF : D6 54               TSTREM: SUB	ZREM-3AH	; Is it REM?
     868/    37B1 : C2 1F 37            	JP	NZ,CRNCLP	; No - Leave flag
     869/    37B4 : 47                  	LD	B,A		; Copy rest of buffer
     870/    37B5 : 7E                  NXTCHR: LD	A,(HL)		; Get byte
     871/    37B6 : B7                  	OR	A		; End of line ?
     872/    37B7 : CA C5 37            	JP	Z,ENDBUF	; Yes - Terminate buffer
     873/    37BA : B8                  	CP	B		; End of statement ?
     874/    37BB : CA 9E 37            	JP	Z,MOVDIR	; Yes - Get next one
     875/    37BE : 23                  CPYLIT: INC	HL		; Move up source string
     876/    37BF : 12                  	LD	(DE),A		; Save in destination
     877/    37C0 : 0C                  	INC	C		; Increment length
     878/    37C1 : 13                  	INC	DE		; Move up destination
     879/    37C2 : C3 B5 37            	JP	NXTCHR		; Repeat
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 16 - 12/29/2022 20:41:36


     880/    37C5 :                     ;
     881/    37C5 : 21 A5 80            ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
     882/    37C8 : 12                  	LD	(DE),A		; Mark end of buffer (A = 00)
     883/    37C9 : 13                  	INC	DE
     884/    37CA : 12                  	LD	(DE),A		; A = 00
     885/    37CB : 13                  	INC	DE
     886/    37CC : 12                  	LD	(DE),A		; A = 00
     887/    37CD : C9                  	RET
     888/    37CE :                     ;
     889/    37CE : 3A 89 80            DODEL:	LD	A,(NULFLG)	; Get null flag status
     890/    37D1 : B7                  	OR	A		; Is it zero?
     891/    37D2 : 3E 00               	LD	A,0		; Zero A - Leave flags
     892/    37D4 : 32 89 80            	LD	(NULFLG),A	; Zero null flag
     893/    37D7 : C2 E2 37            	JP	NZ,ECHDEL	; Set - Echo it
     894/    37DA : 05                  	DEC	B		; Decrement length
     895/    37DB : CA FF 37            	JP	Z,GETLIN	; Get line again if empty
     896/    37DE : CD 93 38            	CALL	OUTC		; Output null character
     897/    37E1 : 3E                  	DB	3EH		; Skip "DEC B"
     898/    37E2 : 05                  ECHDEL: DEC	B		; Count bytes in buffer
     899/    37E3 : 2B                  	DEC	HL		; Back space buffer
     900/    37E4 : CA F6 37            	JP	Z,OTKLN		; No buffer - Try again
     901/    37E7 : 7E                  	LD	A,(HL)		; Get deleted byte
     902/    37E8 : CD 93 38            	CALL	OUTC		; Echo it
     903/    37EB : C3 08 38            	JP	MORINP		; Get more input
     904/    37EE :                     ;
     905/    37EE : 05                  DELCHR: DEC	B		; Count bytes in buffer
     906/    37EF : 2B                  	DEC	HL		; Back space buffer
     907/    37F0 : CD 93 38            	CALL	OUTC		; Output character in A
     908/    37F3 : C2 08 38            	JP	NZ,MORINP	; Not end - Get more
     909/    37F6 : CD 93 38            OTKLN:	CALL	OUTC		; Output character in A
     910/    37F9 : CD C2 3C            KILIN:	CALL	PRCRLF		; Output CRLF
     911/    37FC : C3 FF 37            	JP	TTYLIN		; Get line again
     912/    37FF :                     ;
     913/    37FF :                     GETLIN:
     914/    37FF : 21 A6 80            TTYLIN: LD	HL,BUFFER	; Get a line by character
     915/    3802 : 06 01               	LD	B,1		; Set buffer as empty
     916/    3804 : AF                  	XOR	A
     917/    3805 : 32 89 80            	LD	(NULFLG),A	; Clear null flag
     918/    3808 : CD BD 38            MORINP: CALL	CLOTST		; Get character and test ^O
     919/    380B : 4F                  	LD	C,A		; Save character in C
     920/    380C : FE 7F               	CP	DEL		; Delete character?
     921/    380E : CA CE 37            	JP	Z,DODEL	; Yes - Process it
     922/    3811 : 3A 89 80            	LD	A,(NULFLG)	; Get null flag
     923/    3814 : B7                  	OR	A		; Test null flag status
     924/    3815 : CA 21 38            	JP	Z,PROCES	; Reset - Process character
     925/    3818 : 3E 00               	LD	A,0		; Set a null
     926/    381A : CD 93 38            	CALL	OUTC		; Output null
     927/    381D : AF                  	XOR	A		; Clear A
     928/    381E : 32 89 80            	LD	(NULFLG),A	; Reset null flag
     929/    3821 : 79                  PROCES: LD	A,C		; Get character
     930/    3822 : FE 07               	CP	CTRLG		; Bell?
     931/    3824 : CA 65 38            	JP	Z,PUTCTL	; Yes - Save it
     932/    3827 : FE 03               	CP	CTRLC		; Is it control "C"?
     933/    3829 : CC C2 3C            	CALL	Z,PRCRLF	; Yes - Output CRLF
     934/    382C : 37                  	SCF			; Flag break
     935/    382D : C8                  	RET	Z		; Return if control "C"
     936/    382E : FE 0D               	CP	CR		; Is it enter?
     937/    3830 : CA BD 3C            	JP	Z,ENDINP	; Yes - Terminate input
     938/    3833 : FE 15               	CP	CTRLU		; Is it control "U"?
     939/    3835 : CA F9 37            	JP	Z,KILIN		; Yes - Get another line
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 17 - 12/29/2022 20:41:36


     940/    3838 : FE 40               	CP	'@'		; Is it "kill line"?
     941/    383A : CA F6 37            	JP	Z,OTKLN		; Yes - Kill line
     942/    383D : FE 5F               	CP	'_'		; Is it delete?
     943/    383F : CA EE 37            	JP	Z,DELCHR	; Yes - Delete character
     944/    3842 : FE 08               	CP	BKSP		; Is it backspace?
     945/    3844 : CA EE 37            	JP	Z,DELCHR	; Yes - Delete character
     946/    3847 : FE 12               	CP	CTRLR		; Is it control "R"?
     947/    3849 : C2 60 38            	JP	NZ,PUTBUF	; No - Put in buffer
     948/    384C : C5                  	PUSH	BC		; Save buffer length
     949/    384D : D5                  	PUSH	DE		; Save DE
     950/    384E : E5                  	PUSH	HL		; Save buffer address
     951/    384F : 36 00               	LD	(HL),0		; Mark end of buffer
     952/    3851 : CD 83 4E            	CALL	OUTNCR		; Output and do CRLF
     953/    3854 : 21 A6 80            	LD	HL,BUFFER	; Point to buffer start
     954/    3857 : CD 61 43            	CALL	PRS		; Output buffer
     955/    385A : E1                  	POP	HL		; Restore buffer address
     956/    385B : D1                  	POP	DE		; Restore DE
     957/    385C : C1                  	POP	BC		; Restore buffer length
     958/    385D : C3 08 38            	JP	MORINP		; Get another character
     959/    3860 :                     ;
     960/    3860 : FE 20               PUTBUF: CP	' '		; Is it a control code?
     961/    3862 : DA 08 38            	JP	C,MORINP	; Yes - Ignore
     962/    3865 : 78                  PUTCTL: LD	A,B		; Get number of bytes in buffer
     963/    3866 : FE 49               	CP	72+1		; Test for line overflow
     964/    3868 : 3E 07               	LD	A,CTRLG		; Set a bell
     965/    386A : D2 7A 38            	JP	NC,OUTNBS	; Ring bell if buffer full
     966/    386D : 79                  	LD	A,C		; Get character
     967/    386E : 71                  	LD	(HL),C		; Save in buffer
     968/    386F : 32 11 81            	LD	(LSTBIN),A	; Save last input byte
     969/    3872 : 23                  	INC	HL		; Move up buffer
     970/    3873 : 04                  	INC	B		; Increment length
     971/    3874 : CD 93 38            OUTIT:	CALL	OUTC		; Output the character entered
     972/    3877 : C3 08 38            	JP	MORINP		; Get another character
     973/    387A :                     ;
     974/    387A : CD 93 38            OUTNBS: CALL	OUTC		; Output bell and back over it
     975/    387D : 3E 08               	LD	A,BKSP		; Set back space
     976/    387F : C3 74 38            	JP	OUTIT		; Output it and get more
     977/    3882 :                     ;
     978/    3882 : 7C                  CPDEHL: LD	A,H		; Get H
     979/    3883 : 92                  	SUB	D		; Compare with D
     980/    3884 : C0                  	RET	NZ		; Different - Exit
     981/    3885 : 7D                  	LD	A,L		; Get L
     982/    3886 : 93                  	SUB	E		; Compare with E
     983/    3887 : C9                  	RET			; Return status
     984/    3888 :                     ;
     985/    3888 : 7E                  CHKSYN: LD	A,(HL)		; Check syntax of character
     986/    3889 : E3                  	EX	(SP),HL		; Address of test byte
     987/    388A : BE                  	CP	(HL)		; Same as in code string?
     988/    388B : 23                  	INC	HL		; Return address
     989/    388C : E3                  	EX	(SP),HL		; Put it back
     990/    388D : CA 16 3A            	JP	Z,GETCHR	; Yes - Get next character
     991/    3890 : C3 BA 35            	JP	SNERR		; Different - ?SN Error
     992/    3893 :                     ;
     993/    3893 : F5                  OUTC:	PUSH	AF		; Save character
     994/    3894 : 3A 8A 80            	LD	A,(CTLOFG)	; Get control "O" flag
     995/    3897 : B7                  	OR	A		; Is it set?
     996/    3898 : C2 96 43            	JP	NZ,POPAF	; Yes - don't output
     997/    389B : F1                  	POP	AF		; Restore character
     998/    389C : C5                  	PUSH	BC		; Save buffer length
     999/    389D : F5                  	PUSH	AF		; Save character
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 18 - 12/29/2022 20:41:36


    1000/    389E : FE 20               	CP	' '		; Is it a control code?
    1001/    38A0 : DA B7 38            	JP	C,DINPOS	; Yes - Don't INC POS(X)
    1002/    38A3 : 3A 87 80            	LD	A,(LWIDTH)	; Get line width
    1003/    38A6 : 47                  	LD	B,A		; To B
    1004/    38A7 : 3A F0 80            	LD	A,(CURPOS)	; Get cursor position
    1005/    38AA : 04                  	INC	B		; Width 255?
    1006/    38AB : CA B3 38            	JP	Z,INCLEN	; Yes - No width limit
    1007/    38AE : 05                  	DEC	B		; Restore width
    1008/    38AF : B8                  	CP	B		; At end of line?
    1009/    38B0 : CC C2 3C            	CALL	Z,PRCRLF	; Yes - output CRLF
    1010/    38B3 : 3C                  INCLEN: INC	A		; Move on one character
    1011/    38B4 : 32 F0 80            	LD	(CURPOS),A	; Save new position
    1012/    38B7 : F1                  DINPOS: POP	AF		; Restore character
    1013/    38B8 : C1                  	POP	BC		; Restore buffer length
    1014/    38B9 : CD 6D 4E            	CALL	MONOUT		; Send it
    1015/    38BC : C9                  	RET
    1016/    38BD :                     ;
    1017/    38BD : CD 22 4D            CLOTST: CALL	GETINP		; Get input character
    1018/    38C0 : E6 7F               	AND	01111111B	; Strip bit 7
    1019/    38C2 : FE 0F               	CP	CTRLO		; Is it control "O"?
    1020/    38C4 : C0                  	RET	NZ		; No don't flip flag
    1021/    38C5 : 3A 8A 80            	LD	A,(CTLOFG)	; Get flag
    1022/    38C8 : 2F                  	CPL			; Flip it
    1023/    38C9 : 32 8A 80            	LD	(CTLOFG),A	; Put it back
    1024/    38CC : AF                  	XOR	A		; Null character
    1025/    38CD : C9                  	RET
    1026/    38CE :                     ;
    1027/    38CE : CD E6 3A            LIST:	CALL	ATOH		; ASCII number to DE
    1028/    38D1 : C0                  	RET	NZ		; Return if anything extra
    1029/    38D2 : C1                  	POP	BC		; Rubbish - Not needed
    1030/    38D3 : CD A6 36            	CALL	SRCHLN		; Search for line number in DE
    1031/    38D6 : C5                  	PUSH	BC		; Save address of line
    1032/    38D7 : CD 24 39            	CALL	SETLIN		; Set up lines counter
    1033/    38DA : E1                  LISTLP: POP	HL		; Restore address of line
    1034/    38DB : 4E                  	LD	C,(HL)		; Get LSB of next line
    1035/    38DC : 23                  	INC	HL
    1036/    38DD : 46                  	LD	B,(HL)		; Get MSB of next line
    1037/    38DE : 23                  	INC	HL
    1038/    38DF : 78                  	LD	A,B		; BC = 0 (End of program)?
    1039/    38E0 : B1                  	OR	C
    1040/    38E1 : CA 05 36            	JP	Z,PRNTOK	; Yes - Go to command mode
    1041/    38E4 : CD 2D 39            	CALL	COUNT		; Count lines
    1042/    38E7 : CD 41 3A            	CALL	TSTBRK		; Test for break key
    1043/    38EA : C5                  	PUSH	BC		; Save address of next line
    1044/    38EB : CD C2 3C            	CALL	PRCRLF		; Output CRLF
    1045/    38EE : 5E                  	LD	E,(HL)		; Get LSB of line number
    1046/    38EF : 23                  	INC	HL
    1047/    38F0 : 56                  	LD	D,(HL)		; Get MSB of line number
    1048/    38F1 : 23                  	INC	HL
    1049/    38F2 : E5                  	PUSH	HL		; Save address of line start
    1050/    38F3 : EB                  	EX	DE,HL		; Line number to HL
    1051/    38F4 : CD 06 4A            	CALL	PRNTHL		; Output line number in decimal
    1052/    38F7 : 3E 20               	LD	A,' '		; Space after line number
    1053/    38F9 : E1                  	POP	HL		; Restore start of line address
    1054/    38FA : CD 93 38            LSTLP2: CALL	OUTC		; Output character in A
    1055/    38FD : 7E                  LSTLP3: LD	A,(HL)		; Get next byte in line
    1056/    38FE : B7                  	OR	A		; End of line?
    1057/    38FF : 23                  	INC	HL		; To next byte in line
    1058/    3900 : CA DA 38            	JP	Z,LISTLP	; Yes - get next line
    1059/    3903 : F2 FA 38            	JP	P,LSTLP2	; No token - output it
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 19 - 12/29/2022 20:41:36


    1060/    3906 : D6 7F               	SUB	ZEND-1		; Find and output word
    1061/    3908 : 4F                  	LD	C,A		; Token offset+1 to C
    1062/    3909 : 11 43 33            	LD	DE,WORDS	; Reserved word list
    1063/    390C : 1A                  FNDTOK: LD	A,(DE)		; Get character in list
    1064/    390D : 13                  	INC	DE		; Move on to next
    1065/    390E : B7                  	OR	A		; Is it start of word?
    1066/    390F : F2 0C 39            	JP	P,FNDTOK	; No - Keep looking for word
    1067/    3912 : 0D                  	DEC	C		; Count words
    1068/    3913 : C2 0C 39            	JP	NZ,FNDTOK	; Not there - keep looking
    1069/    3916 : E6 7F               OUTWRD: AND	01111111B	; Strip bit 7
    1070/    3918 : CD 93 38            	CALL	OUTC		; Output first character
    1071/    391B : 1A                  	LD	A,(DE)		; Get next character
    1072/    391C : 13                  	INC	DE		; Move on to next
    1073/    391D : B7                  	OR	A		; Is it end of word?
    1074/    391E : F2 16 39            	JP	P,OUTWRD	; No - output the rest
    1075/    3921 : C3 FD 38            	JP	LSTLP3		; Next byte in line
    1076/    3924 :                     ;
    1077/    3924 : E5                  SETLIN: PUSH	HL		; Set up LINES counter
    1078/    3925 : 2A 8D 80            	LD	HL,(LINESN)	; Get LINES number
    1079/    3928 : 22 8B 80            	LD	(LINESC),HL	; Save in LINES counter
    1080/    392B : E1                  	POP	HL
    1081/    392C : C9                  	RET
    1082/    392D :                     ;
    1083/    392D : E5                  COUNT:	PUSH	HL		; Save code string address
    1084/    392E : D5                  	PUSH	DE
    1085/    392F : 2A 8B 80            	LD	HL,(LINESC)	; Get LINES counter
    1086/    3932 : 11 FF FF            	LD	DE,-1
    1087/    3935 :                     ;	ADC	HL,DE		; Decrement
    1088/    3935 : 7B                  	LD	A,E		;REPLACE Z80 CODE
    1089/    3936 : 8D                  	ADC	A,L		;REPLACE Z80 CODE
    1090/    3937 : 6F                  	LD	L,A		;REPLACE Z80 CODE
    1091/    3938 : 7A                  	LD	A,D		;REPLACE Z80 CODE
    1092/    3939 : 8C                  	ADC	A,H		;REPLACE Z80 CODE
    1093/    393A : 67                  	LD	H,A		;REPLACE Z80 CODE
    1094/    393B :                     ;
    1095/    393B : 22 8B 80            	LD	(LINESC),HL	; Put it back
    1096/    393E : D1                  	POP	DE
    1097/    393F : E1                  	POP	HL		; Restore code string address
    1098/    3940 : F0                  	RET	P		; Return if more lines to go
    1099/    3941 : E5                  	PUSH	HL		; Save code string address
    1100/    3942 : 2A 8D 80            	LD	HL,(LINESN)	; Get LINES number
    1101/    3945 : 22 8B 80            	LD	(LINESC),HL	; Reset LINES counter
    1102/    3948 : CD 22 4D            	CALL	GETINP		; Get input character
    1103/    394B : FE 03               	CP	CTRLC		; Is it control "C"?
    1104/    394D : CA 54 39            	JP	Z,RSLNBK	; Yes - Reset LINES and break
    1105/    3950 : E1                  	POP	HL		; Restore code string address
    1106/    3951 : C3 2D 39            	JP	COUNT		; Keep on counting
    1107/    3954 :                     ;
    1108/    3954 : 2A 8D 80            RSLNBK: LD	HL,(LINESN)	; Get LINES number
    1109/    3957 : 22 8B 80            	LD	(LINESC),HL	; Reset LINES counter
    1110/    395A : C3 7E 32            	JP	BRKRET		; Go and output "Break"
    1111/    395D :                     ;
    1112/    395D : 3E 64               FOR:	LD	A,64H		; Flag "FOR" assignment
    1113/    395F : 32 10 81            	LD	(FORFLG),A	; Save "FOR" flag
    1114/    3962 : CD C8 3B            	CALL	LET		; Set up initial index
    1115/    3965 : C1                  	POP	BC		; Drop RETurn address
    1116/    3966 : E5                  	PUSH	HL		; Save code string address
    1117/    3967 : CD B1 3B            	CALL	DATA		; Get next statement address
    1118/    396A : 22 0C 81            	LD	(LOOPST),HL	; Save it for start of loop
    1119/    396D : 21 02 00            	LD	HL,2		; Offset for "FOR" block
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 20 - 12/29/2022 20:41:36


    1120/    3970 : 39                  	ADD	HL,SP		; Point to it
    1121/    3971 : CD 67 35            FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
    1122/    3974 : D1                  	POP	DE		; Get code string address
    1123/    3975 : C2 8D 39            	JP	NZ,FORFND	; No nesting found
    1124/    3978 : 09                  	ADD	HL,BC		; Move into "FOR" block
    1125/    3979 : D5                  	PUSH	DE		; Save code string address
    1126/    397A : 2B                  	DEC	HL
    1127/    397B : 56                  	LD	D,(HL)		; Get MSB of loop statement
    1128/    397C : 2B                  	DEC	HL
    1129/    397D : 5E                  	LD	E,(HL)		; Get LSB of loop statement
    1130/    397E : 23                  	INC	HL
    1131/    397F : 23                  	INC	HL
    1132/    3980 : E5                  	PUSH	HL		; Save block address
    1133/    3981 : 2A 0C 81            	LD	HL,(LOOPST)	; Get address of loop statement
    1134/    3984 : CD 82 38            	CALL	CPDEHL		; Compare the FOR loops
    1135/    3987 : E1                  	POP	HL		; Restore block address
    1136/    3988 : C2 71 39            	JP	NZ,FORSLP	; Different FORs - Find another
    1137/    398B : D1                  	POP	DE		; Restore code string address
    1138/    398C : F9                  	LD	SP,HL		; Remove all nested loops
    1139/    398D :                     ;
    1140/    398D : EB                  FORFND: EX	DE,HL		; Code string address to HL
    1141/    398E : 0E 08               	LD	C,8
    1142/    3990 : CD 97 35            	CALL	CHKSTK		; Check for 8 levels of stack
    1143/    3993 : E5                  	PUSH	HL		; Save code string address
    1144/    3994 : 2A 0C 81            	LD	HL,(LOOPST)	; Get first statement of loop
    1145/    3997 : E3                  	EX	(SP),HL		; Save and restore code string
    1146/    3998 : E5                  	PUSH	HL		; Re-save code string address
    1147/    3999 : 2A A1 80            	LD	HL,(LINEAT)	; Get current line number
    1148/    399C : E3                  	EX	(SP),HL		; Save and restore code string
    1149/    399D : CD 8A 3E            	CALL	TSTNUM		; Make sure it's a number
    1150/    39A0 : CD 88 38            	CALL	CHKSYN		; Make sure "TO" is next
    1151/    39A3 : A6                  	DB	ZTO		; "TO" token
    1152/    39A4 : CD 87 3E            	CALL	GETNUM		; Get "TO" expression value
    1153/    39A7 : E5                  	PUSH	HL		; Save code string address
    1154/    39A8 : CD B8 48            	CALL	BCDEFP		; Move "TO" value to BCDE
    1155/    39AB : E1                  	POP	HL		; Restore code string address
    1156/    39AC : C5                  	PUSH	BC		; Save "TO" value in block
    1157/    39AD : D5                  	PUSH	DE
    1158/    39AE : 01 00 81            	LD	BC,8100H	; BCDE - 1 (default STEP)
    1159/    39B1 : 51                  	LD	D,C		; C=0
    1160/    39B2 : 5A                  	LD	E,D		; D=0
    1161/    39B3 : 7E                  	LD	A,(HL)		; Get next byte in code string
    1162/    39B4 : FE AB               	CP	ZSTEP		; See if "STEP" is stated
    1163/    39B6 : 3E 01               	LD	A,1		; Sign of step = 1
    1164/    39B8 : C2 C9 39            	JP	NZ,SAVSTP	; No STEP given - Default to 1
    1165/    39BB : CD 16 3A            	CALL	GETCHR		; Jump over "STEP" token
    1166/    39BE : CD 87 3E            	CALL	GETNUM		; Get step value
    1167/    39C1 : E5                  	PUSH	HL		; Save code string address
    1168/    39C2 : CD B8 48            	CALL	BCDEFP		; Move STEP to BCDE
    1169/    39C5 : CD 6C 48            	CALL	TSTSGN		; Test sign of FPREG
    1170/    39C8 : E1                  	POP	HL		; Restore code string address
    1171/    39C9 : C5                  SAVSTP: PUSH	BC		; Save the STEP value in block
    1172/    39CA : D5                  	PUSH	DE
    1173/    39CB : F5                  	PUSH	AF		; Save sign of STEP
    1174/    39CC : 33                  	INC	SP		; Don't save flags
    1175/    39CD : E5                  	PUSH	HL		; Save code string address
    1176/    39CE : 2A 13 81            	LD	HL,(BRKLIN)	; Get address of index variable
    1177/    39D1 : E3                  	EX	(SP),HL		; Save and restore code string
    1178/    39D2 : 06 81               PUTFID: LD	B,ZFOR		; "FOR" block marker
    1179/    39D4 : C5                  	PUSH	BC		; Save it
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 21 - 12/29/2022 20:41:36


    1180/    39D5 : 33                  	INC	SP		; Don't save C
    1181/    39D6 :                     ;
    1182/    39D6 : CD 41 3A            RUNCNT: CALL	TSTBRK		; Execution driver - Test break
    1183/    39D9 : 22 13 81            	LD	(BRKLIN),HL	; Save code address for break
    1184/    39DC : 7E                  	LD	A,(HL)		; Get next byte in code string
    1185/    39DD : FE 3A               	CP	':'		; Multi statement line?
    1186/    39DF : CA F6 39            	JP	Z,EXCUTE	; Yes - Execute it
    1187/    39E2 : B7                  	OR	A		; End of line?
    1188/    39E3 : C2 BA 35            	JP	NZ,SNERR	; No - Syntax error
    1189/    39E6 : 23                  	INC	HL		; Point to address of next line
    1190/    39E7 : 7E                  	LD	A,(HL)		; Get LSB of line pointer
    1191/    39E8 : 23                  	INC	HL
    1192/    39E9 : B6                  	OR	(HL)		; Is it zero (End of prog)?
    1193/    39EA : CA 6C 3A            	JP	Z,ENDPRG	; Yes - Terminate execution
    1194/    39ED : 23                  	INC	HL		; Point to line number
    1195/    39EE : 5E                  	LD	E,(HL)		; Get LSB of line number
    1196/    39EF : 23                  	INC	HL
    1197/    39F0 : 56                  	LD	D,(HL)		; Get MSB of line number
    1198/    39F1 : EB                  	EX	DE,HL		; Line number to HL
    1199/    39F2 : 22 A1 80            	LD	(LINEAT),HL	; Save as current line number
    1200/    39F5 : EB                  	EX	DE,HL		; Line number back to DE
    1201/    39F6 : CD 16 3A            EXCUTE: CALL	GETCHR		; Get key word
    1202/    39F9 : 11 D6 39            	LD	DE,RUNCNT	; Where to RETurn to
    1203/    39FC : D5                  	PUSH	DE		; Save for RETurn
    1204/    39FD : C8                  IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
    1205/    39FE : D6 80               ONJMP:	SUB	ZEND		; Is it a token?
    1206/    3A00 : DA C8 3B            	JP	C,LET		; No - try to assign it
    1207/    3A03 : FE 25               	CP	ZNEW+1-ZEND	; END to NEW ?
    1208/    3A05 : D2 BA 35            	JP	NC,SNERR	; Not a key word - ?SN Error
    1209/    3A08 : 07                  	RLCA			; Double it
    1210/    3A09 : 4F                  	LD	C,A		; BC = Offset into table
    1211/    3A0A : 06 00               	LD	B,0
    1212/    3A0C : EB                  	EX	DE,HL		; Save code string address
    1213/    3A0D : 21 62 34            	LD	HL,WORDTB	; Keyword address table
    1214/    3A10 : 09                  	ADD	HL,BC		; Point to routine address
    1215/    3A11 : 4E                  	LD	C,(HL)		; Get LSB of routine address
    1216/    3A12 : 23                  	INC	HL
    1217/    3A13 : 46                  	LD	B,(HL)		; Get MSB of routine address
    1218/    3A14 : C5                  	PUSH	BC		; Save routine address
    1219/    3A15 : EB                  	EX	DE,HL		; Restore code string address
    1220/    3A16 :                     ;
    1221/    3A16 : 23                  GETCHR: INC	HL		; Point to next character
    1222/    3A17 : 7E                  	LD	A,(HL)		; Get next code string byte
    1223/    3A18 : FE 3A               	CP	':'		; Z if ':'
    1224/    3A1A : D0                  	RET	NC		; NC if > "9"
    1225/    3A1B : FE 20               	CP	' '
    1226/    3A1D : CA 16 3A            	JP	Z,GETCHR	; Skip over spaces
    1227/    3A20 : FE 30               	CP	'0'
    1228/    3A22 : 3F                  	CCF			; NC if < '0'
    1229/    3A23 : 3C                  	INC	A		; Test for zero - Leave carry
    1230/    3A24 : 3D                  	DEC	A		; Z if Null
    1231/    3A25 : C9                  	RET
    1232/    3A26 :                     ;
    1233/    3A26 : EB                  RESTOR: EX	DE,HL		; Save code string address
    1234/    3A27 : 2A A3 80            	LD	HL,(BASTXT)	; Point to start of program
    1235/    3A2A : CA 3B 3A            	JP	Z,RESTNL	; Just RESTORE - reset pointer
    1236/    3A2D : EB                  	EX	DE,HL		; Restore code string address
    1237/    3A2E : CD E6 3A            	CALL	ATOH		; Get line number to DE
    1238/    3A31 : E5                  	PUSH	HL		; Save code string address
    1239/    3A32 : CD A6 36            	CALL	SRCHLN		; Search for line number in DE
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 22 - 12/29/2022 20:41:36


    1240/    3A35 : 60                  	LD	H,B		; HL = Address of line
    1241/    3A36 : 69                  	LD	L,C
    1242/    3A37 : D1                  	POP	DE		; Restore code string address
    1243/    3A38 : D2 87 3B            	JP	NC,ULERR	; ?UL Error if not found
    1244/    3A3B : 2B                  RESTNL: DEC	HL		; Byte before DATA statement
    1245/    3A3C : 22 21 81            UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
    1246/    3A3F : EB                  	EX	DE,HL		; Restore code string address
    1247/    3A40 : C9                  	RET
    1248/    3A41 :                     ;
    1249/    3A41 :                     
    1250/    3A41 : DF                  TSTBRK: RST	18H		; Check input status
    1251/    3A42 : C8                  	RET	Z		; No key, go back
    1252/    3A43 : D7                  	RST	10H		; Get the key into A
    1253/    3A44 : FE 1B               	CP	ESC		; Escape key?
    1254/    3A46 : CA 5D 3A            	JP	Z,BRK		; Yes, break
    1255/    3A49 : FE 03               	CP	CTRLC		; <Ctrl-C>
    1256/    3A4B : CA 5D 3A            	JP	Z,BRK		; Yes, break
    1257/    3A4E : FE 13               	CP	CTRLS		; Stop scrolling?
    1258/    3A50 : C0                  	RET	NZ		; Other key, ignore
    1259/    3A51 :                     ;
    1260/    3A51 :                     
    1261/    3A51 : D7                  STALL:	RST	10H		; Wait for key
    1262/    3A52 : FE 11               	CP	CTRLQ		; Resume scrolling?
    1263/    3A54 : C8                  	RET	Z		; Release the chokehold
    1264/    3A55 : FE 03               	CP	CTRLC		; Second break?
    1265/    3A57 : CA 62 3A            	JP	Z,STOP		; Break during hold exits prog
    1266/    3A5A : C3 51 3A            	JP	STALL		; Loop until <Ctrl-Q> or <brk>
    1267/    3A5D :                     ;
    1268/    3A5D : 3E FF               BRK	LD	A,0FFH		; Set BRKFLG
    1269/    3A5F : 32 92 80            	LD	(BRKFLG),A	; Store it
    1270/    3A62 :                     ;
    1271/    3A62 :                     
    1272/    3A62 : C0                  STOP:	RET	NZ		; Exit if anything else
    1273/    3A63 : F6                  	DB	0F6H		; Flag "STOP"
    1274/    3A64 : C0                  PEND:	RET	NZ		; Exit if anything else
    1275/    3A65 : 22 13 81            	LD	(BRKLIN),HL	; Save point of break
    1276/    3A68 : 21                  	DB	21H		; Skip "OR 11111111B"
    1277/    3A69 : F6 FF               INPBRK: OR	11111111B	; Flag "Break" wanted
    1278/    3A6B : C1                  	POP	BC		; Return not needed and more
    1279/    3A6C : 2A A1 80            ENDPRG: LD	HL,(LINEAT)	; Get current line number
    1280/    3A6F : F5                  	PUSH	AF		; Save STOP / END status
    1281/    3A70 : 7D                  	LD	A,L		; Is it direct break?
    1282/    3A71 : A4                  	AND	H
    1283/    3A72 : 3C                  	INC	A		; Line is -1 if direct break
    1284/    3A73 : CA 7F 3A            	JP	Z,NOLIN		; Yes - No line number
    1285/    3A76 : 22 17 81            	LD	(ERRLIN),HL	; Save line of break
    1286/    3A79 : 2A 13 81            	LD	HL,(BRKLIN)	; Get point of break
    1287/    3A7C : 22 19 81            	LD	(CONTAD),HL	; Save point to CONTinue
    1288/    3A7F : AF                  NOLIN:	XOR	A
    1289/    3A80 : 32 8A 80            	LD	(CTLOFG),A	; Enable output
    1290/    3A83 : CD B5 3C            	CALL	STTLIN		; Start a new line
    1291/    3A86 : F1                  	POP	AF		; Restore STOP / END status
    1292/    3A87 : 21 5D 35            	LD	HL,BRKMSG	; "Break" message
    1293/    3A8A : C2 EE 35            	JP	NZ,ERRIN	; "in line" wanted?
    1294/    3A8D : C3 05 36            	JP	PRNTOK		; Go to command mode
    1295/    3A90 :                     ;
    1296/    3A90 : 2A 19 81            CONT:	LD	HL,(CONTAD)	; Get CONTinue address
    1297/    3A93 : 7C                  	LD	A,H		; Is it zero?
    1298/    3A94 : B5                  	OR	L
    1299/    3A95 : 1E 20               	LD	E,CN		; ?CN Error
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 23 - 12/29/2022 20:41:36


    1300/    3A97 : CA CE 35            	JP	Z,ERROR		; Yes - output "?CN Error"
    1301/    3A9A : EB                  	EX	DE,HL		; Save code string address
    1302/    3A9B : 2A 17 81            	LD	HL,(ERRLIN)	; Get line of last break
    1303/    3A9E : 22 A1 80            	LD	(LINEAT),HL	; Set up current line number
    1304/    3AA1 : EB                  	EX	DE,HL		; Restore code string address
    1305/    3AA2 : C9                  	RET			; CONTinue where left off
    1306/    3AA3 :                     ;
    1307/    3AA3 : CD EB 45            NULL:	CALL	GETINT		; Get integer 0-255
    1308/    3AA6 : C0                  	RET	NZ		; Return if bad value
    1309/    3AA7 : 32 86 80            	LD	(NULLS),A	; Set nulls number
    1310/    3AAA : C9                  	RET
    1311/    3AAB :                     ;
    1312/    3AAB :                     
    1313/    3AAB : E5                  ACCSUM: PUSH	HL		; Save address in array
    1314/    3AAC : 2A 8F 80            	LD	HL,(CHKSUM)	; Get check sum
    1315/    3AAF : 06 00               	LD	B,0		; BC - Value of byte
    1316/    3AB1 : 4F                  	LD	C,A
    1317/    3AB2 : 09                  	ADD	HL,BC		; Add byte to check sum
    1318/    3AB3 : 22 8F 80            	LD	(CHKSUM),HL	; Re-save check sum
    1319/    3AB6 : E1                  	POP	HL		; Restore address in array
    1320/    3AB7 : C9                  	RET
    1321/    3AB8 :                     ;
    1322/    3AB8 : 7E                  CHKLTR: LD	A,(HL)		; Get byte
    1323/    3AB9 : FE 41               	CP	'A'		; < 'a' ?
    1324/    3ABB : D8                  	RET	C		; Carry set if not letter
    1325/    3ABC : FE 5B               	CP	'Z'+1		; > 'z' ?
    1326/    3ABE : 3F                  	CCF
    1327/    3ABF : C9                  	RET			; Carry set if not letter
    1328/    3AC0 :                     ;
    1329/    3AC0 : CD 16 3A            FPSINT: CALL	GETCHR		; Get next character
    1330/    3AC3 : CD 87 3E            POSINT: CALL	GETNUM		; Get integer 0 to 32767
    1331/    3AC6 : CD 6C 48            DEPINT: CALL	TSTSGN		; Test sign of FPREG
    1332/    3AC9 : FA E1 3A            	JP	M,FCERR		; Negative - ?FC Error
    1333/    3ACC : 3A 2C 81            DEINT:	LD	A,(FPEXP)	; Get integer value to DE
    1334/    3ACF : FE 90               	CP	80H+16		; Exponent in range (16 bits)?
    1335/    3AD1 : DA 14 49            	JP	C,FPINT		; Yes - convert it
    1336/    3AD4 : 01 80 90            	LD	BC,9080H	; BCDE = -32768
    1337/    3AD7 : 11 00 00            	LD	DE,0000
    1338/    3ADA : E5                  	PUSH	HL		; Save code string address
    1339/    3ADB : CD E7 48            	CALL	CMPNUM		; Compare FPREG with BCDE
    1340/    3ADE : E1                  	POP	HL		; Restore code string address
    1341/    3ADF : 51                  	LD	D,C		; MSB to D
    1342/    3AE0 : C8                  	RET	Z		; Return if in range
    1343/    3AE1 : 1E 08               FCERR:	LD	E,FC		; ?FC Error
    1344/    3AE3 : C3 CE 35            	JP	ERROR		; Output error-
    1345/    3AE6 :                     ;
    1346/    3AE6 : 2B                  ATOH:	DEC	HL		; ASCII number to DE binary
    1347/    3AE7 : 11 00 00            GETLN:	LD	DE,0		; Get number to DE
    1348/    3AEA : CD 16 3A            GTLNLP: CALL	GETCHR		; Get next character
    1349/    3AED : D0                  	RET	NC		; Exit if not a digit
    1350/    3AEE : E5                  	PUSH	HL		; Save code string address
    1351/    3AEF : F5                  	PUSH	AF		; Save digit
    1352/    3AF0 : 21 98 19            	LD	HL,65529/10	; Largest number 65529
    1353/    3AF3 : CD 82 38            	CALL	CPDEHL		; Number in range?
    1354/    3AF6 : DA BA 35            	JP	C,SNERR		; No - ?SN Error
    1355/    3AF9 : 62                  	LD	H,D		; HL = Number
    1356/    3AFA : 6B                  	LD	L,E
    1357/    3AFB : 19                  	ADD	HL,DE		; Times 2
    1358/    3AFC : 29                  	ADD	HL,HL		; Times 4
    1359/    3AFD : 19                  	ADD	HL,DE		; Times 5
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 24 - 12/29/2022 20:41:36


    1360/    3AFE : 29                  	ADD	HL,HL		; Times 10
    1361/    3AFF : F1                  	POP	AF		; Restore digit
    1362/    3B00 : D6 30               	SUB	'0'		; Make it 0 to 9
    1363/    3B02 : 5F                  	LD	E,A		; DE = Value of digit
    1364/    3B03 : 16 00               	LD	D,0
    1365/    3B05 : 19                  	ADD	HL,DE		; Add to number
    1366/    3B06 : EB                  	EX	DE,HL		; Number to DE
    1367/    3B07 : E1                  	POP	HL		; Restore code string address
    1368/    3B08 : C3 EA 3A            	JP	GTLNLP		; Go to next character
    1369/    3B0B :                     ;
    1370/    3B0B : CA D6 36            CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
    1371/    3B0E : CD C3 3A            	CALL	POSINT		; Get integer 0 to 32767 to DE
    1372/    3B11 : 2B                  	DEC	HL		; Cancel increment
    1373/    3B12 : CD 16 3A            	CALL	GETCHR		; Get next character
    1374/    3B15 : E5                  	PUSH	HL		; Save code string address
    1375/    3B16 : 2A F4 80            	LD	HL,(LSTRAM)	; Get end of RAM
    1376/    3B19 : CA 2E 3B            	JP	Z,STORED	; No value given - Use stored
    1377/    3B1C : E1                  	POP	HL		; Restore code string address
    1378/    3B1D : CD 88 38            	CALL	CHKSYN		; Check for comma
    1379/    3B20 : 2C                  	DB	','
    1380/    3B21 : D5                  	PUSH	DE		; Save number
    1381/    3B22 : CD C3 3A            	CALL	POSINT		; Get integer 0 to 32767
    1382/    3B25 : 2B                  	DEC	HL		; Cancel increment
    1383/    3B26 : CD 16 3A            	CALL	GETCHR		; Get next character
    1384/    3B29 : C2 BA 35            	JP	NZ,SNERR	; ?SN Error if more on line
    1385/    3B2C : E3                  	EX	(SP),HL		; Save code string address
    1386/    3B2D : EB                  	EX	DE,HL		; Number to DE
    1387/    3B2E : 7D                  STORED: LD	A,L		; Get LSB of new RAM top
    1388/    3B2F : 93                  	SUB	E		; Subtract LSB of string space
    1389/    3B30 : 5F                  	LD	E,A		; Save LSB
    1390/    3B31 : 7C                  	LD	A,H		; Get MSB of new RAM top
    1391/    3B32 : 9A                  	SBC	A,D		; Subtract MSB of string space
    1392/    3B33 : 57                  	LD	D,A		; Save MSB
    1393/    3B34 : DA AF 35            	JP	C,OMERR		; ?OM Error if not enough mem
    1394/    3B37 : E5                  	PUSH	HL		; Save RAM top
    1395/    3B38 : 2A 1B 81            	LD	HL,(PROGND)	; Get program end
    1396/    3B3B : 01 28 00            	LD	BC,40		; 40 Bytes minimum working RAM
    1397/    3B3E : 09                  	ADD	HL,BC		; Get lowest address
    1398/    3B3F : CD 82 38            	CALL	CPDEHL		; Enough memory?
    1399/    3B42 : D2 AF 35            	JP	NC,OMERR	; No - ?OM Error
    1400/    3B45 : EB                  	EX	DE,HL		; RAM top to HL
    1401/    3B46 : 22 9F 80            	LD	(STRSPC),HL	; Set new string space
    1402/    3B49 : E1                  	POP	HL		; End of memory to use
    1403/    3B4A : 22 F4 80            	LD	(LSTRAM),HL	; Set new top of RAM
    1404/    3B4D : E1                  	POP	HL		; Restore code string address
    1405/    3B4E : C3 D6 36            	JP	INTVAR		; Initialise variables
    1406/    3B51 :                     ;
    1407/    3B51 : CA D2 36            RUN:	JP	Z,RUNFST	; RUN from start if just RUN
    1408/    3B54 : CD D6 36            	CALL	INTVAR		; Initialise variables
    1409/    3B57 : 01 D6 39            	LD	BC,RUNCNT	; Execution driver loop
    1410/    3B5A : C3 6D 3B            	JP	RUNLIN		; RUN from line number
    1411/    3B5D :                     ;
    1412/    3B5D : 0E 03               GOSUB:	LD	C,3		; 3 Levels of stack needed
    1413/    3B5F : CD 97 35            	CALL	CHKSTK		; Check for 3 levels of stack
    1414/    3B62 : C1                  	POP	BC		; Get return address
    1415/    3B63 : E5                  	PUSH	HL		; Save code string for RETURN
    1416/    3B64 : E5                  	PUSH	HL		; And for GOSUB routine
    1417/    3B65 : 2A A1 80            	LD	HL,(LINEAT)	; Get current line
    1418/    3B68 : E3                  	EX	(SP),HL		; Into stack - Code string out
    1419/    3B69 : 3E 8C               	LD	A,ZGOSUB	; "GOSUB" token
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 25 - 12/29/2022 20:41:36


    1420/    3B6B : F5                  	PUSH	AF		; Save token
    1421/    3B6C : 33                  	INC	SP		; Don't save flags
    1422/    3B6D :                     ;
    1423/    3B6D : C5                  RUNLIN: PUSH	BC		; Save return address
    1424/    3B6E : CD E6 3A            GOTO:	CALL	ATOH		; ASCII number to DE binary
    1425/    3B71 : CD B3 3B            	CALL	REM		; Get end of line
    1426/    3B74 : E5                  	PUSH	HL		; Save end of line
    1427/    3B75 : 2A A1 80            	LD	HL,(LINEAT)	; Get current line
    1428/    3B78 : CD 82 38            	CALL	CPDEHL		; Line after current?
    1429/    3B7B : E1                  	POP	HL		; Restore end of line
    1430/    3B7C : 23                  	INC	HL		; Start of next line
    1431/    3B7D : DC A9 36            	CALL	C,SRCHLP	; Line is after current line
    1432/    3B80 : D4 A6 36            	CALL	NC,SRCHLN	; Line is before current line
    1433/    3B83 : 60                  	LD	H,B		; Set up code string address
    1434/    3B84 : 69                  	LD	L,C
    1435/    3B85 : 2B                  	DEC	HL		; Incremented after
    1436/    3B86 : D8                  	RET	C		; Line found
    1437/    3B87 : 1E 0E               ULERR:	LD	E,UL		; ?UL Error
    1438/    3B89 : C3 CE 35            	JP	ERROR		; Output error message
    1439/    3B8C :                     ;
    1440/    3B8C : C0                  RETURN: RET	NZ		; Return if not just RETURN
    1441/    3B8D : 16 FF               	LD	D,-1		; Flag "GOSUB" search
    1442/    3B8F : CD 63 35            	CALL	BAKSTK		; Look "GOSUB" block
    1443/    3B92 : F9                  	LD	SP,HL		; Kill all FORs in subroutine
    1444/    3B93 : FE 8C               	CP	ZGOSUB		; Test for "GOSUB" token
    1445/    3B95 : 1E 04               	LD	E,RG		; ?RG Error
    1446/    3B97 : C2 CE 35            	JP	NZ,ERROR	; Error if no "GOSUB" found
    1447/    3B9A : E1                  	POP	HL		; Get RETURN line number
    1448/    3B9B : 22 A1 80            	LD	(LINEAT),HL	; Save as current
    1449/    3B9E : 23                  	INC	HL		; Was it from direct statement?
    1450/    3B9F : 7C                  	LD	A,H
    1451/    3BA0 : B5                  	OR	L		; Return to line
    1452/    3BA1 : C2 AB 3B            	JP	NZ,RETLIN	; No - Return to line
    1453/    3BA4 : 3A 11 81            	LD	A,(LSTBIN)	; Any INPUT in subroutine?
    1454/    3BA7 : B7                  	OR	A		; If so buffer is corrupted
    1455/    3BA8 : C2 04 36            	JP	NZ,POPNOK	; Yes - Go to command mode
    1456/    3BAB : 21 D6 39            RETLIN: LD	HL,RUNCNT	; Execution driver loop
    1457/    3BAE : E3                  	EX	(SP),HL		; Into stack - Code string out
    1458/    3BAF : 3E                  	DB	3EH		; Skip "POP HL"
    1459/    3BB0 : E1                  NXTDTA: POP	HL		; Restore code string address
    1460/    3BB1 :                     ;
    1461/    3BB1 : 01 3A               DATA:	DB	01H,3AH		; ':' End of statement
    1462/    3BB3 : 0E 00               REM:	LD	C,0		; 00	End of statement
    1463/    3BB5 : 06 00               	LD	B,0
    1464/    3BB7 : 79                  NXTSTL: LD	A,C		; Statement and byte
    1465/    3BB8 : 48                  	LD	C,B
    1466/    3BB9 : 47                  	LD	B,A		; Statement end byte
    1467/    3BBA : 7E                  NXTSTT: LD	A,(HL)		; Get byte
    1468/    3BBB : B7                  	OR	A		; End of line?
    1469/    3BBC : C8                  	RET	Z		; Yes - Exit
    1470/    3BBD : B8                  	CP	B		; End of statement?
    1471/    3BBE : C8                  	RET	Z		; Yes - Exit
    1472/    3BBF : 23                  	INC	HL		; Next byte
    1473/    3BC0 : FE 22               	CP	'"'		; Literal string?
    1474/    3BC2 : CA B7 3B            	JP	Z,NXTSTL	; Yes - Look for another '"'
    1475/    3BC5 : C3 BA 3B            	JP	NXTSTT		; Keep looking
    1476/    3BC8 :                     ;
    1477/    3BC8 : CD 7E 40            LET:	CALL	GETVAR		; Get variable name
    1478/    3BCB : CD 88 38            	CALL	CHKSYN		; Make sure "=" follows
    1479/    3BCE : B4                  	DB	ZEQUAL		; "=" token
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 26 - 12/29/2022 20:41:36


    1480/    3BCF : D5                  	PUSH	DE		; Save address of variable
    1481/    3BD0 : 3A F2 80            	LD	A,(TYPE)	; Get data type
    1482/    3BD3 : F5                  	PUSH	AF		; Save type
    1483/    3BD4 : CD 99 3E            	CALL	EVAL		; Evaluate expression
    1484/    3BD7 : F1                  	POP	AF		; Restore type
    1485/    3BD8 : E3                  	EX	(SP),HL		; Save code - Get var addr
    1486/    3BD9 : 22 13 81            	LD	(BRKLIN),HL	; Save address of variable
    1487/    3BDC : 1F                  	RRA			; Adjust type
    1488/    3BDD : CD 8C 3E            	CALL	CHKTYP		; Check types are the same
    1489/    3BE0 : CA 1B 3C            	JP	Z,LETNUM	; Numeric - Move value
    1490/    3BE3 : E5                  LETSTR: PUSH	HL		; Save address of string var
    1491/    3BE4 : 2A 29 81            	LD	HL,(FPREG)	; Pointer to string entry
    1492/    3BE7 : E5                  	PUSH	HL		; Save it on stack
    1493/    3BE8 : 23                  	INC	HL		; Skip over length
    1494/    3BE9 : 23                  	INC	HL
    1495/    3BEA : 5E                  	LD	E,(HL)		; LSB of string address
    1496/    3BEB : 23                  	INC	HL
    1497/    3BEC : 56                  	LD	D,(HL)		; MSB of string address
    1498/    3BED : 2A A3 80            	LD	HL,(BASTXT)	; Point to start of program
    1499/    3BF0 : CD 82 38            	CALL	CPDEHL		; Is string before program?
    1500/    3BF3 : D2 0A 3C            	JP	NC,CRESTR	; Yes - Create string entry
    1501/    3BF6 : 2A 9F 80            	LD	HL,(STRSPC)	; Point to string space
    1502/    3BF9 : CD 82 38            	CALL	CPDEHL		; Is string literal in program?
    1503/    3BFC : D1                  	POP	DE		; Restore address of string
    1504/    3BFD : D2 12 3C            	JP	NC,MVSTPT	; Yes - Set up pointer
    1505/    3C00 : 21 04 81            	LD	HL,TMPSTR	; Temporary string pool
    1506/    3C03 : CD 82 38            	CALL	CPDEHL		; Is string in temporary pool?
    1507/    3C06 : D2 12 3C            	JP	NC,MVSTPT	; No - Set up pointer
    1508/    3C09 : 3E                  	DB	3EH		; Skip "POP DE"
    1509/    3C0A : D1                  CRESTR: POP	DE		; Restore address of string
    1510/    3C0B : CD C2 44            	CALL	BAKTMP		; Back to last tmp-str entry
    1511/    3C0E : EB                  	EX	DE,HL		; Address of string entry
    1512/    3C0F : CD FB 42            	CALL	SAVSTR		; Save string in string area
    1513/    3C12 : CD C2 44            MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
    1514/    3C15 : E1                  	POP	HL		; Get string pointer
    1515/    3C16 : CD C7 48            	CALL	DETHL4		; Move string pointer to var
    1516/    3C19 : E1                  	POP	HL		; Restore code string address
    1517/    3C1A : C9                  	RET
    1518/    3C1B :                     ;
    1519/    3C1B : E5                  LETNUM: PUSH	HL		; Save address of variable
    1520/    3C1C : CD C4 48            	CALL	FPTHL		; Move value to variable
    1521/    3C1F : D1                  	POP	DE		; Restore address of variable
    1522/    3C20 : E1                  	POP	HL		; Restore code string address
    1523/    3C21 : C9                  	RET
    1524/    3C22 :                     ;
    1525/    3C22 : CD EB 45            ON:	CALL	GETINT		; Get integer 0-255
    1526/    3C25 : 7E                  	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
    1527/    3C26 : 47                  	LD	B,A		; Save in B
    1528/    3C27 : FE 8C               	CP	ZGOSUB		; "GOSUB" token?
    1529/    3C29 : CA 31 3C            	JP	Z,ONGO		; Yes - Find line number
    1530/    3C2C : CD 88 38            	CALL	CHKSYN		; Make sure it's "GOTO"
    1531/    3C2F : 88                  	DB	ZGOTO		; "GOTO" token
    1532/    3C30 : 2B                  	DEC	HL		; Cancel increment
    1533/    3C31 : 4B                  ONGO:	LD	C,E		; Integer of branch value
    1534/    3C32 : 0D                  ONGOLP: DEC	C		; Count branches
    1535/    3C33 : 78                  	LD	A,B		; Get "GOTO" or "GOSUB" token
    1536/    3C34 : CA FE 39            	JP	Z,ONJMP		; Go to that line if right one
    1537/    3C37 : CD E7 3A            	CALL	GETLN		; Get line number to DE
    1538/    3C3A : FE 2C               	CP	','		; Another line number?
    1539/    3C3C : C0                  	RET	NZ		; No - Drop through
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 27 - 12/29/2022 20:41:36


    1540/    3C3D : C3 32 3C            	JP	ONGOLP		; Yes - loop
    1541/    3C40 :                     ;
    1542/    3C40 : CD 99 3E            IF:	CALL	EVAL		; Evaluate expression
    1543/    3C43 : 7E                  	LD	A,(HL)		; Get token
    1544/    3C44 : FE 88               	CP	ZGOTO		; "GOTO" token?
    1545/    3C46 : CA 4E 3C            	JP	Z,IFGO		; Yes - Get line
    1546/    3C49 : CD 88 38            	CALL	CHKSYN		; Make sure it's "THEN"
    1547/    3C4C : A9                  	DB	ZTHEN		; "THEN" token
    1548/    3C4D : 2B                  	DEC	HL		; Cancel increment
    1549/    3C4E : CD 8A 3E            IFGO:	CALL	TSTNUM		; Make sure it's numeric
    1550/    3C51 : CD 6C 48            	CALL	TSTSGN		; Test state of expression
    1551/    3C54 : CA B3 3B            	JP	Z,REM		; False - Drop through
    1552/    3C57 : CD 16 3A            	CALL	GETCHR		; Get next character
    1553/    3C5A : DA 6E 3B            	JP	C,GOTO		; Number - GOTO that line
    1554/    3C5D : C3 FD 39            	JP	IFJMP		; Otherwise do statement
    1555/    3C60 :                     ;
    1556/    3C60 : 2B                  MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
    1557/    3C61 : CD 16 3A            	CALL	GETCHR		; Get next character
    1558/    3C64 : CA C2 3C            PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
    1559/    3C67 : C8                  PRNTLP: RET	Z		; End of list - Exit
    1560/    3C68 : FE A5               	CP	ZTAB		; "TAB(" token?
    1561/    3C6A : CA F5 3C            	JP	Z,DOTAB		; Yes - Do TAB routine
    1562/    3C6D : FE A8               	CP	ZSPC		; "SPC(" token?
    1563/    3C6F : CA F5 3C            	JP	Z,DOTAB		; Yes - Do SPC routine
    1564/    3C72 : E5                  	PUSH	HL		; Save code string address
    1565/    3C73 : FE 2C               	CP	','		; Comma?
    1566/    3C75 : CA DE 3C            	JP	Z,DOCOM		; Yes - Move to next zone
    1567/    3C78 : FE 3B               	CP	59;";"		; Semi-colon?
    1568/    3C7A : CA 18 3D            	JP	Z,NEXITM	; Do semi-colon routine
    1569/    3C7D : C1                  	POP	BC		; Code string address to BC
    1570/    3C7E : CD 99 3E            	CALL	EVAL		; Evaluate expression
    1571/    3C81 : E5                  	PUSH	HL		; Save code string address
    1572/    3C82 : 3A F2 80            	LD	A,(TYPE)	; Get variable type
    1573/    3C85 : B7                  	OR	A		; Is it a string variable?
    1574/    3C86 : C2 AE 3C            	JP	NZ,PRNTST	; Yes - Output string contents
    1575/    3C89 : CD 11 4A            	CALL	NUMASC		; Convert number to text
    1576/    3C8C : CD 1F 43            	CALL	CRTST		; Create temporary string
    1577/    3C8F : 36 20               	LD	(HL),' '	; Followed by a space
    1578/    3C91 : 2A 29 81            	LD	HL,(FPREG)	; Get length of output
    1579/    3C94 : 34                  	INC	(HL)		; Plus 1 for the space
    1580/    3C95 : 2A 29 81            	LD	HL,(FPREG)	; < Not needed >
    1581/    3C98 : 3A 87 80            	LD	A,(LWIDTH)	; Get width of line
    1582/    3C9B : 47                  	LD	B,A		; To B
    1583/    3C9C : 04                  	INC	B		; Width 255 (No limit)?
    1584/    3C9D : CA AA 3C            	JP	Z,PRNTNB	; Yes - Output number string
    1585/    3CA0 : 04                  	INC	B		; Adjust it
    1586/    3CA1 : 3A F0 80            	LD	A,(CURPOS)	; Get cursor position
    1587/    3CA4 : 86                  	ADD	A,(HL)		; Add length of string
    1588/    3CA5 : 3D                  	DEC	A		; Adjust it
    1589/    3CA6 : B8                  	CP	B		; Will output fit on this line?
    1590/    3CA7 : D4 C2 3C            	CALL	NC,PRCRLF	; No - CRLF first
    1591/    3CAA : CD 64 43            PRNTNB: CALL	PRS1		; Output string at (HL)
    1592/    3CAD : AF                  	XOR	A		; Skip CALL by setting 'z' flag
    1593/    3CAE : C4 64 43            PRNTST: CALL	NZ,PRS1		; Output string at (HL)
    1594/    3CB1 : E1                  	POP	HL		; Restore code string address
    1595/    3CB2 : C3 60 3C            	JP	MRPRNT		; See if more to PRINT
    1596/    3CB5 :                     ;
    1597/    3CB5 : 3A F0 80            STTLIN: LD	A,(CURPOS)	; Make sure on new line
    1598/    3CB8 : B7                  	OR	A		; Already at start?
    1599/    3CB9 : C8                  	RET	Z		; Yes - Do nothing
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 28 - 12/29/2022 20:41:36


    1600/    3CBA : C3 C2 3C            	JP	PRCRLF		; Start a new line
    1601/    3CBD :                     ;
    1602/    3CBD : 36 00               ENDINP: LD	(HL),0		; Mark end of buffer
    1603/    3CBF : 21 A5 80            	LD	HL,BUFFER-1	; Point to buffer
    1604/    3CC2 : 3E 0D               PRCRLF: LD	A,CR		; Load a CR
    1605/    3CC4 : CD 93 38            	CALL	OUTC		; Output character
    1606/    3CC7 : 3E 0A               	LD	A,LF		; Load a LF
    1607/    3CC9 : CD 93 38            	CALL	OUTC		; Output character
    1608/    3CCC : AF                  DONULL: XOR	A		; Set to position 0
    1609/    3CCD : 32 F0 80            	LD	(CURPOS),A	; Store it
    1610/    3CD0 : 3A 86 80            	LD	A,(NULLS)	; Get number of nulls
    1611/    3CD3 : 3D                  NULLP:	DEC	A		; Count them
    1612/    3CD4 : C8                  	RET	Z		; Return if done
    1613/    3CD5 : F5                  	PUSH	AF		; Save count
    1614/    3CD6 : AF                  	XOR	A		; Load a null
    1615/    3CD7 : CD 93 38            	CALL	OUTC		; Output it
    1616/    3CDA : F1                  	POP	AF		; Restore count
    1617/    3CDB : C3 D3 3C            	JP	NULLP		; Keep counting
    1618/    3CDE :                     ;
    1619/    3CDE : 3A 88 80            DOCOM:	LD	A,(COMMAN)	; Get comma width
    1620/    3CE1 : 47                  	LD	B,A		; Save in B
    1621/    3CE2 : 3A F0 80            	LD	A,(CURPOS)	; Get current position
    1622/    3CE5 : B8                  	CP	B		; Within the limit?
    1623/    3CE6 : D4 C2 3C            	CALL	NC,PRCRLF	; No - output CRLF
    1624/    3CE9 : D2 18 3D            	JP	NC,NEXITM	; Get next item
    1625/    3CEC : D6 0E               ZONELP: SUB	14		; Next zone of 14 characters
    1626/    3CEE : D2 EC 3C            	JP	NC,ZONELP	; Repeat if more zones
    1627/    3CF1 : 2F                  	CPL			; Number of spaces to output
    1628/    3CF2 : C3 0D 3D            	JP	ASPCS		; Output them
    1629/    3CF5 :                     ;
    1630/    3CF5 : F5                  DOTAB:	PUSH	AF		; Save token
    1631/    3CF6 : CD E8 45            	CALL	FNDNUM		; Evaluate expression
    1632/    3CF9 : CD 88 38            	CALL	CHKSYN		; Make sure ")" follows
    1633/    3CFC : 29                  	DB	")"
    1634/    3CFD : 2B                  	DEC	HL		; Back space on to ")"
    1635/    3CFE : F1                  	POP	AF		; Restore token
    1636/    3CFF : D6 A8               	SUB	ZSPC		; Was it "SPC(" ?
    1637/    3D01 : E5                  	PUSH	HL		; Save code string address
    1638/    3D02 : CA 08 3D            	JP	Z,DOSPC	; Yes - Do 'E' spaces
    1639/    3D05 : 3A F0 80            	LD	A,(CURPOS)	; Get current position
    1640/    3D08 : 2F                  DOSPC:	CPL			; Number of spaces to print to
    1641/    3D09 : 83                  	ADD	A,E		; Total number to print
    1642/    3D0A : D2 18 3D            	JP	NC,NEXITM	; TAB < Current POS(X)
    1643/    3D0D : 3C                  ASPCS:	INC	A		; Output A spaces
    1644/    3D0E : 47                  	LD	B,A		; Save number to print
    1645/    3D0F : 3E 20               	LD	A,' '		; Space
    1646/    3D11 : CD 93 38            SPCLP:	CALL	OUTC		; Output character in A
    1647/    3D14 : 05                  	DEC	B		; Count them
    1648/    3D15 : C2 11 3D            	JP	NZ,SPCLP	; Repeat if more
    1649/    3D18 : E1                  NEXITM: POP	HL		; Restore code string address
    1650/    3D19 : CD 16 3A            	CALL	GETCHR		; Get next character
    1651/    3D1C : C3 67 3C            	JP	PRNTLP		; More to print
    1652/    3D1F :                     ;
    1653/    3D1F : 3F 52 65 64 6F 20   REDO:	DB	"?Redo from start",CR,LF,0
             3D25 : 66 72 6F 6D 20 73 
             3D2B : 74 61 72 74 0D 0A 
             3D31 : 00                
    1654/    3D32 :                     ;
    1655/    3D32 : 3A 12 81            BADINP: LD	A,(READFG)	; READ or INPUT?
    1656/    3D35 : B7                  	OR	A
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 29 - 12/29/2022 20:41:36


    1657/    3D36 : C2 B4 35            	JP	NZ,DATSNR	; READ - ?SN Error
    1658/    3D39 : C1                  	POP	BC		; Throw away code string addr
    1659/    3D3A : 21 1F 3D            	LD	HL,REDO		; "Redo from start" message
    1660/    3D3D : CD 61 43            	CALL	PRS		; Output string
    1661/    3D40 : C3 05 37            	JP	DOAGN		; Do last INPUT again
    1662/    3D43 :                     ;
    1663/    3D43 : CD CC 42            INPUT:	CALL	IDTEST		; Test for illegal direct
    1664/    3D46 : 7E                  	LD	A,(HL)		; Get character after "INPUT"
    1665/    3D47 : FE 22               	CP	'"'		; Is there a prompt string?
    1666/    3D49 : 3E 00               	LD	A,0		; Clear A and leave flags
    1667/    3D4B : 32 8A 80            	LD	(CTLOFG),A	; Enable output
    1668/    3D4E : C2 5D 3D            	JP	NZ,NOPMPT	; No prompt - get input
    1669/    3D51 : CD 20 43            	CALL	QTSTR		; Get string terminated by '"'
    1670/    3D54 : CD 88 38            	CALL	CHKSYN		; Check for ';' after prompt
    1671/    3D57 : 3B                  	DB	';'
    1672/    3D58 : E5                  	PUSH	HL		; Save code string address
    1673/    3D59 : CD 64 43            	CALL	PRS1		; Output prompt string
    1674/    3D5C : 3E                  	DB	3EH		; Skip "PUSH HL"
    1675/    3D5D : E5                  NOPMPT: PUSH	HL		; Save code string address
    1676/    3D5E : CD 09 37            	CALL	PROMPT		; Get input with "? " prompt
    1677/    3D61 : C1                  	POP	BC		; Restore code string address
    1678/    3D62 : DA 69 3A            	JP	C,INPBRK	; Break pressed - Exit
    1679/    3D65 : 23                  	INC	HL		; Next byte
    1680/    3D66 : 7E                  	LD	A,(HL)		; Get it
    1681/    3D67 : B7                  	OR	A		; End of line?
    1682/    3D68 : 2B                  	DEC	HL		; Back again
    1683/    3D69 : C5                  	PUSH	BC		; Re-save code string address
    1684/    3D6A : CA B0 3B            	JP	Z,NXTDTA	; Yes - Find next DATA stmt
    1685/    3D6D : 36 2C               	LD	(HL),','	; Store comma as separator
    1686/    3D6F : C3 77 3D            	JP	NXTITM		; Get next item
    1687/    3D72 :                     ;
    1688/    3D72 : E5                  READ:	PUSH	HL		; Save code string address
    1689/    3D73 : 2A 21 81            	LD	HL,(NXTDAT)	; Next DATA statement
    1690/    3D76 : F6                  	DB	0F6H		; Flag "READ"
    1691/    3D77 : AF                  NXTITM: XOR	A		; Flag "INPUT"
    1692/    3D78 : 32 12 81            	LD	(READFG),A	; Save "READ"/"INPUT" flag
    1693/    3D7B : E3                  	EX	(SP),HL		; Get code str' , Save pointer
    1694/    3D7C : C3 83 3D            	JP	GTVLUS		; Get values
    1695/    3D7F :                     ;
    1696/    3D7F : CD 88 38            NEDMOR: CALL	CHKSYN		; Check for comma between items
    1697/    3D82 : 2C                  	DB	','
    1698/    3D83 : CD 7E 40            GTVLUS: CALL	GETVAR		; Get variable name
    1699/    3D86 : E3                  	EX	(SP),HL		; Save code str" , Get pointer
    1700/    3D87 : D5                  	PUSH	DE		; Save variable address
    1701/    3D88 : 7E                  	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
    1702/    3D89 : FE 2C               	CP	','		; Comma?
    1703/    3D8B : CA AB 3D            	JP	Z,ANTVLU	; Yes - Get another value
    1704/    3D8E : 3A 12 81            	LD	A,(READFG)	; Is it READ?
    1705/    3D91 : B7                  	OR	A
    1706/    3D92 : C2 18 3E            	JP	NZ,FDTLP	; Yes - Find next DATA stmt
    1707/    3D95 : 3E 3F               	LD	A,'?'		; More INPUT needed
    1708/    3D97 : CD 93 38            	CALL	OUTC		; Output character
    1709/    3D9A : CD 09 37            	CALL	PROMPT		; Get INPUT with prompt
    1710/    3D9D : D1                  	POP	DE		; Variable address
    1711/    3D9E : C1                  	POP	BC		; Code string address
    1712/    3D9F : DA 69 3A            	JP	C,INPBRK	; Break pressed
    1713/    3DA2 : 23                  	INC	HL		; Point to next DATA byte
    1714/    3DA3 : 7E                  	LD	A,(HL)		; Get byte
    1715/    3DA4 : B7                  	OR	A		; Is it zero (No input) ?
    1716/    3DA5 : 2B                  	DEC	HL		; Back space INPUT pointer
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 30 - 12/29/2022 20:41:36


    1717/    3DA6 : C5                  	PUSH	BC		; Save code string address
    1718/    3DA7 : CA B0 3B            	JP	Z,NXTDTA	; Find end of buffer
    1719/    3DAA : D5                  	PUSH	DE		; Save variable address
    1720/    3DAB : 3A F2 80            ANTVLU: LD	A,(TYPE)	; Check data type
    1721/    3DAE : B7                  	OR	A		; Is it numeric?
    1722/    3DAF : CA D5 3D            	JP	Z,INPBIN	; Yes - Convert to binary
    1723/    3DB2 : CD 16 3A            	CALL	GETCHR		; Get next character
    1724/    3DB5 : 57                  	LD	D,A		; Save input character
    1725/    3DB6 : 47                  	LD	B,A		; Again
    1726/    3DB7 : FE 22               	CP	'"'		; Start of literal sting?
    1727/    3DB9 : CA C9 3D            	JP	Z,STRENT	; Yes - Create string entry
    1728/    3DBC : 3A 12 81            	LD	A,(READFG)	; "READ" or "INPUT" ?
    1729/    3DBF : B7                  	OR	A
    1730/    3DC0 : 57                  	LD	D,A		; Save 00 if "INPUT"
    1731/    3DC1 : CA C6 3D            	JP	Z,ITMSEP	; "INPUT" - End with 00
    1732/    3DC4 : 16 3A               	LD	D,':'		; "DATA" - End with 00 or ':'
    1733/    3DC6 : 06 2C               ITMSEP: LD	B,','		; Item separator
    1734/    3DC8 : 2B                  	DEC	HL		; Back space for DTSTR
    1735/    3DC9 : CD 23 43            STRENT: CALL	DTSTR		; Get string terminated by D
    1736/    3DCC : EB                  	EX	DE,HL		; String address to DE
    1737/    3DCD : 21 E0 3D            	LD	HL,LTSTND	; Where to go after LETSTR
    1738/    3DD0 : E3                  	EX	(SP),HL		; Save HL , get input pointer
    1739/    3DD1 : D5                  	PUSH	DE		; Save address of string
    1740/    3DD2 : C3 E3 3B            	JP	LETSTR		; Assign string to variable
    1741/    3DD5 :                     ;
    1742/    3DD5 : CD 16 3A            INPBIN: CALL	GETCHR		; Get next character
    1743/    3DD8 : CD 73 49            	CALL	ASCTFP		; Convert ASCII to FP number
    1744/    3DDB : E3                  	EX	(SP),HL		; Save input ptr, Get var addr
    1745/    3DDC : CD C4 48            	CALL	FPTHL		; Move FPREG to variable
    1746/    3DDF : E1                  	POP	HL		; Restore input pointer
    1747/    3DE0 : 2B                  LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
    1748/    3DE1 : CD 16 3A            	CALL	GETCHR		; Get next character
    1749/    3DE4 : CA EC 3D            	JP	Z,MORDT		; End of line - More needed?
    1750/    3DE7 : FE 2C               	CP	','		; Another value?
    1751/    3DE9 : C2 32 3D            	JP	NZ,BADINP	; No - Bad input
    1752/    3DEC : E3                  MORDT:	EX	(SP),HL		; Get code string address
    1753/    3DED : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    1754/    3DEE : CD 16 3A            	CALL	GETCHR		; Get next character
    1755/    3DF1 : C2 7F 3D            	JP	NZ,NEDMOR	; More needed - Get it
    1756/    3DF4 : D1                  	POP	DE		; Restore DATA pointer
    1757/    3DF5 : 3A 12 81            	LD	A,(READFG)	; "READ" or "INPUT" ?
    1758/    3DF8 : B7                  	OR	A
    1759/    3DF9 : EB                  	EX	DE,HL		; DATA pointer to HL
    1760/    3DFA : C2 3C 3A            	JP	NZ,UPDATA	; Update DATA pointer if "READ"
    1761/    3DFD : D5                  	PUSH	DE		; Save code string address
    1762/    3DFE : B6                  	OR	(HL)		; More input given?
    1763/    3DFF : 21 07 3E            	LD	HL,EXTIG	; "?Extra ignored" message
    1764/    3E02 : C4 61 43            	CALL	NZ,PRS		; Output string if extra given
    1765/    3E05 : E1                  	POP	HL		; Restore code string address
    1766/    3E06 : C9                  	RET
    1767/    3E07 :                     ;
    1768/    3E07 : 3F 45 78 74 72 61   EXTIG:	DB	"?Extra ignored",CR,LF,0
             3E0D : 20 69 67 6E 6F 72 
             3E13 : 65 64 0D 0A 00    
    1769/    3E18 :                     ;
    1770/    3E18 : CD B1 3B            FDTLP:	CALL	DATA		; Get next statement
    1771/    3E1B : B7                  	OR	A		; End of line?
    1772/    3E1C : C2 31 3E            	JP	NZ,FANDT	; No - See if DATA statement
    1773/    3E1F : 23                  	INC	HL
    1774/    3E20 : 7E                  	LD	A,(HL)		; End of program?
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 31 - 12/29/2022 20:41:36


    1775/    3E21 : 23                  	INC	HL
    1776/    3E22 : B6                  	OR	(HL)		; 00 00 Ends program
    1777/    3E23 : 1E 06               	LD	E,OD		; ?OD Error
    1778/    3E25 : CA CE 35            	JP	Z,ERROR		; Yes - Out of DATA
    1779/    3E28 : 23                  	INC	HL
    1780/    3E29 : 5E                  	LD	E,(HL)		; LSB of line number
    1781/    3E2A : 23                  	INC	HL
    1782/    3E2B : 56                  	LD	D,(HL)		; MSB of line number
    1783/    3E2C : EB                  	EX	DE,HL
    1784/    3E2D : 22 0E 81            	LD	(DATLIN),HL	; Set line of current DATA item
    1785/    3E30 : EB                  	EX	DE,HL
    1786/    3E31 : CD 16 3A            FANDT:	CALL	GETCHR		; Get next character
    1787/    3E34 : FE 83               	CP	ZDATA		; "DATA" token
    1788/    3E36 : C2 18 3E            	JP	NZ,FDTLP	; No "DATA" - Keep looking
    1789/    3E39 : C3 AB 3D            	JP	ANTVLU		; Found - Convert input
    1790/    3E3C :                     ;
    1791/    3E3C : 11 00 00            NEXT:	LD	DE,0		; In case no index given
    1792/    3E3F : C4 7E 40            NEXT1:	CALL	NZ,GETVAR	; Get index address
    1793/    3E42 : 22 13 81            	LD	(BRKLIN),HL	; Save code string address
    1794/    3E45 : CD 63 35            	CALL	BAKSTK		; Look for "FOR" block
    1795/    3E48 : C2 C0 35            	JP	NZ,NFERR	; No "FOR" - ?NF Error
    1796/    3E4B : F9                  	LD	SP,HL		; Clear nested loops
    1797/    3E4C : D5                  	PUSH	DE		; Save index address
    1798/    3E4D : 7E                  	LD	A,(HL)		; Get sign of STEP
    1799/    3E4E : 23                  	INC	HL
    1800/    3E4F : F5                  	PUSH	AF		; Save sign of STEP
    1801/    3E50 : D5                  	PUSH	DE		; Save index address
    1802/    3E51 : CD AA 48            	CALL	PHLTFP		; Move index value to FPREG
    1803/    3E54 : E3                  	EX	(SP),HL		; Save address of TO value
    1804/    3E55 : E5                  	PUSH	HL		; Save address of index
    1805/    3E56 : CD 17 46            	CALL	ADDPHL		; Add STEP to index value
    1806/    3E59 : E1                  	POP	HL		; Restore address of index
    1807/    3E5A : CD C4 48            	CALL	FPTHL		; Move value to index variable
    1808/    3E5D : E1                  	POP	HL		; Restore address of TO value
    1809/    3E5E : CD BB 48            	CALL	LOADFP		; Move TO value to BCDE
    1810/    3E61 : E5                  	PUSH	HL		; Save address of line of FOR
    1811/    3E62 : CD E7 48            	CALL	CMPNUM		; Compare index with TO value
    1812/    3E65 : E1                  	POP	HL		; Restore address of line num
    1813/    3E66 : C1                  	POP	BC		; Address of sign of STEP
    1814/    3E67 : 90                  	SUB	B		; Compare with expected sign
    1815/    3E68 : CD BB 48            	CALL	LOADFP		; BC = Loop stmt,DE = Line num
    1816/    3E6B : CA 77 3E            	JP	Z,KILFOR	; Loop finished - Terminate it
    1817/    3E6E : EB                  	EX	DE,HL		; Loop statement line number
    1818/    3E6F : 22 A1 80            	LD	(LINEAT),HL	; Set loop line number
    1819/    3E72 : 69                  	LD	L,C		; Set code string to loop
    1820/    3E73 : 60                  	LD	H,B
    1821/    3E74 : C3 D2 39            	JP	PUTFID		; Put back "FOR" and continue
    1822/    3E77 :                     ;
    1823/    3E77 : F9                  KILFOR: LD	SP,HL		; Remove "FOR" block
    1824/    3E78 : 2A 13 81            	LD	HL,(BRKLIN)	; Code string after "NEXT"
    1825/    3E7B : 7E                  	LD	A,(HL)		; Get next byte in code string
    1826/    3E7C : FE 2C               	CP	','		; More NEXTs ?
    1827/    3E7E : C2 D6 39            	JP	NZ,RUNCNT	; No - Do next statement
    1828/    3E81 : CD 16 3A            	CALL	GETCHR		; Position to index name
    1829/    3E84 : CD 3F 3E            	CALL	NEXT1		; Re-enter NEXT routine
    1830/    3E87 :                     ; < will not RETurn to here , Exit to RUNCNT or Loop >
    1831/    3E87 :                     ;
    1832/    3E87 : CD 99 3E            GETNUM: CALL	EVAL		; Get a numeric expression
    1833/    3E8A : F6                  TSTNUM: DB	0F6H		; Clear carry (numeric)
    1834/    3E8B : 37                  TSTSTR: SCF			; Set carry (string)
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 32 - 12/29/2022 20:41:36


    1835/    3E8C : 3A F2 80            CHKTYP: LD	A,(TYPE)	; Check types match
    1836/    3E8F : 8F                  	ADC	A,A		; Expected + actual
    1837/    3E90 : B7                  	OR	A		; Clear carry , set parity
    1838/    3E91 : E8                  	RET	PE		; Even parity - Types match
    1839/    3E92 : C3 CC 35            	JP	TMERR		; Different types - Error
    1840/    3E95 :                     ;
    1841/    3E95 : CD 88 38            OPNPAR: CALL	CHKSYN		; Make sure "(" follows
    1842/    3E98 : 28                  	DB	"("
    1843/    3E99 : 2B                  EVAL:	DEC	HL		; Evaluate expression & save
    1844/    3E9A : 16 00               	LD	D,0		; Precedence value
    1845/    3E9C : D5                  EVAL1:	PUSH	DE		; Save precedence
    1846/    3E9D : 0E 01               	LD	C,1
    1847/    3E9F : CD 97 35            	CALL	CHKSTK		; Check for 1 level of stack
    1848/    3EA2 : CD 10 3F            	CALL	OPRND		; Get next expression value
    1849/    3EA5 : 22 15 81            EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
    1850/    3EA8 : 2A 15 81            EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
    1851/    3EAB : C1                  	POP	BC		; Precedence value and operator
    1852/    3EAC : 78                  	LD	A,B		; Get precedence value
    1853/    3EAD : FE 78               	CP	78H		; "AND" or "OR" ?
    1854/    3EAF : D4 8A 3E            	CALL	NC,TSTNUM	; No - Make sure it's a number
    1855/    3EB2 : 7E                  	LD	A,(HL)		; Get next operator / function
    1856/    3EB3 : 16 00               	LD	D,0		; Clear Last relation
    1857/    3EB5 : D6 B3               RLTLP:	SUB	ZGTR		; ">" Token
    1858/    3EB7 : DA D1 3E            	JP	C,FOPRND	; + - * / ^ AND OR - Test it
    1859/    3EBA : FE 03               	CP	ZLTH+1-ZGTR	; < = >
    1860/    3EBC : D2 D1 3E            	JP	NC,FOPRND	; Function - Call it
    1861/    3EBF : FE 01               	CP	ZEQUAL-ZGTR	; "="
    1862/    3EC1 : 17                  	RLA			; <- Test for legal
    1863/    3EC2 : AA                  	XOR	D		; <- combinations of < = >
    1864/    3EC3 : BA                  	CP	D		; <- by combining last token
    1865/    3EC4 : 57                  	LD	D,A		; <- with current one
    1866/    3EC5 : DA BA 35            	JP	C,SNERR		; Error if "<<' '==" or ">>"
    1867/    3EC8 : 22 0A 81            	LD	(CUROPR),HL	; Save address of current token
    1868/    3ECB : CD 16 3A            	CALL	GETCHR		; Get next character
    1869/    3ECE : C3 B5 3E            	JP	RLTLP		; Treat the two as one
    1870/    3ED1 :                     ;
    1871/    3ED1 : 7A                  FOPRND: LD	A,D		; < = > found ?
    1872/    3ED2 : B7                  	OR	A
    1873/    3ED3 : C2 F9 3F            	JP	NZ,TSTRED	; Yes - Test for reduction
    1874/    3ED6 : 7E                  	LD	A,(HL)		; Get operator token
    1875/    3ED7 : 22 0A 81            	LD	(CUROPR),HL	; Save operator address
    1876/    3EDA : D6 AC               	SUB	ZPLUS		; Operator or function?
    1877/    3EDC : D8                  	RET	C		; Neither - Exit
    1878/    3EDD : FE 07               	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
    1879/    3EDF : D0                  	RET	NC		; No - Exit
    1880/    3EE0 : 5F                  	LD	E,A		; Coded operator
    1881/    3EE1 : 3A F2 80            	LD	A,(TYPE)	; Get data type
    1882/    3EE4 : 3D                  	DEC	A		; FF = numeric , 00 = string
    1883/    3EE5 : B3                  	OR	E		; Combine with coded operator
    1884/    3EE6 : 7B                  	LD	A,E		; Get coded operator
    1885/    3EE7 : CA 57 44            	JP	Z,CONCAT	; String concatenation
    1886/    3EEA : 07                  	RLCA			; Times 2
    1887/    3EEB : 83                  	ADD	A,E		; Times 3
    1888/    3EEC : 5F                  	LD	E,A		; To DE (D is 0)
    1889/    3EED : 21 AC 34            	LD	HL,PRITAB	; Precedence table
    1890/    3EF0 : 19                  	ADD	HL,DE		; To the operator concerned
    1891/    3EF1 : 78                  	LD	A,B		; Last operator precedence
    1892/    3EF2 : 56                  	LD	D,(HL)		; Get evaluation precedence
    1893/    3EF3 : BA                  	CP	D		; Compare with eval precedence
    1894/    3EF4 : D0                  	RET	NC		; Exit if higher precedence
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 33 - 12/29/2022 20:41:36


    1895/    3EF5 : 23                  	INC	HL		; Point to routine address
    1896/    3EF6 : CD 8A 3E            	CALL	TSTNUM		; Make sure it's a number
    1897/    3EF9 :                     ;
    1898/    3EF9 : C5                  STKTHS: PUSH	BC		; Save last precedence & token
    1899/    3EFA : 01 A8 3E            	LD	BC,EVAL3	; Where to go on prec' break
    1900/    3EFD : C5                  	PUSH	BC		; Save on stack for return
    1901/    3EFE : 43                  	LD	B,E		; Save operator
    1902/    3EFF : 4A                  	LD	C,D		; Save precedence
    1903/    3F00 : CD 9D 48            	CALL	STAKFP		; Move value to stack
    1904/    3F03 : 58                  	LD	E,B		; Restore operator
    1905/    3F04 : 51                  	LD	D,C		; Restore precedence
    1906/    3F05 : 4E                  	LD	C,(HL)		; Get LSB of routine address
    1907/    3F06 : 23                  	INC	HL
    1908/    3F07 : 46                  	LD	B,(HL)		; Get MSB of routine address
    1909/    3F08 : 23                  	INC	HL
    1910/    3F09 : C5                  	PUSH	BC		; Save routine address
    1911/    3F0A : 2A 0A 81            	LD	HL,(CUROPR)	; Address of current operator
    1912/    3F0D : C3 9C 3E            	JP	EVAL1		; Loop until prec' break
    1913/    3F10 :                     ;
    1914/    3F10 : AF                  OPRND:	XOR	A		; Get operand routine
    1915/    3F11 : 32 F2 80            	LD	(TYPE),A	; Set numeric expected
    1916/    3F14 : CD 16 3A            	CALL	GETCHR		; Get next character
    1917/    3F17 : 1E 24               	LD	E,MO		; ?MO Error
    1918/    3F19 : CA CE 35            	JP	Z,ERROR		; No operand - Error
    1919/    3F1C : DA 73 49            	JP	C,ASCTFP	; Number - Get value
    1920/    3F1F : CD B8 3A            	CALL	CHKLTR		; See if a letter
    1921/    3F22 : D2 78 3F            	JP	NC,CONVAR	; Letter - Find variable
    1922/    3F25 : FE 26               	CP	'&'		; &H = HEX, &B = BINARY
    1923/    3F27 : C2 3C 3F            	JP	NZ, NOTAMP
    1924/    3F2A : CD 16 3A            	CALL	GETCHR		; Get next character
    1925/    3F2D : FE 48               	CP	'H'		; Hex number indicated? [function added]
    1926/    3F2F : CA BD 4D            	JP	Z,HEXTFP	; Convert Hex to FPREG
    1927/    3F32 : FE 42               	CP	'B'		; Binary number indicated? [function added]
    1928/    3F34 : CA 39 4E            	JP	Z,BINTFP	; Convert Bin to FPREG
    1929/    3F37 : 1E 02               	LD	E,SN		; If neither then a ?SN Error
    1930/    3F39 : CA CE 35            	JP	Z,ERROR
    1931/    3F3C : FE AC               NOTAMP: CP	ZPLUS		; '+' Token ?
    1932/    3F3E : CA 10 3F            	JP	Z,OPRND		; Yes - Look for operand
    1933/    3F41 : FE 2E               	CP	'.'		; '.' ?
    1934/    3F43 : CA 73 49            	JP	Z,ASCTFP	; Yes - Create FP number
    1935/    3F46 : FE AD               	CP	ZMINUS		; '-' Token ?
    1936/    3F48 : CA 67 3F            	JP	Z,MINUS		; Yes - Do minus
    1937/    3F4B : FE 22               	CP	'"'		; Literal string ?
    1938/    3F4D : CA 20 43            	JP	Z,QTSTR		; Get string terminated by '"'
    1939/    3F50 : FE AA               	CP	ZNOT		; "NOT" Token ?
    1940/    3F52 : CA 59 40            	JP	Z,EVNOT		; Yes - Eval NOT expression
    1941/    3F55 : FE A7               	CP	ZFN		; "FN" Token ?
    1942/    3F57 : CA 84 42            	JP	Z,DOFN		; Yes - Do FN routine
    1943/    3F5A : D6 B6               	SUB	ZSGN		; Is it a function?
    1944/    3F5C : D2 89 3F            	JP	NC,FNOFST	; Yes - Evaluate function
    1945/    3F5F : CD 95 3E            EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
    1946/    3F62 : CD 88 38            	CALL	CHKSYN		; Make sure ")" follows
    1947/    3F65 : 29                  	DB	")"
    1948/    3F66 : C9                  	RET
    1949/    3F67 :                     ;
    1950/    3F67 : 16 7D               MINUS:	LD	D,7DH		; '-' precedence
    1951/    3F69 : CD 9C 3E            	CALL	EVAL1		; Evaluate until prec' break
    1952/    3F6C : 2A 15 81            	LD	HL,(NXTOPR)	; Get next operator address
    1953/    3F6F : E5                  	PUSH	HL		; Save next operator address
    1954/    3F70 : CD 95 48            	CALL	INVSGN		; Negate value
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 34 - 12/29/2022 20:41:36


    1955/    3F73 : CD 8A 3E            RETNUM: CALL	TSTNUM		; Make sure it's a number
    1956/    3F76 : E1                  	POP	HL		; Restore next operator address
    1957/    3F77 : C9                  	RET
    1958/    3F78 :                     ;
    1959/    3F78 : CD 7E 40            CONVAR: CALL	GETVAR		; Get variable address to DE
    1960/    3F7B : E5                  FRMEVL: PUSH	HL		; Save code string address
    1961/    3F7C : EB                  	EX	DE,HL		; Variable address to HL
    1962/    3F7D : 22 29 81            	LD	(FPREG),HL	; Save address of variable
    1963/    3F80 : 3A F2 80            	LD	A,(TYPE)	; Get type
    1964/    3F83 : B7                  	OR	A		; Numeric?
    1965/    3F84 : CC AA 48            	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
    1966/    3F87 : E1                  	POP	HL		; Restore code string address
    1967/    3F88 : C9                  	RET
    1968/    3F89 :                     ;
    1969/    3F89 : 06 00               FNOFST: LD	B,0		; Get address of function
    1970/    3F8B : 07                  	RLCA			; Double function offset
    1971/    3F8C : 4F                  	LD	C,A		; BC = Offset in function table
    1972/    3F8D : C5                  	PUSH	BC		; Save adjusted token value
    1973/    3F8E : CD 16 3A            	CALL	GETCHR		; Get next character
    1974/    3F91 : 79                  	LD	A,C		; Get adjusted token value
    1975/    3F92 : FE 31               	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
    1976/    3F94 : DA B0 3F            	JP	C,FNVAL		; No - Do function
    1977/    3F97 : CD 95 3E            	CALL	OPNPAR		; Evaluate expression	(X,...
    1978/    3F9A : CD 88 38            	CALL	CHKSYN		; Make sure ',' follows
    1979/    3F9D : 2C                  	DB	','
    1980/    3F9E : CD 8B 3E            	CALL	TSTSTR		; Make sure it's a string
    1981/    3FA1 : EB                  	EX	DE,HL		; Save code string address
    1982/    3FA2 : 2A 29 81            	LD	HL,(FPREG)	; Get address of string
    1983/    3FA5 : E3                  	EX	(SP),HL		; Save address of string
    1984/    3FA6 : E5                  	PUSH	HL		; Save adjusted token value
    1985/    3FA7 : EB                  	EX	DE,HL		; Restore code string address
    1986/    3FA8 : CD EB 45            	CALL	GETINT		; Get integer 0-255
    1987/    3FAB : EB                  	EX	DE,HL		; Save code string address
    1988/    3FAC : E3                  	EX	(SP),HL		; Save integer,HL = adj' token
    1989/    3FAD : C3 B8 3F            	JP	GOFUNC		; Jump to string function
    1990/    3FB0 :                     ;
    1991/    3FB0 : CD 5F 3F            FNVAL:	CALL	EVLPAR		; Evaluate expression
    1992/    3FB3 : E3                  	EX	(SP),HL		; HL = Adjusted token value
    1993/    3FB4 : 11 73 3F            	LD	DE,RETNUM	; Return number from function
    1994/    3FB7 : D5                  	PUSH	DE		; Save on stack
    1995/    3FB8 : 01 0B 33            GOFUNC: LD	BC,FNCTAB	; Function routine addresses
    1996/    3FBB : 09                  	ADD	HL,BC		; Point to right address
    1997/    3FBC : 4E                  	LD	C,(HL)		; Get LSB of address
    1998/    3FBD : 23                  	INC	HL		;
    1999/    3FBE : 66                  	LD	H,(HL)		; Get MSB of address
    2000/    3FBF : 69                  	LD	L,C		; Address to HL
    2001/    3FC0 : E9                  	JP	(HL)		; Jump to function
    2002/    3FC1 :                     ;
    2003/    3FC1 : 15                  SGNEXP: DEC	D		; Dee to flag negative exponent
    2004/    3FC2 : FE AD               	CP	ZMINUS		; '-' token ?
    2005/    3FC4 : C8                  	RET	Z		; Yes - Return
    2006/    3FC5 : FE 2D               	CP	'-'		; '-' ASCII ?
    2007/    3FC7 : C8                  	RET	Z		; Yes - Return
    2008/    3FC8 : 14                  	INC	D		; Inc to flag positive exponent
    2009/    3FC9 : FE 2B               	CP	'+'		; '+' ASCII ?
    2010/    3FCB : C8                  	RET	Z		; Yes - Return
    2011/    3FCC : FE AC               	CP	ZPLUS		; '+' token ?
    2012/    3FCE : C8                  	RET	Z		; Yes - Return
    2013/    3FCF : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2014/    3FD0 : C9                  	RET			; Return "NZ"
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 35 - 12/29/2022 20:41:36


    2015/    3FD1 :                     ;
    2016/    3FD1 : F6                  POR:	DB	0F6H		; Flag "OR"
    2017/    3FD2 : AF                  PAND:	XOR	A		; Flag "AND"
    2018/    3FD3 : F5                  	PUSH	AF		; Save "AND" / "OR" flag
    2019/    3FD4 : CD 8A 3E            	CALL	TSTNUM		; Make sure it's a number
    2020/    3FD7 : CD CC 3A            	CALL	DEINT		; Get integer -32768 to 32767
    2021/    3FDA : F1                  	POP	AF		; Restore "AND" / "OR" flag
    2022/    3FDB : EB                  	EX	DE,HL		; <- Get last
    2023/    3FDC : C1                  	POP	BC		; <- value
    2024/    3FDD : E3                  	EX	(SP),HL		; <- from
    2025/    3FDE : EB                  	EX	DE,HL		; <- stack
    2026/    3FDF : CD AD 48            	CALL	FPBCDE		; Move last value to FPREG
    2027/    3FE2 : F5                  	PUSH	AF		; Save "AND" / "OR" flag
    2028/    3FE3 : CD CC 3A            	CALL	DEINT		; Get integer -32768 to 32767
    2029/    3FE6 : F1                  	POP	AF		; Restore "AND" / "OR" flag
    2030/    3FE7 : C1                  	POP	BC		; Get value
    2031/    3FE8 : 79                  	LD	A,C		; Get LSB
    2032/    3FE9 : 21 42 42            	LD	HL,ACPASS	; Address of save AC as current
    2033/    3FEC : C2 F4 3F            	JP	NZ,POR1		; Jump if OR
    2034/    3FEF : A3                  	AND	E		; "AND" LSBs
    2035/    3FF0 : 4F                  	LD	C,A		; Save LSB
    2036/    3FF1 : 78                  	LD	A,B		; Get MBS
    2037/    3FF2 : A2                  	AND	D		; "AND" MSBs
    2038/    3FF3 : E9                  	JP	(HL)		; Save AC as current (ACPASS)
    2039/    3FF4 :                     ;
    2040/    3FF4 : B3                  POR1:	OR	E		; "OR" LSBs
    2041/    3FF5 : 4F                  	LD	C,A		; Save LSB
    2042/    3FF6 : 78                  	LD	A,B		; Get MSB
    2043/    3FF7 : B2                  	OR	D		; "OR" MSBs
    2044/    3FF8 : E9                  	JP	(HL)		; Save AC as current (ACPASS)
    2045/    3FF9 :                     ;
    2046/    3FF9 : 21 0B 40            TSTRED: LD	HL,CMPLOG	; Logical compare routine
    2047/    3FFC : 3A F2 80            	LD	A,(TYPE)	; Get data type
    2048/    3FFF : 1F                  	RRA			; Carry set = string
    2049/    4000 : 7A                  	LD	A,D		; Get last precedence value
    2050/    4001 : 17                  	RLA			; Times 2 plus carry
    2051/    4002 : 5F                  	LD	E,A		; To E
    2052/    4003 : 16 64               	LD	D,64H		; Relational precedence
    2053/    4005 : 78                  	LD	A,B		; Get current precedence
    2054/    4006 : BA                  	CP	D		; Compare with last
    2055/    4007 : D0                  	RET	NC		; Eval if last was rel' or log'
    2056/    4008 : C3 F9 3E            	JP	STKTHS		; Stack this one and get next
    2057/    400B :                     ;
    2058/    400B : 0D 40               CMPLOG: DW	CMPLG1		; Compare two values / strings
    2059/    400D : 79                  CMPLG1: LD	A,C		; Get data type
    2060/    400E : B7                  	OR	A
    2061/    400F : 1F                  	RRA
    2062/    4010 : C1                  	POP	BC		; Get last expression to BCDE
    2063/    4011 : D1                  	POP	DE
    2064/    4012 : F5                  	PUSH	AF		; Save status
    2065/    4013 : CD 8C 3E            	CALL	CHKTYP		; Check that types match
    2066/    4016 : 21 4F 40            	LD	HL,CMPRES	; Result to comparison
    2067/    4019 : E5                  	PUSH	HL		; Save for RETurn
    2068/    401A : CA E7 48            	JP	Z,CMPNUM	; Compare values if numeric
    2069/    401D : AF                  	XOR	A		; Compare two strings
    2070/    401E : 32 F2 80            	LD	(TYPE),A	; Set type to numeric
    2071/    4021 : D5                  	PUSH	DE		; Save string name
    2072/    4022 : CD A4 44            	CALL	GSTRCU		; Get current string
    2073/    4025 : 7E                  	LD	A,(HL)		; Get length of string
    2074/    4026 : 23                  	INC	HL
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 36 - 12/29/2022 20:41:36


    2075/    4027 : 23                  	INC	HL
    2076/    4028 : 4E                  	LD	C,(HL)		; Get LSB of address
    2077/    4029 : 23                  	INC	HL
    2078/    402A : 46                  	LD	B,(HL)		; Get MSB of address
    2079/    402B : D1                  	POP	DE		; Restore string name
    2080/    402C : C5                  	PUSH	BC		; Save address of string
    2081/    402D : F5                  	PUSH	AF		; Save length of string
    2082/    402E : CD A8 44            	CALL	GSTRDE		; Get second string
    2083/    4031 : CD BB 48            	CALL	LOADFP		; Get address of second string
    2084/    4034 : F1                  	POP	AF		; Restore length of string 1
    2085/    4035 : 57                  	LD	D,A		; Length to D
    2086/    4036 : E1                  	POP	HL		; Restore address of string 1
    2087/    4037 : 7B                  CMPSTR: LD	A,E		; Bytes of string 2 to do
    2088/    4038 : B2                  	OR	D		; Bytes of string 1 to do
    2089/    4039 : C8                  	RET	Z		; Exit if all bytes compared
    2090/    403A : 7A                  	LD	A,D		; Get bytes of string 1 to do
    2091/    403B : D6 01               	SUB	1
    2092/    403D : D8                  	RET	C		; Exit if end of string 1
    2093/    403E : AF                  	XOR	A
    2094/    403F : BB                  	CP	E		; Bytes of string 2 to do
    2095/    4040 : 3C                  	INC	A
    2096/    4041 : D0                  	RET	NC		; Exit if end of string 2
    2097/    4042 : 15                  	DEC	D		; Count bytes in string 1
    2098/    4043 : 1D                  	DEC	E		; Count bytes in string 2
    2099/    4044 : 0A                  	LD	A,(BC)		; Byte in string 2
    2100/    4045 : BE                  	CP	(HL)		; Compare to byte in string 1
    2101/    4046 : 23                  	INC	HL		; Move up string 1
    2102/    4047 : 03                  	INC	BC		; Move up string 2
    2103/    4048 : CA 37 40            	JP	Z,CMPSTR	; Same - Try next bytes
    2104/    404B : 3F                  	CCF			; Flag difference (">" or "<")
    2105/    404C : C3 77 48            	JP	FLGDIF		; "<" gives -1 , ">" gives +1
    2106/    404F :                     ;
    2107/    404F : 3C                  CMPRES: INC	A		; Increment current value
    2108/    4050 : 8F                  	ADC	A,A		; Double plus carry
    2109/    4051 : C1                  	POP	BC		; Get other value
    2110/    4052 : A0                  	AND	B		; Combine them
    2111/    4053 : C6 FF               	ADD	A,-1		; Carry set if different
    2112/    4055 : 9F                  	SBC	A,A		; 00 - Equal , FF - Different
    2113/    4056 : C3 7E 48            	JP	FLGREL		; Set current value & continue
    2114/    4059 :                     ;
    2115/    4059 : 16 5A               EVNOT:	LD	D,5AH		; Precedence value for "NOT"
    2116/    405B : CD 9C 3E            	CALL	EVAL1		; Eval until precedence break
    2117/    405E : CD 8A 3E            	CALL	TSTNUM		; Make sure it's a number
    2118/    4061 : CD CC 3A            	CALL	DEINT		; Get integer -32768 - 32767
    2119/    4064 : 7B                  	LD	A,E		; Get LSB
    2120/    4065 : 2F                  	CPL			; Invert LSB
    2121/    4066 : 4F                  	LD	C,A		; Save "NOT" of LSB
    2122/    4067 : 7A                  	LD	A,D		; Get MSB
    2123/    4068 : 2F                  	CPL			; Invert MSB
    2124/    4069 : CD 42 42            	CALL	ACPASS		; Save AC as current
    2125/    406C : C1                  	POP	BC		; Clean up stack
    2126/    406D : C3 A8 3E            	JP	EVAL3		; Continue evaluation
    2127/    4070 :                     ;
    2128/    4070 : 2B                  DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
    2129/    4071 : CD 16 3A            	CALL	GETCHR		; Get next character
    2130/    4074 : C8                  	RET	Z		; End of DIM statement
    2131/    4075 : CD 88 38            	CALL	CHKSYN		; Make sure ',' follows
    2132/    4078 : 2C                  	DB	','
    2133/    4079 : 01 70 40            DIM:	LD	BC,DIMRET	; Return to "DIMRET"
    2134/    407C : C5                  	PUSH	BC		; Save on stack
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 37 - 12/29/2022 20:41:36


    2135/    407D : F6                  	DB	0F6H		; Flag "Create" variable
    2136/    407E : AF                  GETVAR: XOR	A		; Find variable address,to DE
    2137/    407F : 32 F1 80            	LD	(LCRFLG),A	; Set locate / create flag
    2138/    4082 : 46                  	LD	B,(HL)		; Get First byte of name
    2139/    4083 : CD B8 3A            GTFNAM: CALL	CHKLTR		; See if a letter
    2140/    4086 : DA BA 35            	JP	C,SNERR		; ?SN Error if not a letter
    2141/    4089 : AF                  	XOR	A
    2142/    408A : 4F                  	LD	C,A		; Clear second byte of name
    2143/    408B : 32 F2 80            	LD	(TYPE),A	; Set type to numeric
    2144/    408E : CD 16 3A            	CALL	GETCHR		; Get next character
    2145/    4091 : DA 9A 40            	JP	C,SVNAM2	; Numeric - Save in name
    2146/    4094 : CD B8 3A            	CALL	CHKLTR		; See if a letter
    2147/    4097 : DA A7 40            	JP	C,CHARTY	; Not a letter - Check type
    2148/    409A : 4F                  SVNAM2: LD	C,A		; Save second byte of name
    2149/    409B : CD 16 3A            ENDNAM: CALL	GETCHR		; Get next character
    2150/    409E : DA 9B 40            	JP	C,ENDNAM	; Numeric - Get another
    2151/    40A1 : CD B8 3A            	CALL	CHKLTR		; See if a letter
    2152/    40A4 : D2 9B 40            	JP	NC,ENDNAM	; Letter - Get another
    2153/    40A7 : D6 24               CHARTY: SUB	'$'		; String variable?
    2154/    40A9 : C2 B6 40            	JP	NZ,NOTSTR	; No - Numeric variable
    2155/    40AC : 3C                  	INC	A		; A = 1 (string type)
    2156/    40AD : 32 F2 80            	LD	(TYPE),A	; Set type to string
    2157/    40B0 : 0F                  	RRCA			; A = 80H , Flag for string
    2158/    40B1 : 81                  	ADD	A,C		; 2nd byte of name has bit 7 on
    2159/    40B2 : 4F                  	LD	C,A		; Resave second byte on name
    2160/    40B3 : CD 16 3A            	CALL	GETCHR		; Get next character
    2161/    40B6 : 3A 10 81            NOTSTR: LD	A,(FORFLG)	; Array name needed ?
    2162/    40B9 : 3D                  	DEC	A
    2163/    40BA : CA 63 41            	JP	Z,ARLDSV	; Yes - Get array name
    2164/    40BD : F2 C6 40            	JP	P,NSCFOR	; No array with "FOR" or "FN"
    2165/    40C0 : 7E                  	LD	A,(HL)		; Get byte again
    2166/    40C1 : D6 28               	SUB	'('		; Subscripted variable?
    2167/    40C3 : CA 3B 41            	JP	Z,SBSCPT	; Yes - Sort out subscript
    2168/    40C6 :                     ;
    2169/    40C6 : AF                  NSCFOR: XOR	A		; Simple variable
    2170/    40C7 : 32 10 81            	LD	(FORFLG),A	; Clear "FOR" flag
    2171/    40CA : E5                  	PUSH	HL		; Save code string address
    2172/    40CB : 50                  	LD	D,B		; DE = Variable name to find
    2173/    40CC : 59                  	LD	E,C
    2174/    40CD : 2A 23 81            	LD	HL,(FNRGNM)	; FN argument name
    2175/    40D0 : CD 82 38            	CALL	CPDEHL		; Is it the FN argument?
    2176/    40D3 : 11 25 81            	LD	DE,FNARG	; Point to argument value
    2177/    40D6 : CA AD 47            	JP	Z,POPHRT	; Yes - Return FN argument value
    2178/    40D9 : 2A 1D 81            	LD	HL,(VAREND)	; End of variables
    2179/    40DC : EB                  	EX	DE,HL		; Address of end of search
    2180/    40DD : 2A 1B 81            	LD	HL,(PROGND)	; Start of variables address
    2181/    40E0 : CD 82 38            FNDVAR: CALL	CPDEHL		; End of variable list table?
    2182/    40E3 : CA F9 40            	JP	Z,CFEVAL	; Yes - Called from EVAL?
    2183/    40E6 : 79                  	LD	A,C		; Get second byte of name
    2184/    40E7 : 96                  	SUB	(HL)		; Compare with name in list
    2185/    40E8 : 23                  	INC	HL		; Move on to first byte
    2186/    40E9 : C2 EE 40            	JP	NZ,FNTHR	; Different - Find another
    2187/    40EC : 78                  	LD	A,B		; Get first byte of name
    2188/    40ED : 96                  	SUB	(HL)		; Compare with name in list
    2189/    40EE : 23                  FNTHR:	INC	HL		; Move on to LSB of value
    2190/    40EF : CA 2D 41            	JP	Z,RETADR	; Found - Return address
    2191/    40F2 : 23                  	INC	HL		; <- Skip
    2192/    40F3 : 23                  	INC	HL		; <- over
    2193/    40F4 : 23                  	INC	HL		; <- F.P.
    2194/    40F5 : 23                  	INC	HL		; <- value
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 38 - 12/29/2022 20:41:36


    2195/    40F6 : C3 E0 40            	JP	FNDVAR		; Keep looking
    2196/    40F9 :                     ;
    2197/    40F9 : E1                  CFEVAL: POP	HL		; Restore code string address
    2198/    40FA : E3                  	EX	(SP),HL		; Get return address
    2199/    40FB : D5                  	PUSH	DE		; Save address of variable
    2200/    40FC : 11 7B 3F            	LD	DE,FRMEVL	; Return address in EVAL
    2201/    40FF : CD 82 38            	CALL	CPDEHL		; Called from EVAL ?
    2202/    4102 : D1                  	POP	DE		; Restore address of variable
    2203/    4103 : CA 30 41            	JP	Z,RETNUL	; Yes - Return null variable
    2204/    4106 : E3                  	EX	(SP),HL		; Put back return
    2205/    4107 : E5                  	PUSH	HL		; Save code string address
    2206/    4108 : C5                  	PUSH	BC		; Save variable name
    2207/    4109 : 01 06 00            	LD	BC,6		; 2 byte name plus 4 byte data
    2208/    410C : 2A 1F 81            	LD	HL,(ARREND)	; End of arrays
    2209/    410F : E5                  	PUSH	HL		; Save end of arrays
    2210/    4110 : 09                  	ADD	HL,BC		; Move up 6 bytes
    2211/    4111 : C1                  	POP	BC		; Source address in BC
    2212/    4112 : E5                  	PUSH	HL		; Save new end address
    2213/    4113 : CD 86 35            	CALL	MOVUP		; Move arrays up
    2214/    4116 : E1                  	POP	HL		; Restore new end address
    2215/    4117 : 22 1F 81            	LD	(ARREND),HL	; Set new end address
    2216/    411A : 60                  	LD	H,B		; End of variables to HL
    2217/    411B : 69                  	LD	L,C
    2218/    411C : 22 1D 81            	LD	(VAREND),HL	; Set new end address
    2219/    411F :                     ;
    2220/    411F : 2B                  ZEROLP: DEC	HL		; Back through to zero variable
    2221/    4120 : 36 00               	LD	(HL),0		; Zero byte in variable
    2222/    4122 : CD 82 38            	CALL	CPDEHL		; Done them all?
    2223/    4125 : C2 1F 41            	JP	NZ,ZEROLP	; No - Keep on going
    2224/    4128 : D1                  	POP	DE		; Get variable name
    2225/    4129 : 73                  	LD	(HL),E		; Store second character
    2226/    412A : 23                  	INC	HL
    2227/    412B : 72                  	LD	(HL),D		; Store first character
    2228/    412C : 23                  	INC	HL
    2229/    412D : EB                  RETADR: EX	DE,HL		; Address of variable in DE
    2230/    412E : E1                  	POP	HL		; Restore code string address
    2231/    412F : C9                  	RET
    2232/    4130 :                     ;
    2233/    4130 : 32 2C 81            RETNUL: LD	(FPEXP),A	; Set result to zero
    2234/    4133 : 21 56 35            	LD	HL,ZERBYT	; Also set a null string
    2235/    4136 : 22 29 81            	LD	(FPREG),HL	; Save for EVAL
    2236/    4139 : E1                  	POP	HL		; Restore code string address
    2237/    413A : C9                  	RET
    2238/    413B :                     ;
    2239/    413B : E5                  SBSCPT: PUSH	HL		; Save code string address
    2240/    413C : 2A F1 80            	LD	HL,(LCRFLG)	; Locate/Create and Type
    2241/    413F : E3                  	EX	(SP),HL		; Save and get code string
    2242/    4140 : 57                  	LD	D,A		; Zero number of dimensions
    2243/    4141 : D5                  SCPTLP: PUSH	DE		; Save number of dimensions
    2244/    4142 : C5                  	PUSH	BC		; Save array name
    2245/    4143 : CD C0 3A            	CALL	FPSINT		; Get subscript (0-32767)
    2246/    4146 : C1                  	POP	BC		; Restore array name
    2247/    4147 : F1                  	POP	AF		; Get number of dimensions
    2248/    4148 : EB                  	EX	DE,HL
    2249/    4149 : E3                  	EX	(SP),HL		; Save subscript value
    2250/    414A : E5                  	PUSH	HL		; Save LCRFLG and TYPE
    2251/    414B : EB                  	EX	DE,HL
    2252/    414C : 3C                  	INC	A		; Count dimensions
    2253/    414D : 57                  	LD	D,A		; Save in D
    2254/    414E : 7E                  	LD	A,(HL)		; Get next byte in code string
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 39 - 12/29/2022 20:41:36


    2255/    414F : FE 2C               	CP	','		; Comma (more to come)?
    2256/    4151 : CA 41 41            	JP	Z,SCPTLP	; Yes - More subscripts
    2257/    4154 : CD 88 38            	CALL	CHKSYN		; Make sure ")" follows
    2258/    4157 : 29                  	DB	")"
    2259/    4158 : 22 15 81            	LD	(NXTOPR),HL	; Save code string address
    2260/    415B : E1                  	POP	HL		; Get LCRFLG and TYPE
    2261/    415C : 22 F1 80            	LD	(LCRFLG),HL	; Restore Locate/create & type
    2262/    415F : 1E 00               	LD	E,0		; Flag not CSAVE* or CLOAD*
    2263/    4161 : D5                  	PUSH	DE		; Save number of dimensions (D)
    2264/    4162 : 11                  	DB	11H		; Skip "PUSH HL" and "PUSH AF'
    2265/    4163 :                     ;
    2266/    4163 : E5                  ARLDSV: PUSH	HL		; Save code string address
    2267/    4164 : F5                  	PUSH	AF		; A = 00 , Flags set = Z,N
    2268/    4165 : 2A 1D 81            	LD	HL,(VAREND)	; Start of arrays
    2269/    4168 : 3E                  	DB	3EH		; Skip "ADD HL,DE"
    2270/    4169 : 19                  FNDARY: ADD	HL,DE		; Move to next array start
    2271/    416A : EB                  	EX	DE,HL
    2272/    416B : 2A 1F 81            	LD	HL,(ARREND)	; End of arrays
    2273/    416E : EB                  	EX	DE,HL		; Current array pointer
    2274/    416F : CD 82 38            	CALL	CPDEHL		; End of arrays found?
    2275/    4172 : CA 9B 41            	JP	Z,CREARY	; Yes - Create array
    2276/    4175 : 7E                  	LD	A,(HL)		; Get second byte of name
    2277/    4176 : B9                  	CP	C		; Compare with name given
    2278/    4177 : 23                  	INC	HL		; Move on
    2279/    4178 : C2 7D 41            	JP	NZ,NXTARY	; Different - Find next array
    2280/    417B : 7E                  	LD	A,(HL)		; Get first byte of name
    2281/    417C : B8                  	CP	B		; Compare with name given
    2282/    417D : 23                  NXTARY: INC	HL		; Move on
    2283/    417E : 5E                  	LD	E,(HL)		; Get LSB of next array address
    2284/    417F : 23                  	INC	HL
    2285/    4180 : 56                  	LD	D,(HL)		; Get MSB of next array address
    2286/    4181 : 23                  	INC	HL
    2287/    4182 : C2 69 41            	JP	NZ,FNDARY	; Not found - Keep looking
    2288/    4185 : 3A F1 80            	LD	A,(LCRFLG)	; Found Locate or Create it?
    2289/    4188 : B7                  	OR	A
    2290/    4189 : C2 C3 35            	JP	NZ,DDERR	; Create - ?DD Error
    2291/    418C : F1                  	POP	AF		; Locate - Get number of dim'ns
    2292/    418D : 44                  	LD	B,H		; BC Points to array dim'ns
    2293/    418E : 4D                  	LD	C,L
    2294/    418F : CA AD 47            	JP	Z,POPHRT	; Jump if array load/save
    2295/    4192 : 96                  	SUB	(HL)		; Same number of dimensions?
    2296/    4193 : CA F9 41            	JP	Z,FINDEL	; Yes - Find element
    2297/    4196 : 1E 10               BSERR:	LD	E,BS		; ?BS Error
    2298/    4198 : C3 CE 35            	JP	ERROR		; Output error
    2299/    419B :                     ;
    2300/    419B : 11 04 00            CREARY: LD	DE,4		; 4 Bytes per entry
    2301/    419E : F1                  	POP	AF		; Array to save or 0 dim'ns?
    2302/    419F : CA E1 3A            	JP	Z,FCERR		; Yes - ?FC Error
    2303/    41A2 : 71                  	LD	(HL),C		; Save second byte of name
    2304/    41A3 : 23                  	INC	HL
    2305/    41A4 : 70                  	LD	(HL),B		; Save first byte of name
    2306/    41A5 : 23                  	INC	HL
    2307/    41A6 : 4F                  	LD	C,A		; Number of dimensions to C
    2308/    41A7 : CD 97 35            	CALL	CHKSTK		; Check if enough memory
    2309/    41AA : 23                  	INC	HL		; Point to number of dimensions
    2310/    41AB : 23                  	INC	HL
    2311/    41AC : 22 0A 81            	LD	(CUROPR),HL	; Save address of pointer
    2312/    41AF : 71                  	LD	(HL),C		; Set number of dimensions
    2313/    41B0 : 23                  	INC	HL
    2314/    41B1 : 3A F1 80            	LD	A,(LCRFLG)	; Locate of Create?
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 40 - 12/29/2022 20:41:36


    2315/    41B4 : 17                  	RLA			; Carry set = Create
    2316/    41B5 : 79                  	LD	A,C		; Get number of dimensions
    2317/    41B6 : 01 0B 00            CRARLP: LD	BC,10+1		; Default dimension size 10
    2318/    41B9 : D2 BE 41            	JP	NC,DEFSIZ	; Locate - Set default size
    2319/    41BC : C1                  	POP	BC		; Get specified dimension size
    2320/    41BD : 03                  	INC	BC		; Include zero element
    2321/    41BE : 71                  DEFSIZ: LD	(HL),C		; Save LSB of dimension size
    2322/    41BF : 23                  	INC	HL
    2323/    41C0 : 70                  	LD	(HL),B		; Save MSB of dimension size
    2324/    41C1 : 23                  	INC	HL
    2325/    41C2 : F5                  	PUSH	AF		; Save num' of dim'ns an status
    2326/    41C3 : E5                  	PUSH	HL		; Save address of dim'n size
    2327/    41C4 : CD 58 49            	CALL	MLDEBC		; Multiply DE by BC to find
    2328/    41C7 : EB                  	EX	DE,HL		; amount of mem needed (to DE)
    2329/    41C8 : E1                  	POP	HL		; Restore address of dimension
    2330/    41C9 : F1                  	POP	AF		; Restore number of dimensions
    2331/    41CA : 3D                  	DEC	A		; Count them
    2332/    41CB : C2 B6 41            	JP	NZ,CRARLP	; Do next dimension if more
    2333/    41CE : F5                  	PUSH	AF		; Save locate/create flag
    2334/    41CF : 42                  	LD	B,D		; MSB of memory needed
    2335/    41D0 : 4B                  	LD	C,E		; LSB of memory needed
    2336/    41D1 : EB                  	EX	DE,HL
    2337/    41D2 : 19                  	ADD	HL,DE		; Add bytes to array start
    2338/    41D3 : DA AF 35            	JP	C,OMERR		; Too big - Error
    2339/    41D6 : CD A0 35            	CALL	ENFMEM		; See if enough memory
    2340/    41D9 : 22 1F 81            	LD	(ARREND),HL	; Save new end of array
    2341/    41DC :                     ;
    2342/    41DC : 2B                  ZERARY: DEC	HL		; Back through array data
    2343/    41DD : 36 00               	LD	(HL),0		; Set array element to zero
    2344/    41DF : CD 82 38            	CALL	CPDEHL		; All elements zeroed?
    2345/    41E2 : C2 DC 41            	JP	NZ,ZERARY	; No - Keep on going
    2346/    41E5 : 03                  	INC	BC		; Number of bytes + 1
    2347/    41E6 : 57                  	LD	D,A		; A=0
    2348/    41E7 : 2A 0A 81            	LD	HL,(CUROPR)	; Get address of array
    2349/    41EA : 5E                  	LD	E,(HL)		; Number of dimensions
    2350/    41EB : EB                  	EX	DE,HL		; To HL
    2351/    41EC : 29                  	ADD	HL,HL		; Two bytes per dimension size
    2352/    41ED : 09                  	ADD	HL,BC		; Add number of bytes
    2353/    41EE : EB                  	EX	DE,HL		; Bytes needed to DE
    2354/    41EF : 2B                  	DEC	HL
    2355/    41F0 : 2B                  	DEC	HL
    2356/    41F1 : 73                  	LD	(HL),E		; Save LSB of bytes needed
    2357/    41F2 : 23                  	INC	HL
    2358/    41F3 : 72                  	LD	(HL),D		; Save MSB of bytes needed
    2359/    41F4 : 23                  	INC	HL
    2360/    41F5 : F1                  	POP	AF		; Locate / Create?
    2361/    41F6 : DA 1D 42            	JP	C,ENDDIM	; A is 0 , End if create
    2362/    41F9 : 47                  FINDEL: LD	B,A		; Find array element
    2363/    41FA : 4F                  	LD	C,A
    2364/    41FB : 7E                  	LD	A,(HL)		; Number of dimensions
    2365/    41FC : 23                  	INC	HL
    2366/    41FD : 16                  	DB	16H		; Skip "POP HL"
    2367/    41FE : E1                  FNDELP: POP	HL		; Address of next dim' size
    2368/    41FF : 5E                  	LD	E,(HL)		; Get LSB of dim'n size
    2369/    4200 : 23                  	INC	HL
    2370/    4201 : 56                  	LD	D,(HL)		; Get MSB of dim'n size
    2371/    4202 : 23                  	INC	HL
    2372/    4203 : E3                  	EX	(SP),HL		; Save address - Get index
    2373/    4204 : F5                  	PUSH	AF		; Save number of dim'ns
    2374/    4205 : CD 82 38            	CALL	CPDEHL		; Dimension too large?
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 41 - 12/29/2022 20:41:36


    2375/    4208 : D2 96 41            	JP	NC,BSERR	; Yes - ?BS Error
    2376/    420B : E5                  	PUSH	HL		; Save index
    2377/    420C : CD 58 49            	CALL	MLDEBC		; Multiply previous by size
    2378/    420F : D1                  	POP	DE		; Index supplied to DE
    2379/    4210 : 19                  	ADD	HL,DE		; Add index to pointer
    2380/    4211 : F1                  	POP	AF		; Number of dimensions
    2381/    4212 : 3D                  	DEC	A		; Count them
    2382/    4213 : 44                  	LD	B,H		; MSB of pointer
    2383/    4214 : 4D                  	LD	C,L		; LSB of pointer
    2384/    4215 : C2 FE 41            	JP	NZ,FNDELP	; More - Keep going
    2385/    4218 : 29                  	ADD	HL,HL		; 4 Bytes per element
    2386/    4219 : 29                  	ADD	HL,HL
    2387/    421A : C1                  	POP	BC		; Start of array
    2388/    421B : 09                  	ADD	HL,BC		; Point to element
    2389/    421C : EB                  	EX	DE,HL		; Address of element to DE
    2390/    421D : 2A 15 81            ENDDIM: LD	HL,(NXTOPR)	; Got code string address
    2391/    4220 : C9                  	RET
    2392/    4221 :                     ;
    2393/    4221 : 2A 1F 81            FRE:	LD	HL,(ARREND)	; Start of free memory
    2394/    4224 : EB                  	EX	DE,HL		; To DE
    2395/    4225 : 21 00 00            	LD	HL,0		; End of free memory
    2396/    4228 : 39                  	ADD	HL,SP		; Current stack value
    2397/    4229 : 3A F2 80            	LD	A,(TYPE)	; Dummy argument type
    2398/    422C : B7                  	OR	A
    2399/    422D : CA 3D 42            	JP	Z,FRENUM	; Numeric - Free variable space
    2400/    4230 : CD A4 44            	CALL	GSTRCU		; Current string to pool
    2401/    4233 : CD A4 43            	CALL	GARBGE		; Garbage collection
    2402/    4236 : 2A 9F 80            	LD	HL,(STRSPC)	; Bottom of string space in use
    2403/    4239 : EB                  	EX	DE,HL		; To DE
    2404/    423A : 2A 08 81            	LD	HL,(STRBOT)	; Bottom of string space
    2405/    423D : 7D                  FRENUM: LD	A,L		; Get LSB of end
    2406/    423E : 93                  	SUB	E		; Subtract LSB of beginning
    2407/    423F : 4F                  	LD	C,A		; Save difference if C
    2408/    4240 : 7C                  	LD	A,H		; Get MSB of end
    2409/    4241 : 9A                  	SBC	A,D		; Subtract MSB of beginning
    2410/    4242 : 41                  ACPASS: LD	B,C		; Return integer AC
    2411/    4243 : 50                  ABPASS: LD	D,B		; Return integer AB
    2412/    4244 : 1E 00               	LD	E,0
    2413/    4246 : 21 F2 80            	LD	HL,TYPE		; Point to type
    2414/    4249 : 73                  	LD	(HL),E		; Set type to numeric
    2415/    424A : 06 90               	LD	B,80H+16	; 16 bit integer
    2416/    424C : C3 83 48            	JP	RETINT		; Return the integr
    2417/    424F :                     ;
    2418/    424F : 3A F0 80            POS:	LD	A,(CURPOS)	; Get cursor position
    2419/    4252 : 47                  PASSA:	LD	B,A		; Put A into AB
    2420/    4253 : AF                  	XOR	A		; Zero A
    2421/    4254 : C3 43 42            	JP	ABPASS		; Return integer AB
    2422/    4257 :                     ;
    2423/    4257 : CD DA 42            DEF:	CALL	CHEKFN		; Get "FN" and name
    2424/    425A : CD CC 42            	CALL	IDTEST		; Test for illegal direct
    2425/    425D : 01 B1 3B            	LD	BC,DATA		; To get next statement
    2426/    4260 : C5                  	PUSH	BC		; Save address for RETurn
    2427/    4261 : D5                  	PUSH	DE		; Save address of function ptr
    2428/    4262 : CD 88 38            	CALL	CHKSYN		; Make sure "(" follows
    2429/    4265 : 28                  	DB	"("
    2430/    4266 : CD 7E 40            	CALL	GETVAR		; Get argument variable name
    2431/    4269 : E5                  	PUSH	HL		; Save code string address
    2432/    426A : EB                  	EX	DE,HL		; Argument address to HL
    2433/    426B : 2B                  	DEC	HL
    2434/    426C : 56                  	LD	D,(HL)		; Get first byte of arg name
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 42 - 12/29/2022 20:41:36


    2435/    426D : 2B                  	DEC	HL
    2436/    426E : 5E                  	LD	E,(HL)		; Get second byte of arg name
    2437/    426F : E1                  	POP	HL		; Restore code string address
    2438/    4270 : CD 8A 3E            	CALL	TSTNUM		; Make sure numeric argument
    2439/    4273 : CD 88 38            	CALL	CHKSYN		; Make sure ")" follows
    2440/    4276 : 29                  	DB	")"
    2441/    4277 : CD 88 38            	CALL	CHKSYN		; Make sure "=" follows
    2442/    427A : B4                  	DB	ZEQUAL		; "=" token
    2443/    427B : 44                  	LD	B,H		; Code string address to BC
    2444/    427C : 4D                  	LD	C,L
    2445/    427D : E3                  	EX	(SP),HL		; Save code str , Get FN ptr
    2446/    427E : 71                  	LD	(HL),C		; Save LSB of FN code string
    2447/    427F : 23                  	INC	HL
    2448/    4280 : 70                  	LD	(HL),B		; Save MSB of FN code string
    2449/    4281 : C3 19 43            	JP	SVSTAD		; Save address and do function
    2450/    4284 :                     ;
    2451/    4284 : CD DA 42            DOFN:	CALL	CHEKFN		; Make sure FN follows
    2452/    4287 : D5                  	PUSH	DE		; Save function pointer address
    2453/    4288 : CD 5F 3F            	CALL	EVLPAR		; Evaluate expression in "()"
    2454/    428B : CD 8A 3E            	CALL	TSTNUM		; Make sure numeric result
    2455/    428E : E3                  	EX	(SP),HL		; Save code str , Get FN ptr
    2456/    428F : 5E                  	LD	E,(HL)		; Get LSB of FN code string
    2457/    4290 : 23                  	INC	HL
    2458/    4291 : 56                  	LD	D,(HL)		; Get MSB of FN code string
    2459/    4292 : 23                  	INC	HL
    2460/    4293 : 7A                  	LD	A,D		; And function DEFined?
    2461/    4294 : B3                  	OR	E
    2462/    4295 : CA C6 35            	JP	Z,UFERR		; No - ?UF Error
    2463/    4298 : 7E                  	LD	A,(HL)		; Get LSB of argument address
    2464/    4299 : 23                  	INC	HL
    2465/    429A : 66                  	LD	H,(HL)		; Get MSB of argument address
    2466/    429B : 6F                  	LD	L,A		; HL = Arg variable address
    2467/    429C : E5                  	PUSH	HL		; Save it
    2468/    429D : 2A 23 81            	LD	HL,(FNRGNM)	; Get old argument name
    2469/    42A0 : E3                  	EX	(SP),HL;	; Save old , Get new
    2470/    42A1 : 22 23 81            	LD	(FNRGNM),HL	; Set new argument name
    2471/    42A4 : 2A 27 81            	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
    2472/    42A7 : E5                  	PUSH	HL		; Save it
    2473/    42A8 : 2A 25 81            	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
    2474/    42AB : E5                  	PUSH	HL		; Save it
    2475/    42AC : 21 25 81            	LD	HL,FNARG	; HL = Value of argument
    2476/    42AF : D5                  	PUSH	DE		; Save FN code string address
    2477/    42B0 : CD C4 48            	CALL	FPTHL		; Move FPREG to argument
    2478/    42B3 : E1                  	POP	HL		; Get FN code string address
    2479/    42B4 : CD 87 3E            	CALL	GETNUM		; Get value from function
    2480/    42B7 : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2481/    42B8 : CD 16 3A            	CALL	GETCHR		; Get next character
    2482/    42BB : C2 BA 35            	JP	NZ,SNERR	; Bad character in FN - Error
    2483/    42BE : E1                  	POP	HL		; Get MSB,EXP of old arg
    2484/    42BF : 22 25 81            	LD	(FNARG),HL	; Restore it
    2485/    42C2 : E1                  	POP	HL		; Get LSB,NLSB of old arg
    2486/    42C3 : 22 27 81            	LD	(FNARG+2),HL	; Restore it
    2487/    42C6 : E1                  	POP	HL		; Get name of old arg
    2488/    42C7 : 22 23 81            	LD	(FNRGNM),HL	; Restore it
    2489/    42CA : E1                  	POP	HL		; Restore code string address
    2490/    42CB : C9                  	RET
    2491/    42CC :                     ;
    2492/    42CC : E5                  IDTEST: PUSH	HL		; Save code string address
    2493/    42CD : 2A A1 80            	LD	HL,(LINEAT)	; Get current line number
    2494/    42D0 : 23                  	INC	HL		; -1 means direct statement
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 43 - 12/29/2022 20:41:36


    2495/    42D1 : 7C                  	LD	A,H
    2496/    42D2 : B5                  	OR	L
    2497/    42D3 : E1                  	POP	HL		; Restore code string address
    2498/    42D4 : C0                  	RET	NZ		; Return if in program
    2499/    42D5 : 1E 16               	LD	E,ID		; ?ID Error
    2500/    42D7 : C3 CE 35            	JP	ERROR
    2501/    42DA :                     ;
    2502/    42DA : CD 88 38            CHEKFN: CALL	CHKSYN		; Make sure FN follows
    2503/    42DD : A7                  	DB	ZFN		; "FN" token
    2504/    42DE : 3E 80               	LD	A,80H
    2505/    42E0 : 32 10 81            	LD	(FORFLG),A	; Flag FN name to find
    2506/    42E3 : B6                  	OR	(HL)		; FN name has bit 7 set
    2507/    42E4 : 47                  	LD	B,A		; in first byte of name
    2508/    42E5 : CD 83 40            	CALL	GTFNAM		; Get FN name
    2509/    42E8 : C3 8A 3E            	JP	TSTNUM		; Make sure numeric function
    2510/    42EB :                     ;
    2511/    42EB : CD 8A 3E            STR:	CALL	TSTNUM		; Make sure it's a number
    2512/    42EE : CD 11 4A            	CALL	NUMASC		; Turn number into text
    2513/    42F1 : CD 1F 43            STR1:	CALL	CRTST		; Create string entry for it
    2514/    42F4 : CD A4 44            	CALL	GSTRCU		; Current string to pool
    2515/    42F7 : 01 FF 44            	LD	BC,TOPOOL	; Save in string pool
    2516/    42FA : C5                  	PUSH	BC		; Save address on stack
    2517/    42FB :                     ;
    2518/    42FB : 7E                  SAVSTR: LD	A,(HL)		; Get string length
    2519/    42FC : 23                  	INC	HL
    2520/    42FD : 23                  	INC	HL
    2521/    42FE : E5                  	PUSH	HL		; Save pointer to string
    2522/    42FF : CD 7A 43            	CALL	TESTR		; See if enough string space
    2523/    4302 : E1                  	POP	HL		; Restore pointer to string
    2524/    4303 : 4E                  	LD	C,(HL)		; Get LSB of address
    2525/    4304 : 23                  	INC	HL
    2526/    4305 : 46                  	LD	B,(HL)		; Get MSB of address
    2527/    4306 : CD 13 43            	CALL	CRTMST		; Create string entry
    2528/    4309 : E5                  	PUSH	HL		; Save pointer to MSB of addr
    2529/    430A : 6F                  	LD	L,A		; Length of string
    2530/    430B : CD 97 44            	CALL	TOSTRA		; Move to string area
    2531/    430E : D1                  	POP	DE		; Restore pointer to MSB
    2532/    430F : C9                  	RET
    2533/    4310 :                     ;
    2534/    4310 : CD 7A 43            MKTMST: CALL	TESTR		; See if enough string space
    2535/    4313 : 21 04 81            CRTMST: LD	HL,TMPSTR	; Temporary string
    2536/    4316 : E5                  	PUSH	HL		; Save it
    2537/    4317 : 77                  	LD	(HL),A		; Save length of string
    2538/    4318 : 23                  	INC	HL
    2539/    4319 : 23                  SVSTAD: INC	HL
    2540/    431A : 73                  	LD	(HL),E		; Save LSB of address
    2541/    431B : 23                  	INC	HL
    2542/    431C : 72                  	LD	(HL),D		; Save MSB of address
    2543/    431D : E1                  	POP	HL		; Restore pointer
    2544/    431E : C9                  	RET
    2545/    431F :                     ;
    2546/    431F : 2B                  CRTST:	DEC	HL		; DEC - INCed after
    2547/    4320 : 06 22               QTSTR:	LD	B,'"'		; Terminating quote
    2548/    4322 : 50                  	LD	D,B		; Quote to D
    2549/    4323 : E5                  DTSTR:	PUSH	HL		; Save start
    2550/    4324 : 0E FF               	LD	C,-1		; Set counter to -1
    2551/    4326 : 23                  QTSTLP: INC	HL		; Move on
    2552/    4327 : 7E                  	LD	A,(HL)		; Get byte
    2553/    4328 : 0C                  	INC	C		; Count bytes
    2554/    4329 : B7                  	OR	A		; End of line?
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 44 - 12/29/2022 20:41:36


    2555/    432A : CA 35 43            	JP	Z,CRTSTE	; Yes - Create string entry
    2556/    432D : BA                  	CP	D		; Terminator D found?
    2557/    432E : CA 35 43            	JP	Z,CRTSTE	; Yes - Create string entry
    2558/    4331 : B8                  	CP	B		; Terminator B found?
    2559/    4332 : C2 26 43            	JP	NZ,QTSTLP	; No - Keep looking
    2560/    4335 : FE 22               CRTSTE: CP	'"'		; End with '"'?
    2561/    4337 : CC 16 3A            	CALL	Z,GETCHR	; Yes - Get next character
    2562/    433A : E3                  	EX	(SP),HL		; Starting quote
    2563/    433B : 23                  	INC	HL		; First byte of string
    2564/    433C : EB                  	EX	DE,HL		; To DE
    2565/    433D : 79                  	LD	A,C		; Get length
    2566/    433E : CD 13 43            	CALL	CRTMST		; Create string entry
    2567/    4341 : 11 04 81            TSTOPL: LD	DE,TMPSTR	; Temporary string
    2568/    4344 : 2A F6 80            	LD	HL,(TMSTPT)	; Temporary string pool pointer
    2569/    4347 : 22 29 81            	LD	(FPREG),HL	; Save address of string ptr
    2570/    434A : 3E 01               	LD	A,1
    2571/    434C : 32 F2 80            	LD	(TYPE),A	; Set type to string
    2572/    434F : CD C7 48            	CALL	DETHL4		; Move string to pool
    2573/    4352 : CD 82 38            	CALL	CPDEHL		; Out of string pool?
    2574/    4355 : 22 F6 80            	LD	(TMSTPT),HL	; Save new pointer
    2575/    4358 : E1                  	POP	HL		; Restore code string address
    2576/    4359 : 7E                  	LD	A,(HL)		; Get next code byte
    2577/    435A : C0                  	RET	NZ		; Return if pool OK
    2578/    435B : 1E 1E               	LD	E,ST		; ?ST Error
    2579/    435D : C3 CE 35            	JP	ERROR		; String pool overflow
    2580/    4360 :                     ;
    2581/    4360 : 23                  PRNUMS: INC	HL		; Skip leading space
    2582/    4361 : CD 1F 43            PRS:	CALL	CRTST		; Create string entry for it
    2583/    4364 : CD A4 44            PRS1:	CALL	GSTRCU		; Current string to pool
    2584/    4367 : CD BB 48            	CALL	LOADFP		; Move string block to BCDE
    2585/    436A : 1C                  	INC	E		; Length + 1
    2586/    436B : 1D                  PRSLP:	DEC	E		; Count characters
    2587/    436C : C8                  	RET	Z		; End of string
    2588/    436D : 0A                  	LD	A,(BC)		; Get byte to output
    2589/    436E : CD 93 38            	CALL	OUTC		; Output character in A
    2590/    4371 : FE 0D               	CP	CR		; Return?
    2591/    4373 : CC CC 3C            	CALL	Z,DONULL	; Yes - Do nulls
    2592/    4376 : 03                  	INC	BC		; Next byte in string
    2593/    4377 : C3 6B 43            	JP	PRSLP		; More characters to output
    2594/    437A :                     ;
    2595/    437A : B7                  TESTR:	OR	A		; Test if enough room
    2596/    437B : 0E                  	DB	0EH		; No garbage collection done
    2597/    437C : F1                  GRBDON: POP	AF		; Garbage collection done
    2598/    437D : F5                  	PUSH	AF		; Save status
    2599/    437E : 2A 9F 80            	LD	HL,(STRSPC)	; Bottom of string space in use
    2600/    4381 : EB                  	EX	DE,HL		; To DE
    2601/    4382 : 2A 08 81            	LD	HL,(STRBOT)	; Bottom of string area
    2602/    4385 : 2F                  	CPL			; Negate length (Top down)
    2603/    4386 : 4F                  	LD	C,A		; -Length to BC
    2604/    4387 : 06 FF               	LD	B,-1		; BC = -ve length of string
    2605/    4389 : 09                  	ADD	HL,BC		; Add to bottom of space in use
    2606/    438A : 23                  	INC	HL		; Plus one for 2's complement
    2607/    438B : CD 82 38            	CALL	CPDEHL		; Below string RAM area?
    2608/    438E : DA 98 43            	JP	C,TESTOS	; Tidy up if not done else err
    2609/    4391 : 22 08 81            	LD	(STRBOT),HL	; Save new bottom of area
    2610/    4394 : 23                  	INC	HL		; Point to first byte of string
    2611/    4395 : EB                  	EX	DE,HL		; Address to DE
    2612/    4396 : F1                  POPAF:	POP	AF		; Throw away status push
    2613/    4397 : C9                  	RET
    2614/    4398 :                     ;
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 45 - 12/29/2022 20:41:36


    2615/    4398 : F1                  TESTOS: POP	AF		; Garbage collect been done?
    2616/    4399 : 1E 1A               	LD	E,OS		; ?OS Error
    2617/    439B : CA CE 35            	JP	Z,ERROR		; Yes - Not enough string apace
    2618/    439E : BF                  	CP	A		; Flag garbage collect done
    2619/    439F : F5                  	PUSH	AF		; Save status
    2620/    43A0 : 01 7C 43            	LD	BC,GRBDON	; Garbage collection done
    2621/    43A3 : C5                  	PUSH	BC		; Save for RETurn
    2622/    43A4 : 2A F4 80            GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
    2623/    43A7 : 22 08 81            GARBLP: LD	(STRBOT),HL	; Reset string pointer
    2624/    43AA : 21 00 00            	LD	HL,0
    2625/    43AD : E5                  	PUSH	HL		; Flag no string found
    2626/    43AE : 2A 9F 80            	LD	HL,(STRSPC)	; Get bottom of string space
    2627/    43B1 : E5                  	PUSH	HL		; Save bottom of string space
    2628/    43B2 : 21 F8 80            	LD	HL,TMSTPL	; Temporary string pool
    2629/    43B5 : EB                  GRBLP:	EX	DE,HL
    2630/    43B6 : 2A F6 80            	LD	HL,(TMSTPT)	; Temporary string pool pointer
    2631/    43B9 : EB                  	EX	DE,HL
    2632/    43BA : CD 82 38            	CALL	CPDEHL		; Temporary string pool done?
    2633/    43BD : 01 B5 43            	LD	BC,GRBLP	; Loop until string pool done
    2634/    43C0 : C2 09 44            	JP	NZ,STPOOL	; No - See if in string area
    2635/    43C3 : 2A 1B 81            	LD	HL,(PROGND)	; Start of simple variables
    2636/    43C6 : EB                  SMPVAR: EX	DE,HL
    2637/    43C7 : 2A 1D 81            	LD	HL,(VAREND)	; End of simple variables
    2638/    43CA : EB                  	EX	DE,HL
    2639/    43CB : CD 82 38            	CALL	CPDEHL		; All simple strings done?
    2640/    43CE : CA DC 43            	JP	Z,ARRLP		; Yes - Do string arrays
    2641/    43D1 : 7E                  	LD	A,(HL)		; Get type of variable
    2642/    43D2 : 23                  	INC	HL
    2643/    43D3 : 23                  	INC	HL
    2644/    43D4 : B7                  	OR	A		; "S" flag set if string
    2645/    43D5 : CD 0C 44            	CALL	STRADD		; See if string in string area
    2646/    43D8 : C3 C6 43            	JP	SMPVAR		; Loop until simple ones done
    2647/    43DB :                     ;
    2648/    43DB : C1                  GNXARY: POP	BC		; Scrap address of this array
    2649/    43DC : EB                  ARRLP:	EX	DE,HL
    2650/    43DD : 2A 1F 81            	LD	HL,(ARREND)	; End of string arrays
    2651/    43E0 : EB                  	EX	DE,HL
    2652/    43E1 : CD 82 38            	CALL	CPDEHL		; All string arrays done?
    2653/    43E4 : CA 32 44            	JP	Z,SCNEND	; Yes - Move string if found
    2654/    43E7 : CD BB 48            	CALL	LOADFP		; Get array name to BCDE
    2655/    43EA : 7B                  	LD	A,E		; Get type of array	
    2656/    43EB : E5                  	PUSH	HL		; Save address of num of dim'ns
    2657/    43EC : 09                  	ADD	HL,BC		; Start of next array
    2658/    43ED : B7                  	OR	A		; Test type of array
    2659/    43EE : F2 DB 43            	JP	P,GNXARY	; Numeric array - Ignore it
    2660/    43F1 : 22 0A 81            	LD	(CUROPR),HL	; Save address of next array
    2661/    43F4 : E1                  	POP	HL		; Get address of num of dim'ns
    2662/    43F5 : 4E                  	LD	C,(HL)		; BC = Number of dimensions
    2663/    43F6 : 06 00               	LD	B,0
    2664/    43F8 : 09                  	ADD	HL,BC		; Two bytes per dimension size
    2665/    43F9 : 09                  	ADD	HL,BC
    2666/    43FA : 23                  	INC	HL		; Plus one for number of dim'ns
    2667/    43FB : EB                  GRBARY: EX	DE,HL
    2668/    43FC : 2A 0A 81            	LD	HL,(CUROPR)	; Get address of next array
    2669/    43FF : EB                  	EX	DE,HL
    2670/    4400 : CD 82 38            	CALL	CPDEHL		; Is this array finished?
    2671/    4403 : CA DC 43            	JP	Z,ARRLP		; Yes - Get next one
    2672/    4406 : 01 FB 43            	LD	BC,GRBARY	; Loop until array all done
    2673/    4409 : C5                  STPOOL: PUSH	BC		; Save return address
    2674/    440A : F6 80               	OR	80H		; Flag string type
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 46 - 12/29/2022 20:41:36


    2675/    440C : 7E                  STRADD: LD	A,(HL)		; Get string length
    2676/    440D : 23                  	INC	HL
    2677/    440E : 23                  	INC	HL
    2678/    440F : 5E                  	LD	E,(HL)		; Get LSB of string address
    2679/    4410 : 23                  	INC	HL
    2680/    4411 : 56                  	LD	D,(HL)		; Get MSB of string address
    2681/    4412 : 23                  	INC	HL
    2682/    4413 : F0                  	RET	P		; Not a string - Return
    2683/    4414 : B7                  	OR	A		; Set flags on string length
    2684/    4415 : C8                  	RET	Z		; Null string - Return
    2685/    4416 : 44                  	LD	B,H		; Save variable pointer
    2686/    4417 : 4D                  	LD	C,L
    2687/    4418 : 2A 08 81            	LD	HL,(STRBOT)	; Bottom of new area
    2688/    441B : CD 82 38            	CALL	CPDEHL		; String been done?
    2689/    441E : 60                  	LD	H,B		; Restore variable pointer
    2690/    441F : 69                  	LD	L,C
    2691/    4420 : D8                  	RET	C		; String done - Ignore
    2692/    4421 : E1                  	POP	HL		; Return address
    2693/    4422 : E3                  	EX	(SP),HL		; Lowest available string area
    2694/    4423 : CD 82 38            	CALL	CPDEHL		; String within string area?
    2695/    4426 : E3                  	EX	(SP),HL		; Lowest available string area
    2696/    4427 : E5                  	PUSH	HL		; Re-save return address
    2697/    4428 : 60                  	LD	H,B		; Restore variable pointer
    2698/    4429 : 69                  	LD	L,C
    2699/    442A : D0                  	RET	NC		; Outside string area - Ignore
    2700/    442B : C1                  	POP	BC		; Get return , Throw 2 away
    2701/    442C : F1                  	POP	AF		; 
    2702/    442D : F1                  	POP	AF		; 
    2703/    442E : E5                  	PUSH	HL		; Save variable pointer
    2704/    442F : D5                  	PUSH	DE		; Save address of current
    2705/    4430 : C5                  	PUSH	BC		; Put back return address
    2706/    4431 : C9                  	RET			; Go to it
    2707/    4432 :                     ;
    2708/    4432 : D1                  SCNEND: POP	DE		; Addresses of strings
    2709/    4433 : E1                  	POP	HL		; 
    2710/    4434 : 7D                  	LD	A,L		; HL = 0 if no more to do
    2711/    4435 : B4                  	OR	H
    2712/    4436 : C8                  	RET	Z		; No more to do - Return
    2713/    4437 : 2B                  	DEC	HL
    2714/    4438 : 46                  	LD	B,(HL)		; MSB of address of string
    2715/    4439 : 2B                  	DEC	HL
    2716/    443A : 4E                  	LD	C,(HL)		; LSB of address of string
    2717/    443B : E5                  	PUSH	HL		; Save variable address
    2718/    443C : 2B                  	DEC	HL
    2719/    443D : 2B                  	DEC	HL
    2720/    443E : 6E                  	LD	L,(HL)		; HL = Length of string
    2721/    443F : 26 00               	LD	H,0
    2722/    4441 : 09                  	ADD	HL,BC		; Address of end of string+1
    2723/    4442 : 50                  	LD	D,B		; String address to DE
    2724/    4443 : 59                  	LD	E,C
    2725/    4444 : 2B                  	DEC	HL		; Last byte in string
    2726/    4445 : 44                  	LD	B,H		; Address to BC
    2727/    4446 : 4D                  	LD	C,L
    2728/    4447 : 2A 08 81            	LD	HL,(STRBOT)	; Current bottom of string area
    2729/    444A : CD 89 35            	CALL	MOVSTR		; Move string to new address
    2730/    444D : E1                  	POP	HL		; Restore variable address
    2731/    444E : 71                  	LD	(HL),C		; Save new LSB of address
    2732/    444F : 23                  	INC	HL
    2733/    4450 : 70                  	LD	(HL),B		; Save new MSB of address
    2734/    4451 : 69                  	LD	L,C		; Next string area+1 to HL
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 47 - 12/29/2022 20:41:36


    2735/    4452 : 60                  	LD	H,B
    2736/    4453 : 2B                  	DEC	HL		; Next string area address
    2737/    4454 : C3 A7 43            	JP	GARBLP		; Look for more strings
    2738/    4457 :                     ;
    2739/    4457 : C5                  CONCAT: PUSH	BC		; Save prec' opr & code string
    2740/    4458 : E5                  	PUSH	HL		; 
    2741/    4459 : 2A 29 81            	LD	HL,(FPREG)	; Get first string
    2742/    445C : E3                  	EX	(SP),HL		; Save first string
    2743/    445D : CD 10 3F            	CALL	OPRND		; Get second string
    2744/    4460 : E3                  	EX	(SP),HL		; Restore first string
    2745/    4461 : CD 8B 3E            	CALL	TSTSTR		; Make sure it's a string
    2746/    4464 : 7E                  	LD	A,(HL)		; Get length of second string
    2747/    4465 : E5                  	PUSH	HL		; Save first string
    2748/    4466 : 2A 29 81            	LD	HL,(FPREG)	; Get second string
    2749/    4469 : E5                  	PUSH	HL		; Save second string
    2750/    446A : 86                  	ADD	A,(HL)		; Add length of second string
    2751/    446B : 1E 1C               	LD	E,LS		; ?LS Error
    2752/    446D : DA CE 35            	JP	C,ERROR		; String too long - Error
    2753/    4470 : CD 10 43            	CALL	MKTMST		; Make temporary string
    2754/    4473 : D1                  	POP	DE		; Get second string to DE
    2755/    4474 : CD A8 44            	CALL	GSTRDE		; Move to string pool if needed
    2756/    4477 : E3                  	EX	(SP),HL		; Get first string
    2757/    4478 : CD A7 44            	CALL	GSTRHL		; Move to string pool if needed
    2758/    447B : E5                  	PUSH	HL		; Save first string
    2759/    447C : 2A 06 81            	LD	HL,(TMPSTR+2)	; Temporary string address
    2760/    447F : EB                  	EX	DE,HL		; To DE
    2761/    4480 : CD 8E 44            	CALL	SSTSA		; First string to string area
    2762/    4483 : CD 8E 44            	CALL	SSTSA		; Second string to string area
    2763/    4486 : 21 A5 3E            	LD	HL,EVAL2	; Return to evaluation loop
    2764/    4489 : E3                  	EX	(SP),HL		; Save return,get code string
    2765/    448A : E5                  	PUSH	HL		; Save code string address
    2766/    448B : C3 41 43            	JP	TSTOPL		; To temporary string to pool
    2767/    448E :                     ;
    2768/    448E : E1                  SSTSA:	POP	HL		; Return address
    2769/    448F : E3                  	EX	(SP),HL		; Get string block,save return
    2770/    4490 : 7E                  	LD	A,(HL)		; Get length of string
    2771/    4491 : 23                  	INC	HL
    2772/    4492 : 23                  	INC	HL
    2773/    4493 : 4E                  	LD	C,(HL)		; Get LSB of string address
    2774/    4494 : 23                  	INC	HL
    2775/    4495 : 46                  	LD	B,(HL)		; Get MSB of string address
    2776/    4496 : 6F                  	LD	L,A		; Length to L
    2777/    4497 : 2C                  TOSTRA: INC	L		; INC - DECed after
    2778/    4498 : 2D                  TSALP:	DEC	L		; Count bytes moved
    2779/    4499 : C8                  	RET	Z		; End of string - Return
    2780/    449A : 0A                  	LD	A,(BC)		; Get source
    2781/    449B : 12                  	LD	(DE),A		; Save destination
    2782/    449C : 03                  	INC	BC		; Next source
    2783/    449D : 13                  	INC	DE		; Next destination
    2784/    449E : C3 98 44            	JP	TSALP		; Loop until string moved
    2785/    44A1 :                     ;
    2786/    44A1 : CD 8B 3E            GETSTR: CALL	TSTSTR		; Make sure it's a string
    2787/    44A4 : 2A 29 81            GSTRCU: LD	HL,(FPREG)	; Get current string
    2788/    44A7 : EB                  GSTRHL: EX	DE,HL		; Save DE
    2789/    44A8 : CD C2 44            GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
    2790/    44AB : EB                  	EX	DE,HL		; Restore DE
    2791/    44AC : C0                  	RET	NZ		; No - Return
    2792/    44AD : D5                  	PUSH	DE		; Save string
    2793/    44AE : 50                  	LD	D,B		; String block address to DE
    2794/    44AF : 59                  	LD	E,C
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 48 - 12/29/2022 20:41:36


    2795/    44B0 : 1B                  	DEC	DE		; Point to length
    2796/    44B1 : 4E                  	LD	C,(HL)		; Get string length
    2797/    44B2 : 2A 08 81            	LD	HL,(STRBOT)	; Current bottom of string area
    2798/    44B5 : CD 82 38            	CALL	CPDEHL		; Last one in string area?
    2799/    44B8 : C2 C0 44            	JP	NZ,POPHL	; No - Return
    2800/    44BB : 47                  	LD	B,A		; Clear B (A=0)
    2801/    44BC : 09                  	ADD	HL,BC		; Remove string from str' area
    2802/    44BD : 22 08 81            	LD	(STRBOT),HL	; Save new bottom of str' area
    2803/    44C0 : E1                  POPHL:	POP	HL		; Restore string
    2804/    44C1 : C9                  	RET
    2805/    44C2 :                     ;
    2806/    44C2 : 2A F6 80            BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
    2807/    44C5 : 2B                  	DEC	HL		; Back
    2808/    44C6 : 46                  	LD	B,(HL)		; Get MSB of address
    2809/    44C7 : 2B                  	DEC	HL		; Back
    2810/    44C8 : 4E                  	LD	C,(HL)		; Get LSB of address
    2811/    44C9 : 2B                  	DEC	HL		; Back
    2812/    44CA : 2B                  	DEC	HL		; Back
    2813/    44CB : CD 82 38            	CALL	CPDEHL		; String last in string pool?
    2814/    44CE : C0                  	RET	NZ		; Yes - Leave it
    2815/    44CF : 22 F6 80            	LD	(TMSTPT),HL	; Save new string pool top
    2816/    44D2 : C9                  	RET
    2817/    44D3 :                     ;
    2818/    44D3 : 01 52 42            LEN:	LD	BC,PASSA	; To return integer A
    2819/    44D6 : C5                  	PUSH	BC		; Save address
    2820/    44D7 : CD A1 44            GETLEN: CALL	GETSTR		; Get string and its length
    2821/    44DA : AF                  	XOR	A
    2822/    44DB : 57                  	LD	D,A		; Clear D
    2823/    44DC : 32 F2 80            	LD	(TYPE),A	; Set type to numeric
    2824/    44DF : 7E                  	LD	A,(HL)		; Get length of string
    2825/    44E0 : B7                  	OR	A		; Set status flags
    2826/    44E1 : C9                  	RET
    2827/    44E2 :                     ;
    2828/    44E2 : 01 52 42            ASC:	LD	BC,PASSA	; To return integer A
    2829/    44E5 : C5                  	PUSH	BC		; Save address
    2830/    44E6 : CD D7 44            GTFLNM: CALL	GETLEN		; Get length of string
    2831/    44E9 : CA E1 3A            	JP	Z,FCERR		; Null string - Error
    2832/    44EC : 23                  	INC	HL
    2833/    44ED : 23                  	INC	HL
    2834/    44EE : 5E                  	LD	E,(HL)		; Get LSB of address
    2835/    44EF : 23                  	INC	HL
    2836/    44F0 : 56                  	LD	D,(HL)		; Get MSB of address
    2837/    44F1 : 1A                  	LD	A,(DE)		; Get first byte of string
    2838/    44F2 : C9                  	RET
    2839/    44F3 :                     ;
    2840/    44F3 : 3E 01               CHR:	LD	A,1		; One character string
    2841/    44F5 : CD 10 43            	CALL	MKTMST		; Make a temporary string
    2842/    44F8 : CD EE 45            	CALL	MAKINT		; Make it integer A
    2843/    44FB : 2A 06 81            	LD	HL,(TMPSTR+2)	; Get address of string
    2844/    44FE : 73                  	LD	(HL),E		; Save character
    2845/    44FF : C1                  TOPOOL: POP	BC		; Clean up stack
    2846/    4500 : C3 41 43            	JP	TSTOPL		; Temporary string to pool
    2847/    4503 :                     ;
    2848/    4503 : CD 9E 45            LEFT:	CALL	LFRGNM		; Get number and ending ")"
    2849/    4506 : AF                  	XOR	A		; Start at first byte in string
    2850/    4507 : E3                  RIGHT1: EX	(SP),HL		; Save code string,Get string
    2851/    4508 : 4F                  	LD	C,A		; Starting position in string
    2852/    4509 : E5                  MID1:	PUSH	HL		; Save string block address
    2853/    450A : 7E                  	LD	A,(HL)		; Get length of string
    2854/    450B : B8                  	CP	B		; Compare with number given
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 49 - 12/29/2022 20:41:36


    2855/    450C : DA 11 45            	JP	C,ALLFOL	; All following bytes required
    2856/    450F : 78                  	LD	A,B		; Get new length
    2857/    4510 : 11                  	DB	11H		; Skip "LD C,0"
    2858/    4511 : 0E 00               ALLFOL: LD	C,0		; First byte of string
    2859/    4513 : C5                  	PUSH	BC		; Save position in string
    2860/    4514 : CD 7A 43            	CALL	TESTR		; See if enough string space
    2861/    4517 : C1                  	POP	BC		; Get position in string
    2862/    4518 : E1                  	POP	HL		; Restore string block address
    2863/    4519 : E5                  	PUSH	HL		; And re-save it
    2864/    451A : 23                  	INC	HL
    2865/    451B : 23                  	INC	HL
    2866/    451C : 46                  	LD	B,(HL)		; Get LSB of address
    2867/    451D : 23                  	INC	HL
    2868/    451E : 66                  	LD	H,(HL)		; Get MSB of address
    2869/    451F : 68                  	LD	L,B		; HL = address of string
    2870/    4520 : 06 00               	LD	B,0		; BC = starting address
    2871/    4522 : 09                  	ADD	HL,BC		; Point to that byte
    2872/    4523 : 44                  	LD	B,H		; BC = source string
    2873/    4524 : 4D                  	LD	C,L
    2874/    4525 : CD 13 43            	CALL	CRTMST		; Create a string entry
    2875/    4528 : 6F                  	LD	L,A		; Length of new string
    2876/    4529 : CD 97 44            	CALL	TOSTRA		; Move string to string area
    2877/    452C : D1                  	POP	DE		; Clear stack
    2878/    452D : CD A8 44            	CALL	GSTRDE		; Move to string pool if needed
    2879/    4530 : C3 41 43            	JP	TSTOPL		; Temporary string to pool
    2880/    4533 :                     ;
    2881/    4533 : CD 9E 45            RIGHT:	CALL	LFRGNM		; Get number and ending ")"
    2882/    4536 : D1                  	POP	DE		; Get string length
    2883/    4537 : D5                  	PUSH	DE		; And re-save
    2884/    4538 : 1A                  	LD	A,(DE)		; Get length
    2885/    4539 : 90                  	SUB	B		; Move back N bytes
    2886/    453A : C3 07 45            	JP	RIGHT1		; Go and get sub-string
    2887/    453D :                     ;
    2888/    453D : EB                  MID:	EX	DE,HL		; Get code string address
    2889/    453E : 7E                  	LD	A,(HL)		; Get next byte ',' or ")"
    2890/    453F : CD A3 45            	CALL	MIDNUM		; Get number supplied
    2891/    4542 : 04                  	INC	B		; Is it character zero?
    2892/    4543 : 05                  	DEC	B
    2893/    4544 : CA E1 3A            	JP	Z,FCERR		; Yes - Error
    2894/    4547 : C5                  	PUSH	BC		; Save starting position
    2895/    4548 : 1E FF               	LD	E,255		; All of string
    2896/    454A : FE 29               	CP	')'		; Any length given?
    2897/    454C : CA 56 45            	JP	Z,RSTSTR	; No - Rest of string
    2898/    454F : CD 88 38            	CALL	CHKSYN		; Make sure ',' follows
    2899/    4552 : 2C                  	DB	','
    2900/    4553 : CD EB 45            	CALL	GETINT		; Get integer 0-255
    2901/    4556 : CD 88 38            RSTSTR: CALL	CHKSYN		; Make sure ")" follows
    2902/    4559 : 29                  	DB	")"
    2903/    455A : F1                  	POP	AF		; Restore starting position
    2904/    455B : E3                  	EX	(SP),HL		; Get string,8ave code string
    2905/    455C : 01 09 45            	LD	BC,MID1		; Continuation of MID$ routine
    2906/    455F : C5                  	PUSH	BC		; Save for return
    2907/    4560 : 3D                  	DEC	A		; Starting position-1
    2908/    4561 : BE                  	CP	(HL)		; Compare with length
    2909/    4562 : 06 00               	LD	B,0		; Zero bytes length
    2910/    4564 : D0                  	RET	NC		; Null string if start past end
    2911/    4565 : 4F                  	LD	C,A		; Save starting position-1
    2912/    4566 : 7E                  	LD	A,(HL)		; Get length of string
    2913/    4567 : 91                  	SUB	C		; Subtract start
    2914/    4568 : BB                  	CP	E		; Enough string for it?
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 50 - 12/29/2022 20:41:36


    2915/    4569 : 47                  	LD	B,A		; Save maximum length available
    2916/    456A : D8                  	RET	C		; Truncate string if needed
    2917/    456B : 43                  	LD	B,E		; Set specified length
    2918/    456C : C9                  	RET			; Go and create string
    2919/    456D :                     ;
    2920/    456D : CD D7 44            VAL:	CALL	GETLEN		; Get length of string
    2921/    4570 : CA 8C 46            	JP	Z,RESZER	; Result zero
    2922/    4573 : 5F                  	LD	E,A		; Save length
    2923/    4574 : 23                  	INC	HL
    2924/    4575 : 23                  	INC	HL
    2925/    4576 : 7E                  	LD	A,(HL)		; Get LSB of address
    2926/    4577 : 23                  	INC	HL
    2927/    4578 : 66                  	LD	H,(HL)		; Get MSB of address
    2928/    4579 : 6F                  	LD	L,A		; HL = String address
    2929/    457A : E5                  	PUSH	HL		; Save string address
    2930/    457B : 19                  	ADD	HL,DE
    2931/    457C : 46                  	LD	B,(HL)		; Get end of string+1 byte
    2932/    457D : 72                  	LD	(HL),D		; Zero it to terminate
    2933/    457E : E3                  	EX	(SP),HL		; Save string end,get start
    2934/    457F : C5                  	PUSH	BC		; Save end+1 byte
    2935/    4580 : 7E                  	LD	A,(HL)		; Get starting byte
    2936/    4581 : FE 24               	CP	'$'		; Hex number indicated? [function added]
    2937/    4583 : C2 8C 45            	JP	NZ,VAL1
    2938/    4586 : CD BD 4D            	CALL	HEXTFP		; Convert Hex to FPREG
    2939/    4589 : C3 9A 45            	JP	VAL3
    2940/    458C : FE 25               VAL1:	CP	'%'		; Binary number indicated? [function added]
    2941/    458E : C2 97 45            	JP	NZ,VAL2
    2942/    4591 : CD 39 4E            	CALL	BINTFP		; Convert Bin to FPREG
    2943/    4594 : C3 9A 45            	JP	VAL3
    2944/    4597 : CD 73 49            VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
    2945/    459A : C1                  VAL3:	POP	BC		; Restore end+1 byte
    2946/    459B : E1                  	POP	HL		; Restore end+1 address
    2947/    459C : 70                  	LD	(HL),B		; Put back original byte
    2948/    459D : C9                  	RET
    2949/    459E :                     ;
    2950/    459E : EB                  LFRGNM: EX	DE,HL		; Code string address to HL
    2951/    459F : CD 88 38            	CALL	CHKSYN		; Make sure ")" follows
    2952/    45A2 : 29                  	DB	")"
    2953/    45A3 : C1                  MIDNUM: POP	BC		; Get return address
    2954/    45A4 : D1                  	POP	DE		; Get number supplied
    2955/    45A5 : C5                  	PUSH	BC		; Re-save return address
    2956/    45A6 : 43                  	LD	B,E		; Number to B
    2957/    45A7 : C9                  	RET
    2958/    45A8 :                     ;
    2959/    45A8 : CD EE 45            INP:	CALL	MAKINT		; Make it integer A
    2960/    45AB : 32 84 80            	LD	(INPORT),A	; Set input port
    2961/    45AE : CD 83 80            	CALL	INPSUB		; Get input from port
    2962/    45B1 : C3 52 42            	JP	PASSA		; Return integer A
    2963/    45B4 :                     ;
    2964/    45B4 : CD D8 45            POUT:	CALL	SETIO		; Set up port number
    2965/    45B7 : C3 4B 80            	JP	OUTSUB		; Output data and return
    2966/    45BA :                     ;
    2967/    45BA : CD D8 45            WAIT:	CALL	SETIO		; Set up port number
    2968/    45BD : F5                  	PUSH	AF		; Save AND mask
    2969/    45BE : 1E 00               	LD	E,0		; Assume zero if none given
    2970/    45C0 : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2971/    45C1 : CD 16 3A            	CALL	GETCHR		; Get next character
    2972/    45C4 : CA CE 45            	JP	Z,NOXOR		; No XOR byte given
    2973/    45C7 : CD 88 38            	CALL	CHKSYN		; Make sure ',' follows
    2974/    45CA : 2C                  	DB	','
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 51 - 12/29/2022 20:41:36


    2975/    45CB : CD EB 45            	CALL	GETINT		; Get integer 0-255 to XOR with
    2976/    45CE : C1                  NOXOR:	POP	BC		; Restore AND mask
    2977/    45CF : CD 83 80            WAITLP: CALL	INPSUB		; Get input
    2978/    45D2 : AB                  	XOR	E		; Flip selected bits
    2979/    45D3 : A0                  	AND	B		; Result non-zero?
    2980/    45D4 : CA CF 45            	JP	Z,WAITLP	; No = keep waiting
    2981/    45D7 : C9                  	RET
    2982/    45D8 :                     ;
    2983/    45D8 : CD EB 45            SETIO:	CALL	GETINT		; Get integer 0-255
    2984/    45DB : 32 84 80            	LD	(INPORT),A	; Set input port
    2985/    45DE : 32 4C 80            	LD	(OTPORT),A	; Set output port
    2986/    45E1 : CD 88 38            	CALL	CHKSYN		; Make sure ',' follows
    2987/    45E4 : 2C                  	DB	','
    2988/    45E5 : C3 EB 45            	JP	GETINT		; Get integer 0-255 and return
    2989/    45E8 :                     ;
    2990/    45E8 : CD 16 3A            FNDNUM: CALL	GETCHR		; Get next character
    2991/    45EB : CD 87 3E            GETINT: CALL	GETNUM		; Get a number from 0 to 255
    2992/    45EE : CD C6 3A            MAKINT: CALL	DEPINT		; Make sure value 0 - 255
    2993/    45F1 : 7A                  	LD	A,D		; Get MSB of number
    2994/    45F2 : B7                  	OR	A		; Zero?
    2995/    45F3 : C2 E1 3A            	JP	NZ,FCERR	; No - Error
    2996/    45F6 : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    2997/    45F7 : CD 16 3A            	CALL	GETCHR		; Get next character
    2998/    45FA : 7B                  	LD	A,E		; Get number to A
    2999/    45FB : C9                  	RET
    3000/    45FC :                     ;
    3001/    45FC : CD CC 3A            PEEK:	CALL	DEINT		; Get memory address
    3002/    45FF : 1A                  	LD	A,(DE)		; Get byte in memory
    3003/    4600 : C3 52 42            	JP	PASSA		; Return integer A
    3004/    4603 :                     ;
    3005/    4603 : CD 87 3E            POKE:	CALL	GETNUM		; Get memory address
    3006/    4606 : CD CC 3A            	CALL	DEINT		; Get integer -32768 to 3276
    3007/    4609 : D5                  	PUSH	DE		; Save memory address
    3008/    460A : CD 88 38            	CALL	CHKSYN		; Make sure ',' follows
    3009/    460D : 2C                  	DB	','
    3010/    460E : CD EB 45            	CALL	GETINT		; Get integer 0-255
    3011/    4611 : D1                  	POP	DE		; Restore memory address
    3012/    4612 : 12                  	LD	(DE),A		; Load it into memory
    3013/    4613 : C9                  	RET
    3014/    4614 :                     ;
    3015/    4614 : 21 EA 4A            ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
    3016/    4617 : CD BB 48            ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
    3017/    461A : C3 26 46            	JP	FPADD		; Add BCDE to FPREG
    3018/    461D :                     ;
    3019/    461D : CD BB 48            SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
    3020/    4620 : 21                  	DB	21H		; Skip "POP BC" and "POP DE"
    3021/    4621 : C1                  PSUB:	POP	BC		; Get FP number from stack
    3022/    4622 : D1                  	POP	DE
    3023/    4623 : CD 95 48            SUBCDE: CALL	INVSGN		; Negate FPREG
    3024/    4626 : 78                  FPADD:	LD	A,B		; Get FP exponent
    3025/    4627 : B7                  	OR	A		; Is number zero?
    3026/    4628 : C8                  	RET	Z		; Yes - Nothing to add
    3027/    4629 : 3A 2C 81            	LD	A,(FPEXP)	; Get FPREG exponent
    3028/    462C : B7                  	OR	A		; Is this number zero?
    3029/    462D : CA AD 48            	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
    3030/    4630 : 90                  	SUB	B		; BCDE number larger?
    3031/    4631 : D2 40 46            	JP	NC,NOSWAP	; No - Don't swap them
    3032/    4634 : 2F                  	CPL			; Two's complement
    3033/    4635 : 3C                  	INC	A		;	FP exponent
    3034/    4636 : EB                  	EX	DE,HL
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 52 - 12/29/2022 20:41:36


    3035/    4637 : CD 9D 48            	CALL	STAKFP		; Put FPREG on stack
    3036/    463A : EB                  	EX	DE,HL
    3037/    463B : CD AD 48            	CALL	FPBCDE		; Move BCDE to FPREG
    3038/    463E : C1                  	POP	BC		; Restore number from stack
    3039/    463F : D1                  	POP	DE
    3040/    4640 : FE 19               NOSWAP: CP	24+1		; Second number insignificant?
    3041/    4642 : D0                  	RET	NC		; Yes - First number is result
    3042/    4643 : F5                  	PUSH	AF		; Save number of bits to scale
    3043/    4644 : CD D2 48            	CALL	SIGNS		; Set MSBs & sign of result
    3044/    4647 : 67                  	LD	H,A		; Save sign of result
    3045/    4648 : F1                  	POP	AF		; Restore scaling factor
    3046/    4649 : CD EB 46            	CALL	SCALE		; Scale BCDE to same exponent
    3047/    464C : B4                  	OR	H		; Result to be positive?
    3048/    464D : 21 29 81            	LD	HL,FPREG	; Point to FPREG
    3049/    4650 : F2 66 46            	JP	P,MINCDE	; No - Subtract FPREG from CDE
    3050/    4653 : CD CB 46            	CALL	PLUCDE		; Add FPREG to CDE
    3051/    4656 : D2 AC 46            	JP	NC,RONDUP	; No overflow - Round it up
    3052/    4659 : 23                  	INC	HL		; Point to exponent
    3053/    465A : 34                  	INC	(HL)		; Increment it
    3054/    465B : CA C9 35            	JP	Z,OVERR		; Number overflowed - Error
    3055/    465E : 2E 01               	LD	L,1		; 1 bit to shift right
    3056/    4660 : CD 01 47            	CALL	SHRT1		; Shift result right
    3057/    4663 : C3 AC 46            	JP	RONDUP		; Round it up
    3058/    4666 :                     ;
    3059/    4666 : AF                  MINCDE: XOR	A		; Clear A and carry
    3060/    4667 : 90                  	SUB	B		; Negate exponent
    3061/    4668 : 47                  	LD	B,A		; Re-save exponent
    3062/    4669 : 7E                  	LD	A,(HL)		; Get LSB of FPREG
    3063/    466A : 9B                  	SBC	A, E		; Subtract LSB of BCDE
    3064/    466B : 5F                  	LD	E,A		; Save LSB of BCDE
    3065/    466C : 23                  	INC	HL
    3066/    466D : 7E                  	LD	A,(HL)		; Get NMSB of FPREG
    3067/    466E : 9A                  	SBC	A,D		; Subtract NMSB of BCDE
    3068/    466F : 57                  	LD	D,A		; Save NMSB of BCDE
    3069/    4670 : 23                  	INC	HL
    3070/    4671 : 7E                  	LD	A,(HL)		; Get MSB of FPREG
    3071/    4672 : 99                  	SBC	A,C		; Subtract MSB of BCDE
    3072/    4673 : 4F                  	LD	C,A		; Save MSB of BCDE
    3073/    4674 : DC D7 46            CONPOS: CALL	C,COMPL		; Overflow - Make it positive
    3074/    4677 :                     ;
    3075/    4677 : 68                  BNORM:	LD	L,B		; L = Exponent
    3076/    4678 : 63                  	LD	H,E		; H = LSB
    3077/    4679 : AF                  	XOR	A
    3078/    467A : 47                  BNRMLP: LD	B,A		; Save bit count
    3079/    467B : 79                  	LD	A,C		; Get MSB
    3080/    467C : B7                  	OR	A		; Is it zero?
    3081/    467D : C2 99 46            	JP	NZ,PNORM	; No - Do it bit at a time
    3082/    4680 : 4A                  	LD	C,D		; MSB = NMSB
    3083/    4681 : 54                  	LD	D,H		; NMSB= LSB
    3084/    4682 : 65                  	LD	H,L		; LSB = VLSB
    3085/    4683 : 6F                  	LD	L,A		; VLSB= 0
    3086/    4684 : 78                  	LD	A,B		; Get exponent
    3087/    4685 : D6 08               	SUB	8		; Count 8 bits
    3088/    4687 : FE E0               	CP	0E0H		; -24-8 Was number zero?
    3089/    4689 : C2 7A 46            	JP	NZ,BNRMLP	; No - Keep normalising
    3090/    468C : AF                  RESZER: XOR	A		; Result is zero
    3091/    468D : 32 2C 81            SAVEXP: LD	(FPEXP),A	; Save result as zero
    3092/    4690 : C9                  	RET
    3093/    4691 :                     ;
    3094/    4691 : 05                  NORMAL: DEC	B		; Count bits
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 53 - 12/29/2022 20:41:36


    3095/    4692 : 29                  	ADD	HL,HL		; Shift HL left
    3096/    4693 : 7A                  	LD	A,D		; Get NMSB
    3097/    4694 : 17                  	RLA			; Shift left with last bit
    3098/    4695 : 57                  	LD	D,A		; Save NMSB
    3099/    4696 : 79                  	LD	A,C		; Get MSB
    3100/    4697 : 8F                  	ADC	A,A		; Shift left with last bit
    3101/    4698 : 4F                  	LD	C,A		; Save MSB
    3102/    4699 : F2 91 46            PNORM:	JP	P,NORMAL	; Not done - Keep going
    3103/    469C : 78                  	LD	A,B		; Number of bits shifted
    3104/    469D : 5C                  	LD	E,H		; Save HL in EB
    3105/    469E : 45                  	LD	B,L
    3106/    469F : B7                  	OR	A		; Any shifting done?
    3107/    46A0 : CA AC 46            	JP	Z,RONDUP	; No - Round it up
    3108/    46A3 : 21 2C 81            	LD	HL,FPEXP	; Point to exponent
    3109/    46A6 : 86                  	ADD	A,(HL)		; Add shifted bits
    3110/    46A7 : 77                  	LD	(HL),A		; Re-save exponent
    3111/    46A8 : D2 8C 46            	JP	NC,RESZER	; Underflow - Result is zero
    3112/    46AB : C8                  	RET	Z		; Result is zero
    3113/    46AC : 78                  RONDUP: LD	A,B		; Get VLSB of number
    3114/    46AD : 21 2C 81            RONDB:	LD	HL,FPEXP	; Point to exponent
    3115/    46B0 : B7                  	OR	A		; Any rounding?
    3116/    46B1 : FC BE 46            	CALL	M,FPROND	; Yes - Round number up
    3117/    46B4 : 46                  	LD	B,(HL)		; B = Exponent
    3118/    46B5 : 23                  	INC	HL
    3119/    46B6 : 7E                  	LD	A,(HL)		; Get sign of result
    3120/    46B7 : E6 80               	AND	10000000B	; Only bit 7 needed
    3121/    46B9 : A9                  	XOR	C		; Set correct sign
    3122/    46BA : 4F                  	LD	C,A		; Save correct sign in number
    3123/    46BB : C3 AD 48            	JP	FPBCDE		; Move BCDE to FPREG
    3124/    46BE :                     ;
    3125/    46BE : 1C                  FPROND: INC	E		; Round LSB
    3126/    46BF : C0                  	RET	NZ		; Return if ok
    3127/    46C0 : 14                  	INC	D		; Round NMSB
    3128/    46C1 : C0                  	RET	NZ		; Return if ok
    3129/    46C2 : 0C                  	INC	C		; Round MSB
    3130/    46C3 : C0                  	RET	NZ		; Return if ok
    3131/    46C4 : 0E 80               	LD	C,80H		; Set normal value
    3132/    46C6 : 34                  	INC	(HL)		; Increment exponent
    3133/    46C7 : C0                  	RET	NZ		; Return if ok
    3134/    46C8 : C3 C9 35            	JP	OVERR		; Overflow error
    3135/    46CB :                     ;
    3136/    46CB : 7E                  PLUCDE: LD	A,(HL)		; Get LSB of FPREG
    3137/    46CC : 83                  	ADD	A,E		; Add LSB of BCDE
    3138/    46CD : 5F                  	LD	E,A		; Save LSB of BCDE
    3139/    46CE : 23                  	INC	HL
    3140/    46CF : 7E                  	LD	A,(HL)		; Get NMSB of FPREG
    3141/    46D0 : 8A                  	ADC	A,D		; Add NMSB of BCDE
    3142/    46D1 : 57                  	LD	D,A		; Save NMSB of BCDE
    3143/    46D2 : 23                  	INC	HL
    3144/    46D3 : 7E                  	LD	A,(HL)		; Get MSB of FPREG
    3145/    46D4 : 89                  	ADC	A,C		; Add MSB of BCDE
    3146/    46D5 : 4F                  	LD	C,A		; Save MSB of BCDE
    3147/    46D6 : C9                  	RET
    3148/    46D7 :                     ;
    3149/    46D7 : 21 2D 81            COMPL:	LD	HL,SGNRES	; Sign of result
    3150/    46DA : 7E                  	LD	A,(HL)		; Get sign of result
    3151/    46DB : 2F                  	CPL			; Negate it
    3152/    46DC : 77                  	LD	(HL),A		; Put it back
    3153/    46DD : AF                  	XOR	A
    3154/    46DE : 6F                  	LD	L,A		; Set L to zero
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 54 - 12/29/2022 20:41:36


    3155/    46DF : 90                  	SUB	B		; Negate exponent,set carry
    3156/    46E0 : 47                  	LD	B,A		; Re-save exponent
    3157/    46E1 : 7D                  	LD	A,L		; Load zero
    3158/    46E2 : 9B                  	SBC	A,E		; Negate LSB
    3159/    46E3 : 5F                  	LD	E,A		; Re-save LSB
    3160/    46E4 : 7D                  	LD	A,L		; Load zero
    3161/    46E5 : 9A                  	SBC	A,D		; Negate NMSB
    3162/    46E6 : 57                  	LD	D,A		; Re-save NMSB
    3163/    46E7 : 7D                  	LD	A,L		; Load zero
    3164/    46E8 : 99                  	SBC	A,C		; Negate MSB
    3165/    46E9 : 4F                  	LD	C,A		; Re-save MSB
    3166/    46EA : C9                  	RET
    3167/    46EB :                     ;
    3168/    46EB : 06 00               SCALE:	LD	B,0		; Clear underflow
    3169/    46ED : D6 08               SCALLP: SUB	8		; 8 bits (a whole byte)?
    3170/    46EF : DA FA 46            	JP	C,SHRITE	; No - Shift right A bits
    3171/    46F2 : 43                  	LD	B,E		; <- Shift
    3172/    46F3 : 5A                  	LD	E,D		; <- right
    3173/    46F4 : 51                  	LD	D,C		; <- eight
    3174/    46F5 : 0E 00               	LD	C,0		; <- bits
    3175/    46F7 : C3 ED 46            	JP	SCALLP		; More bits to shift
    3176/    46FA :                     ;
    3177/    46FA : C6 09               SHRITE: ADD	A,8+1		; Adjust count
    3178/    46FC : 6F                  	LD	L,A		; Save bits to shift
    3179/    46FD : AF                  SHRLP:	XOR	A		; Flag for all done
    3180/    46FE : 2D                  	DEC	L		; All shifting done?
    3181/    46FF : C8                  	RET	Z		; Yes - Return
    3182/    4700 : 79                  	LD	A,C		; Get MSB
    3183/    4701 : 1F                  SHRT1:	RRA			; Shift it right
    3184/    4702 : 4F                  	LD	C,A		; Re-save
    3185/    4703 : 7A                  	LD	A,D		; Get NMSB
    3186/    4704 : 1F                  	RRA			; Shift right with last bit
    3187/    4705 : 57                  	LD	D,A		; Re-save it
    3188/    4706 : 7B                  	LD	A,E		; Get LSB
    3189/    4707 : 1F                  	RRA			; Shift right with last bit
    3190/    4708 : 5F                  	LD	E,A		; Re-save it
    3191/    4709 : 78                  	LD	A,B		; Get underflow
    3192/    470A : 1F                  	RRA			; Shift right with last bit
    3193/    470B : 47                  	LD	B,A		; Re-save underflow
    3194/    470C : C3 FD 46            	JP	SHRLP		; More bits to do
    3195/    470F :                     ;
    3196/    470F : 00 00 00 81         UNITY:	DB	 000H,000H,000H,081H	; 1.00000
    3197/    4713 :                     ;
    3198/    4713 : 03                  LOGTAB: DB	3			; Table used by LOG
    3199/    4714 : AA 56 19 80         	DB	0AAH,056H,019H,080H	; 0.59898
    3200/    4718 : F1 22 76 80         	DB	0F1H,022H,076H,080H	; 0.96147
    3201/    471C : 45 AA 38 82         	DB	045H,0AAH,038H,082H	; 2.88539
    3202/    4720 :                     ;
    3203/    4720 : CD 6C 48            LOG:	CALL	TSTSGN		; Test sign of value
    3204/    4723 : B7                  	OR	A
    3205/    4724 : EA E1 3A            	JP	PE,FCERR	; ?FC Error if <= zero
    3206/    4727 : 21 2C 81            	LD	HL,FPEXP	; Point to exponent
    3207/    472A : 7E                  	LD	A,(HL)		; Get exponent
    3208/    472B : 01 35 80            	LD	BC,8035H	; BCDE = SQR(1/2)
    3209/    472E : 11 F3 04            	LD	DE,04F3H
    3210/    4731 : 90                  	SUB	B		; Scale value to be < 1
    3211/    4732 : F5                  	PUSH	AF		; Save scale factor
    3212/    4733 : 70                  	LD	(HL),B		; Save new exponent
    3213/    4734 : D5                  	PUSH	DE		; Save SQR(1/2)
    3214/    4735 : C5                  	PUSH	BC
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 55 - 12/29/2022 20:41:36


    3215/    4736 : CD 26 46            	CALL	FPADD		; Add SQR(1/2) to value
    3216/    4739 : C1                  	POP	BC		; Restore SQR(1/2)
    3217/    473A : D1                  	POP	DE
    3218/    473B : 04                  	INC	B		; Make it SQR(2)
    3219/    473C : CD C2 47            	CALL	DVBCDE		; Divide by SQR(2)
    3220/    473F : 21 0F 47            	LD	HL,UNITY	; Point to 1.
    3221/    4742 : CD 1D 46            	CALL	SUBPHL		; Subtract FPREG from 1
    3222/    4745 : 21 13 47            	LD	HL,LOGTAB	; Coefficient table
    3223/    4748 : CD B4 4B            	CALL	SUMSER		; Evaluate sum of series
    3224/    474B : 01 80 80            	LD	BC,8080H	; BCDE = -0.5
    3225/    474E : 11 00 00            	LD	DE,0000H
    3226/    4751 : CD 26 46            	CALL	FPADD		; Subtract 0.5 from FPREG
    3227/    4754 : F1                  	POP	AF		; Restore scale factor
    3228/    4755 : CD E7 49            	CALL	RSCALE		; Re-scale number
    3229/    4758 : 01 31 80            MULLN2: LD	BC,8031H	; BCDE = Ln(2)
    3230/    475B : 11 18 72            	LD	DE,7218H
    3231/    475E : 21                  	DB	21H		; Skip "POP BC" and "POP DE"
    3232/    475F :                     ;
    3233/    475F : C1                  MULT:	POP	BC		; Get number from stack
    3234/    4760 : D1                  	POP	DE
    3235/    4761 : CD 6C 48            FPMULT: CALL	TSTSGN		; Test sign of FPREG
    3236/    4764 : C8                  	RET	Z		; Return zero if zero
    3237/    4765 : 2E 00               	LD	L,0		; Flag add exponents
    3238/    4767 : CD 2A 48            	CALL	ADDEXP		; Add exponents
    3239/    476A : 79                  	LD	A,C		; Get MSB of multiplier
    3240/    476B : 32 3B 81            	LD	(MULVAL),A	; Save MSB of multiplier
    3241/    476E : EB                  	EX	DE,HL
    3242/    476F : 22 3C 81            	LD	(MULVAL+1),HL	; Save rest of multiplier
    3243/    4772 : 01 00 00            	LD	BC,0		; Partial product (BCDE) = zero
    3244/    4775 : 50                  	LD	D,B
    3245/    4776 : 58                  	LD	E,B
    3246/    4777 : 21 77 46            	LD	HL,BNORM	; Address of normalise
    3247/    477A : E5                  	PUSH	HL		; Save for return
    3248/    477B : 21 83 47            	LD	HL,MULT8	; Address of 8 bit multiply
    3249/    477E : E5                  	PUSH	HL		; Save for NMSB,MSB
    3250/    477F : E5                  	PUSH	HL		; 
    3251/    4780 : 21 29 81            	LD	HL,FPREG	; Point to number
    3252/    4783 : 7E                  MULT8:	LD	A,(HL)		; Get LSB of number
    3253/    4784 : 23                  	INC	HL		; Point to NMSB
    3254/    4785 : B7                  	OR	A		; Test LSB
    3255/    4786 : CA AF 47            	JP	Z,BYTSFT	; Zero - shift to next byte
    3256/    4789 : E5                  	PUSH	HL		; Save address of number
    3257/    478A : 2E 08               	LD	L,8		; 8 bits to multiply by
    3258/    478C : 1F                  MUL8LP: RRA			; Shift LSB right
    3259/    478D : 67                  	LD	H,A		; Save LSB
    3260/    478E : 79                  	LD	A,C		; Get MSB
    3261/    478F : D2 9D 47            	JP	NC,NOMADD	; Bit was zero - Don't add
    3262/    4792 : E5                  	PUSH	HL		; Save LSB and count
    3263/    4793 : 2A 3C 81            	LD	HL,(MULVAL+1)	; Get LSB and NMSB
    3264/    4796 : 19                  	ADD	HL,DE		; Add NMSB and LSB
    3265/    4797 : EB                  	EX	DE,HL		; Leave sum in DE
    3266/    4798 : E1                  	POP	HL		; Restore MSB and count
    3267/    4799 : 3A 3B 81            	LD	A,(MULVAL)	; Get MSB of multiplier
    3268/    479C : 89                  	ADC	A,C		; Add MSB
    3269/    479D : 1F                  NOMADD: RRA			; Shift MSB right
    3270/    479E : 4F                  	LD	C,A		; Re-save MSB
    3271/    479F : 7A                  	LD	A,D		; Get NMSB
    3272/    47A0 : 1F                  	RRA			; Shift NMSB right
    3273/    47A1 : 57                  	LD	D,A		; Re-save NMSB
    3274/    47A2 : 7B                  	LD	A,E		; Get LSB
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 56 - 12/29/2022 20:41:36


    3275/    47A3 : 1F                  	RRA			; Shift LSB right
    3276/    47A4 : 5F                  	LD	E,A		; Re-save LSB
    3277/    47A5 : 78                  	LD	A,B		; Get VLSB
    3278/    47A6 : 1F                  	RRA			; Shift VLSB right
    3279/    47A7 : 47                  	LD	B,A		; Re-save VLSB
    3280/    47A8 : 2D                  	DEC	L		; Count bits multiplied
    3281/    47A9 : 7C                  	LD	A,H		; Get LSB of multiplier
    3282/    47AA : C2 8C 47            	JP	NZ,MUL8LP	; More - Do it
    3283/    47AD : E1                  POPHRT: POP	HL		; Restore address of number
    3284/    47AE : C9                  	RET
    3285/    47AF :                     ;
    3286/    47AF : 43                  BYTSFT: LD	B,E		; Shift partial product left
    3287/    47B0 : 5A                  	LD	E,D
    3288/    47B1 : 51                  	LD	D,C
    3289/    47B2 : 4F                  	LD	C,A
    3290/    47B3 : C9                  	RET
    3291/    47B4 :                     ;
    3292/    47B4 : CD 9D 48            DIV10:	CALL	STAKFP		; Save FPREG on stack
    3293/    47B7 : 01 20 84            	LD	BC,8420H	; BCDE = 10.
    3294/    47BA : 11 00 00            	LD	DE,0000H
    3295/    47BD : CD AD 48            	CALL	FPBCDE		; Move 10 to FPREG
    3296/    47C0 :                     ;
    3297/    47C0 : C1                  DIV:	POP	BC		; Get number from stack
    3298/    47C1 : D1                  	POP	DE
    3299/    47C2 : CD 6C 48            DVBCDE: CALL	TSTSGN		; Test sign of FPREG
    3300/    47C5 : CA BD 35            	JP	Z,DZERR		; Error if division by zero
    3301/    47C8 : 2E FF               	LD	L,-1		; Flag subtract exponents
    3302/    47CA : CD 2A 48            	CALL	ADDEXP		; Subtract exponents
    3303/    47CD : 34                  	INC	(HL)		; Add 2 to exponent to adjust
    3304/    47CE : 34                  	INC	(HL)
    3305/    47CF : 2B                  	DEC	HL		; Point to MSB
    3306/    47D0 : 7E                  	LD	A,(HL)		; Get MSB of dividend
    3307/    47D1 : 32 57 80            	LD	(DIV3),A	; Save for subtraction
    3308/    47D4 : 2B                  	DEC	HL
    3309/    47D5 : 7E                  	LD	A,(HL)		; Get NMSB of dividend
    3310/    47D6 : 32 53 80            	LD	(DIV2),A	; Save for subtraction
    3311/    47D9 : 2B                  	DEC	HL
    3312/    47DA : 7E                  	LD	A,(HL)		; Get MSB of dividend
    3313/    47DB : 32 4F 80            	LD	(DIV1),A	; Save for subtraction
    3314/    47DE : 41                  	LD	B,C		; Get MSB
    3315/    47DF : EB                  	EX	DE,HL		; NMSB,LSB to HL
    3316/    47E0 : AF                  	XOR	A
    3317/    47E1 : 4F                  	LD	C,A		; Clear MSB of quotient
    3318/    47E2 : 57                  	LD	D,A		; Clear NMSB of quotient
    3319/    47E3 : 5F                  	LD	E,A		; Clear LSB of quotient
    3320/    47E4 : 32 5A 80            	LD	(DIV4),A	; Clear overflow count
    3321/    47E7 : E5                  DIVLP:	PUSH	HL		; Save divisor
    3322/    47E8 : C5                  	PUSH	BC
    3323/    47E9 : 7D                  	LD	A,L		; Get LSB of number
    3324/    47EA : CD 4E 80            	CALL	DIVSUP		; Subt' divisor from dividend
    3325/    47ED : DE 00               	SBC	A,0		; Count for overflows
    3326/    47EF : 3F                  	CCF
    3327/    47F0 : D2 FA 47            	JP	NC,RESDIV	; Restore divisor if borrow
    3328/    47F3 : 32 5A 80            	LD	(DIV4),A	; Re-save overflow count
    3329/    47F6 : F1                  	POP	AF		; Scrap divisor
    3330/    47F7 : F1                  	POP	AF
    3331/    47F8 : 37                  	SCF			; Set carry to
    3332/    47F9 : D2                  	DB	0D2H		; Skip "POP BC" and "POP HL"
    3333/    47FA :                     ;
    3334/    47FA : C1                  RESDIV: POP	BC		; Restore divisor
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 57 - 12/29/2022 20:41:36


    3335/    47FB : E1                  	POP	HL
    3336/    47FC : 79                  	LD	A,C		; Get MSB of quotient
    3337/    47FD : 3C                  	INC	A
    3338/    47FE : 3D                  	DEC	A
    3339/    47FF : 1F                  	RRA			; Bit 0 to bit 7
    3340/    4800 : FA AD 46            	JP	M,RONDB		; Done - Normalise result
    3341/    4803 : 17                  	RLA			; Restore carry
    3342/    4804 : 7B                  	LD	A,E		; Get LSB of quotient
    3343/    4805 : 17                  	RLA			; Double it
    3344/    4806 : 5F                  	LD	E,A		; Put it back
    3345/    4807 : 7A                  	LD	A,D		; Get NMSB of quotient
    3346/    4808 : 17                  	RLA			; Double it
    3347/    4809 : 57                  	LD	D,A		; Put it back
    3348/    480A : 79                  	LD	A,C		; Get MSB of quotient
    3349/    480B : 17                  	RLA			; Double it
    3350/    480C : 4F                  	LD	C,A		; Put it back
    3351/    480D : 29                  	ADD	HL,HL		; Double NMSB,LSB of divisor
    3352/    480E : 78                  	LD	A,B		; Get MSB of divisor
    3353/    480F : 17                  	RLA			; Double it
    3354/    4810 : 47                  	LD	B,A		; Put it back
    3355/    4811 : 3A 5A 80            	LD	A,(DIV4)	; Get VLSB of quotient
    3356/    4814 : 17                  	RLA			; Double it
    3357/    4815 : 32 5A 80            	LD	(DIV4),A	; Put it back
    3358/    4818 : 79                  	LD	A,C		; Get MSB of quotient
    3359/    4819 : B2                  	OR	D		; Merge NMSB
    3360/    481A : B3                  	OR	E		; Merge LSB
    3361/    481B : C2 E7 47            	JP	NZ,DIVLP	; Not done - Keep dividing
    3362/    481E : E5                  	PUSH	HL		; Save divisor
    3363/    481F : 21 2C 81            	LD	HL,FPEXP	; Point to exponent
    3364/    4822 : 35                  	DEC	(HL)		; Divide by 2
    3365/    4823 : E1                  	POP	HL		; Restore divisor
    3366/    4824 : C2 E7 47            	JP	NZ,DIVLP	; Ok - Keep going
    3367/    4827 : C3 C9 35            	JP	OVERR		; Overflow error
    3368/    482A :                     ;
    3369/    482A : 78                  ADDEXP: LD	A,B		; Get exponent of dividend
    3370/    482B : B7                  	OR	A		; Test it
    3371/    482C : CA 4E 48            	JP	Z,OVTST3	; Zero - Result zero
    3372/    482F : 7D                  	LD	A,L		; Get add/subtract flag
    3373/    4830 : 21 2C 81            	LD	HL,FPEXP	; Point to exponent
    3374/    4833 : AE                  	XOR	(HL)		; Add or subtract it
    3375/    4834 : 80                  	ADD	A,B		; Add the other exponent
    3376/    4835 : 47                  	LD	B,A		; Save new exponent
    3377/    4836 : 1F                  	RRA			; Test exponent for overflow
    3378/    4837 : A8                  	XOR	B
    3379/    4838 : 78                  	LD	A,B		; Get exponent
    3380/    4839 : F2 4D 48            	JP	P,OVTST2	; Positive - Test for overflow
    3381/    483C : C6 80               	ADD	A,80H		; Add excess 128
    3382/    483E : 77                  	LD	(HL),A		; Save new exponent
    3383/    483F : CA AD 47            	JP	Z,POPHRT	; Zero - Result zero
    3384/    4842 : CD D2 48            	CALL	SIGNS		; Set MSBs and sign of result
    3385/    4845 : 77                  	LD	(HL),A		; Save new exponent
    3386/    4846 : 2B                  	DEC	HL		; Point to MSB
    3387/    4847 : C9                  	RET
    3388/    4848 :                     ;
    3389/    4848 : CD 6C 48            OVTST1: CALL	TSTSGN		; Test sign of FPREG
    3390/    484B : 2F                  	CPL			; Invert sign
    3391/    484C : E1                  	POP	HL		; Clean up stack
    3392/    484D : B7                  OVTST2: OR	A		; Test if new exponent zero
    3393/    484E : E1                  OVTST3: POP	HL		; Clear off return address
    3394/    484F : F2 8C 46            	JP	P,RESZER	; Result zero
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 58 - 12/29/2022 20:41:36


    3395/    4852 : C3 C9 35            	JP	OVERR		; Overflow error
    3396/    4855 :                     ;
    3397/    4855 : CD B8 48            MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
    3398/    4858 : 78                  	LD	A,B		; Get exponent
    3399/    4859 : B7                  	OR	A		; Is it zero?
    3400/    485A : C8                  	RET	Z		; Yes - Result is zero
    3401/    485B : C6 02               	ADD	A,2		; Multiply by 4
    3402/    485D : DA C9 35            	JP	C,OVERR		; Overflow - ?OV Error
    3403/    4860 : 47                  	LD	B,A		; Re-save exponent
    3404/    4861 : CD 26 46            	CALL	FPADD		; Add BCDE to FPREG (Times 5)
    3405/    4864 : 21 2C 81            	LD	HL,FPEXP	; Point to exponent
    3406/    4867 : 34                  	INC	(HL)		; Double number (Times 10)
    3407/    4868 : C0                  	RET	NZ		; Ok - Return
    3408/    4869 : C3 C9 35            	JP	OVERR		; Overflow error
    3409/    486C :                     ;
    3410/    486C : 3A 2C 81            TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
    3411/    486F : B7                  	OR	A
    3412/    4870 : C8                  	RET	Z		; RETurn if number is zero
    3413/    4871 : 3A 2B 81            	LD	A,(FPREG+2)	; Get MSB of FPREG
    3414/    4874 : FE                  	DB	0FEH		; Test sign
    3415/    4875 : 2F                  RETREL: CPL			; Invert sign
    3416/    4876 : 17                  	RLA			; Sign bit to carry
    3417/    4877 : 9F                  FLGDIF: SBC	A,A		; Carry to all bits of A
    3418/    4878 : C0                  	RET	NZ		; Return -1 if negative
    3419/    4879 : 3C                  	INC	A		; Bump to +1
    3420/    487A : C9                  	RET			; Positive - Return +1
    3421/    487B :                     ;
    3422/    487B : CD 6C 48            SGN:	CALL	TSTSGN		; Test sign of FPREG
    3423/    487E : 06 88               FLGREL: LD	B,80H+8		; 8 bit integer in exponent
    3424/    4880 : 11 00 00            	LD	DE,0		; Zero NMSB and LSB
    3425/    4883 : 21 2C 81            RETINT: LD	HL,FPEXP	; Point to exponent
    3426/    4886 : 4F                  	LD	C,A		; CDE = MSB,NMSB and LSB
    3427/    4887 : 70                  	LD	(HL),B		; Save exponent
    3428/    4888 : 06 00               	LD	B,0		; CDE = integer to normalise
    3429/    488A : 23                  	INC	HL		; Point to sign of result
    3430/    488B : 36 80               	LD	(HL),80H	; Set sign of result
    3431/    488D : 17                  	RLA			; Carry = sign of integer
    3432/    488E : C3 74 46            	JP	CONPOS		; Set sign of result
    3433/    4891 :                     ;
    3434/    4891 : CD 6C 48            ABS:	CALL	TSTSGN		; Test sign of FPREG
    3435/    4894 : F0                  	RET	P		; Return if positive
    3436/    4895 : 21 2B 81            INVSGN: LD	HL,FPREG+2	; Point to MSB
    3437/    4898 : 7E                  	LD	A,(HL)		; Get sign of mantissa
    3438/    4899 : EE 80               	XOR	80H		; Invert sign of mantissa
    3439/    489B : 77                  	LD	(HL),A		; Re-save sign of mantissa
    3440/    489C : C9                  	RET
    3441/    489D :                     ;
    3442/    489D : EB                  STAKFP: EX	DE,HL		; Save code string address
    3443/    489E : 2A 29 81            	LD	HL,(FPREG)	; LSB,NLSB of FPREG
    3444/    48A1 : E3                  	EX	(SP),HL		; Stack them,get return
    3445/    48A2 : E5                  	PUSH	HL		; Re-save return
    3446/    48A3 : 2A 2B 81            	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
    3447/    48A6 : E3                  	EX	(SP),HL		; Stack them,get return
    3448/    48A7 : E5                  	PUSH	HL		; Re-save return
    3449/    48A8 : EB                  	EX	DE,HL		; Restore code string address
    3450/    48A9 : C9                  	RET
    3451/    48AA :                     ;
    3452/    48AA : CD BB 48            PHLTFP: CALL	LOADFP		; Number at HL to BCDE
    3453/    48AD : EB                  FPBCDE: EX	DE,HL		; Save code string address
    3454/    48AE : 22 29 81            	LD	(FPREG),HL	; Save LSB,NLSB of number
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 59 - 12/29/2022 20:41:36


    3455/    48B1 : 60                  	LD	H,B		; Exponent of number
    3456/    48B2 : 69                  	LD	L,C		; MSB of number
    3457/    48B3 : 22 2B 81            	LD	(FPREG+2),HL	; Save MSB and exponent
    3458/    48B6 : EB                  	EX	DE,HL		; Restore code string address
    3459/    48B7 : C9                  	RET
    3460/    48B8 :                     ;
    3461/    48B8 : 21 29 81            BCDEFP: LD	HL,FPREG	; Point to FPREG
    3462/    48BB : 5E                  LOADFP: LD	E,(HL)		; Get LSB of number
    3463/    48BC : 23                  	INC	HL
    3464/    48BD : 56                  	LD	D,(HL)		; Get NMSB of number
    3465/    48BE : 23                  	INC	HL
    3466/    48BF : 4E                  	LD	C,(HL)		; Get MSB of number
    3467/    48C0 : 23                  	INC	HL
    3468/    48C1 : 46                  	LD	B,(HL)		; Get exponent of number
    3469/    48C2 : 23                  INCHL:	INC	HL		; Used for conditional "INC HL"
    3470/    48C3 : C9                  	RET
    3471/    48C4 :                     ;
    3472/    48C4 : 11 29 81            FPTHL:	LD	DE,FPREG	; Point to FPREG
    3473/    48C7 : 06 04               DETHL4: LD	B,4		; 4 bytes to move
    3474/    48C9 : 1A                  DETHLB: LD	A,(DE)		; Get source
    3475/    48CA : 77                  	LD	(HL),A		; Save destination
    3476/    48CB : 13                  	INC	DE		; Next source
    3477/    48CC : 23                  	INC	HL		; Next destination
    3478/    48CD : 05                  	DEC	B		; Count bytes
    3479/    48CE : C2 C9 48            	JP	NZ,DETHLB	; Loop if more
    3480/    48D1 : C9                  	RET
    3481/    48D2 :                     ;
    3482/    48D2 : 21 2B 81            SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
    3483/    48D5 : 7E                  	LD	A,(HL)		; Get MSB
    3484/    48D6 : 07                  	RLCA			; Old sign to carry
    3485/    48D7 : 37                  	SCF			; Set MSBit
    3486/    48D8 : 1F                  	RRA			; Set MSBit of MSB
    3487/    48D9 : 77                  	LD	(HL),A		; Save new MSB
    3488/    48DA : 3F                  	CCF			; Complement sign
    3489/    48DB : 1F                  	RRA			; Old sign to carry
    3490/    48DC : 23                  	INC	HL
    3491/    48DD : 23                  	INC	HL
    3492/    48DE : 77                  	LD	(HL),A		; Set sign of result
    3493/    48DF : 79                  	LD	A,C		; Get MSB
    3494/    48E0 : 07                  	RLCA			; Old sign to carry
    3495/    48E1 : 37                  	SCF			; Set MSBit
    3496/    48E2 : 1F                  	RRA			; Set MSBit of MSB
    3497/    48E3 : 4F                  	LD	C,A		; Save MSB
    3498/    48E4 : 1F                  	RRA
    3499/    48E5 : AE                  	XOR	(HL)		; New sign of result
    3500/    48E6 : C9                  	RET
    3501/    48E7 :                     ;
    3502/    48E7 : 78                  CMPNUM: LD	A,B		; Get exponent of number
    3503/    48E8 : B7                  	OR	A
    3504/    48E9 : CA 6C 48            	JP	Z,TSTSGN	; Zero - Test sign of FPREG
    3505/    48EC : 21 75 48            	LD	HL,RETREL	; Return relation routine
    3506/    48EF : E5                  	PUSH	HL		; Save for return
    3507/    48F0 : CD 6C 48            	CALL	TSTSGN		; Test sign of FPREG
    3508/    48F3 : 79                  	LD	A,C		; Get MSB of number
    3509/    48F4 : C8                  	RET	Z		; FPREG zero - Number's MSB
    3510/    48F5 : 21 2B 81            	LD	HL,FPREG+2	; MSB of FPREG
    3511/    48F8 : AE                  	XOR	(HL)		; Combine signs
    3512/    48F9 : 79                  	LD	A,C		; Get MSB of number
    3513/    48FA : F8                  	RET	M		; Exit if signs different
    3514/    48FB : CD 01 49            	CALL	CMPFP		; Compare FP numbers
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 60 - 12/29/2022 20:41:36


    3515/    48FE : 1F                  	RRA			; Get carry to sign
    3516/    48FF : A9                  	XOR	C		; Combine with MSB of number
    3517/    4900 : C9                  	RET
    3518/    4901 :                     ;
    3519/    4901 : 23                  CMPFP:	INC	HL		; Point to exponent
    3520/    4902 : 78                  	LD	A,B		; Get exponent
    3521/    4903 : BE                  	CP	(HL)		; Compare exponents
    3522/    4904 : C0                  	RET	NZ		; Different
    3523/    4905 : 2B                  	DEC	HL		; Point to MBS
    3524/    4906 : 79                  	LD	A,C		; Get MSB
    3525/    4907 : BE                  	CP	(HL)		; Compare MSBs
    3526/    4908 : C0                  	RET	NZ		; Different
    3527/    4909 : 2B                  	DEC	HL		; Point to NMSB
    3528/    490A : 7A                  	LD	A,D		; Get NMSB
    3529/    490B : BE                  	CP	(HL)		; Compare NMSBs
    3530/    490C : C0                  	RET	NZ		; Different
    3531/    490D : 2B                  	DEC	HL		; Point to LSB
    3532/    490E : 7B                  	LD	A,E		; Get LSB
    3533/    490F : 96                  	SUB	(HL)		; Compare LSBs
    3534/    4910 : C0                  	RET	NZ		; Different
    3535/    4911 : E1                  	POP	HL		; Drop RETurn
    3536/    4912 : E1                  	POP	HL		; Drop another RETurn
    3537/    4913 : C9                  	RET
    3538/    4914 :                     ;
    3539/    4914 : 47                  FPINT:	LD	B,A		; <- Move
    3540/    4915 : 4F                  	LD	C,A		; <- exponent
    3541/    4916 : 57                  	LD	D,A		; <- to all
    3542/    4917 : 5F                  	LD	E,A		; <- bits
    3543/    4918 : B7                  	OR	A		; Test exponent
    3544/    4919 : C8                  	RET	Z		; Zero - Return zero
    3545/    491A : E5                  	PUSH	HL		; Save pointer to number
    3546/    491B : CD B8 48            	CALL	BCDEFP		; Move FPREG to BCDE
    3547/    491E : CD D2 48            	CALL	SIGNS		; Set MSBs & sign of result
    3548/    4921 : AE                  	XOR	(HL)		; Combine with sign of FPREG
    3549/    4922 : 67                  	LD	H,A		; Save combined signs
    3550/    4923 : FC 38 49            	CALL	M,DCBCDE	; Negative - Decrement BCDE
    3551/    4926 : 3E 98               	LD	A,80H+24	; 24 bits
    3552/    4928 : 90                  	SUB	B		; Bits to shift
    3553/    4929 : CD EB 46            	CALL	SCALE		; Shift BCDE
    3554/    492C : 7C                  	LD	A,H		; Get combined sign
    3555/    492D : 17                  	RLA			; Sign to carry
    3556/    492E : DC BE 46            	CALL	C,FPROND	; Negative - Round number up
    3557/    4931 : 06 00               	LD	B,0		; Zero exponent
    3558/    4933 : DC D7 46            	CALL	C,COMPL		; If negative make positive
    3559/    4936 : E1                  	POP	HL		; Restore pointer to number
    3560/    4937 : C9                  	RET
    3561/    4938 :                     ;
    3562/    4938 : 1B                  DCBCDE: DEC	DE		; Decrement BCDE
    3563/    4939 : 7A                  	LD	A,D		; Test LSBs
    3564/    493A : A3                  	AND	E
    3565/    493B : 3C                  	INC	A
    3566/    493C : C0                  	RET	NZ		; Exit if LSBs not FFFF
    3567/    493D : 0B                  	DEC	BC		; Decrement MSBs
    3568/    493E : C9                  	RET
    3569/    493F :                     ;
    3570/    493F : 21 2C 81            INT:	LD	HL,FPEXP	; Point to exponent
    3571/    4942 : 7E                  	LD	A,(HL)		; Get exponent
    3572/    4943 : FE 98               	CP	80H+24		; Integer accuracy only?
    3573/    4945 : 3A 29 81            	LD	A,(FPREG)	; Get LSB
    3574/    4948 : D0                  	RET	NC		; Yes - Already integer
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 61 - 12/29/2022 20:41:36


    3575/    4949 : 7E                  	LD	A,(HL)		; Get exponent
    3576/    494A : CD 14 49            	CALL	FPINT		; F.P to integer
    3577/    494D : 36 98               	LD	(HL),80H+24	; Save 24 bit integer
    3578/    494F : 7B                  	LD	A,E		; Get LSB of number
    3579/    4950 : F5                  	PUSH	AF		; Save LSB
    3580/    4951 : 79                  	LD	A,C		; Get MSB of number
    3581/    4952 : 17                  	RLA			; Sign to carry
    3582/    4953 : CD 74 46            	CALL	CONPOS		; Set sign of result
    3583/    4956 : F1                  	POP	AF		; Restore LSB of number
    3584/    4957 : C9                  	RET
    3585/    4958 :                     ;
    3586/    4958 : 21 00 00            MLDEBC: LD	HL,0		; Clear partial product
    3587/    495B : 78                  	LD	A,B		; Test multiplier
    3588/    495C : B1                  	OR	C
    3589/    495D : C8                  	RET	Z		; Return zero if zero
    3590/    495E : 3E 10               	LD	A,16		; 16 bits
    3591/    4960 : 29                  MLDBLP: ADD	HL,HL		; Shift P.P left
    3592/    4961 : DA 96 41            	JP	C,BSERR		; ?BS Error if overflow
    3593/    4964 : EB                  	EX	DE,HL
    3594/    4965 : 29                  	ADD	HL,HL		; Shift multiplier left
    3595/    4966 : EB                  	EX	DE,HL
    3596/    4967 : D2 6E 49            	JP	NC,NOMLAD	; Bit was zero - No add
    3597/    496A : 09                  	ADD	HL,BC		; Add multiplicand
    3598/    496B : DA 96 41            	JP	C,BSERR		; ?BS Error if overflow
    3599/    496E : 3D                  NOMLAD: DEC	A		; Count bits
    3600/    496F : C2 60 49            	JP	NZ,MLDBLP	; More
    3601/    4972 : C9                  	RET
    3602/    4973 :                     ;
    3603/    4973 : FE 2D               ASCTFP: CP	'-'		; Negative?
    3604/    4975 : F5                  	PUSH	AF		; Save it and flags
    3605/    4976 : CA 7F 49            	JP	Z,CNVNUM	; Yes - Convert number
    3606/    4979 : FE 2B               	CP	'+'		; Positive?
    3607/    497B : CA 7F 49            	JP	Z,CNVNUM	; Yes - Convert number
    3608/    497E : 2B                  	DEC	HL		; DEC 'cos GETCHR INCs
    3609/    497F : CD 8C 46            CNVNUM: CALL	RESZER		; Set result to zero
    3610/    4982 : 47                  	LD	B,A		; Digits after point counter
    3611/    4983 : 57                  	LD	D,A		; Sign of exponent
    3612/    4984 : 5F                  	LD	E,A		; Exponent of ten
    3613/    4985 : 2F                  	CPL
    3614/    4986 : 4F                  	LD	C,A		; Before or after point flag
    3615/    4987 : CD 16 3A            MANLP:	CALL	GETCHR		; Get next character
    3616/    498A : DA D0 49            	JP	C,ADDIG		; Digit - Add to number
    3617/    498D : FE 2E               	CP	'.'
    3618/    498F : CA AB 49            	JP	Z,DPOINT	; '.' - Flag point
    3619/    4992 : FE 45               	CP	'E'
    3620/    4994 : C2 AF 49            	JP	NZ,CONEXP	; Not 'E' - Scale number
    3621/    4997 : CD 16 3A            	CALL	GETCHR		; Get next character
    3622/    499A : CD C1 3F            	CALL	SGNEXP		; Get sign of exponent
    3623/    499D : CD 16 3A            EXPLP:	CALL	GETCHR		; Get next character
    3624/    49A0 : DA F2 49            	JP	C,EDIGIT	; Digit - Add to exponent
    3625/    49A3 : 14                  	INC	D		; Is sign negative?
    3626/    49A4 : C2 AF 49            	JP	NZ,CONEXP	; No - Scale number
    3627/    49A7 : AF                  	XOR	A
    3628/    49A8 : 93                  	SUB	E		; Negate exponent
    3629/    49A9 : 5F                  	LD	E,A		; And re-save it
    3630/    49AA : 0C                  	INC	C		; Flag end of number
    3631/    49AB : 0C                  DPOINT: INC	C		; Flag point passed
    3632/    49AC : CA 87 49            	JP	Z,MANLP		; Zero - Get another digit
    3633/    49AF : E5                  CONEXP: PUSH	HL		; Save code string address
    3634/    49B0 : 7B                  	LD	A,E		; Get exponent
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 62 - 12/29/2022 20:41:36


    3635/    49B1 : 90                  	SUB	B		; Subtract digits after point
    3636/    49B2 : F4 C8 49            SCALMI: CALL	P,SCALPL	; Positive - Multiply number
    3637/    49B5 : F2 BE 49            	JP	P,ENDCON	; Positive - All done
    3638/    49B8 : F5                  	PUSH	AF		; Save number of times to /10
    3639/    49B9 : CD B4 47            	CALL	DIV10		; Divide by 10
    3640/    49BC : F1                  	POP	AF		; Restore count
    3641/    49BD : 3C                  	INC	A		; Count divides
    3642/    49BE :                     ;
    3643/    49BE : C2 B2 49            ENDCON: JP	NZ,SCALMI	; More to do
    3644/    49C1 : D1                  	POP	DE		; Restore code string address
    3645/    49C2 : F1                  	POP	AF		; Restore sign of number
    3646/    49C3 : CC 95 48            	CALL	Z,INVSGN	; Negative - Negate number
    3647/    49C6 : EB                  	EX	DE,HL		; Code string address to HL
    3648/    49C7 : C9                  	RET
    3649/    49C8 :                     ;
    3650/    49C8 : C8                  SCALPL: RET	Z		; Exit if no scaling needed
    3651/    49C9 : F5                  MULTEN: PUSH	AF		; Save count
    3652/    49CA : CD 55 48            	CALL	MLSP10		; Multiply number by 10
    3653/    49CD : F1                  	POP	AF		; Restore count
    3654/    49CE : 3D                  	DEC	A		; Count multiplies
    3655/    49CF : C9                  	RET
    3656/    49D0 :                     ;
    3657/    49D0 : D5                  ADDIG:	PUSH	DE		; Save sign of exponent
    3658/    49D1 : 57                  	LD	D,A		; Save digit
    3659/    49D2 : 78                  	LD	A,B		; Get digits after point
    3660/    49D3 : 89                  	ADC	A,C		; Add one if after point
    3661/    49D4 : 47                  	LD	B,A		; Re-save counter
    3662/    49D5 : C5                  	PUSH	BC		; Save point flags
    3663/    49D6 : E5                  	PUSH	HL		; Save code string address
    3664/    49D7 : D5                  	PUSH	DE		; Save digit
    3665/    49D8 : CD 55 48            	CALL	MLSP10		; Multiply number by 10
    3666/    49DB : F1                  	POP	AF		; Restore digit
    3667/    49DC : D6 30               	SUB	'0'		; Make it absolute
    3668/    49DE : CD E7 49            	CALL	RSCALE		; Re-scale number
    3669/    49E1 : E1                  	POP	HL		; Restore code string address
    3670/    49E2 : C1                  	POP	BC		; Restore point flags
    3671/    49E3 : D1                  	POP	DE		; Restore sign of exponent
    3672/    49E4 : C3 87 49            	JP	MANLP		; Get another digit
    3673/    49E7 :                     ;
    3674/    49E7 : CD 9D 48            RSCALE: CALL	STAKFP		; Put number on stack
    3675/    49EA : CD 7E 48            	CALL	FLGREL		; Digit to add to FPREG
    3676/    49ED : C1                  PADD:	POP	BC		; Restore number
    3677/    49EE : D1                  	POP	DE
    3678/    49EF : C3 26 46            	JP	FPADD		; Add BCDE to FPREG and return
    3679/    49F2 :                     ;
    3680/    49F2 : 7B                  EDIGIT: LD	A,E		; Get digit
    3681/    49F3 : 07                  	RLCA			; Times 2
    3682/    49F4 : 07                  	RLCA			; Times 4
    3683/    49F5 : 83                  	ADD	A,E		; Times 5
    3684/    49F6 : 07                  	RLCA			; Times 10
    3685/    49F7 : 86                  	ADD	A,(HL)		; Add next digit
    3686/    49F8 : D6 30               	SUB	'0'		; Make it absolute
    3687/    49FA : 5F                  	LD	E,A		; Save new digit
    3688/    49FB : C3 9D 49            	JP	EXPLP		; Look for another digit
    3689/    49FE :                     ;
    3690/    49FE : E5                  LINEIN: PUSH	HL		; Save code string address
    3691/    49FF : 21 52 35            	LD	HL,INMSG	; Output " in "
    3692/    4A02 : CD 61 43            	CALL	PRS		; Output string at HL
    3693/    4A05 : E1                  	POP	HL		; Restore code string address
    3694/    4A06 : EB                  PRNTHL: EX	DE,HL		; Code string address to DE
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 63 - 12/29/2022 20:41:36


    3695/    4A07 : AF                  	XOR	A
    3696/    4A08 : 06 98               	LD	B,80H+24	; 24 bits
    3697/    4A0A : CD 83 48            	CALL	RETINT		; Return the integer
    3698/    4A0D : 21 60 43            	LD	HL,PRNUMS	; Print number string
    3699/    4A10 : E5                  	PUSH	HL		; Save for return
    3700/    4A11 : 21 2E 81            NUMASC: LD	HL,PBUFF	; Convert number to ASCII
    3701/    4A14 : E5                  	PUSH	HL		; Save for return
    3702/    4A15 : CD 6C 48            	CALL	TSTSGN		; Test sign of FPREG
    3703/    4A18 : 36 20               	LD	(HL),' '	; Space at start
    3704/    4A1A : F2 1F 4A            	JP	P,SPCFST	; Positive - Space to start
    3705/    4A1D : 36 2D               	LD	(HL),'-'	; '-' sign at start
    3706/    4A1F : 23                  SPCFST: INC	HL		; First byte of number
    3707/    4A20 : 36 30               	LD	(HL),'0'	; '0' if zero
    3708/    4A22 : CA D5 4A            	JP	Z,JSTZER	; Return '0' if zero
    3709/    4A25 : E5                  	PUSH	HL		; Save buffer address
    3710/    4A26 : FC 95 48            	CALL	M,INVSGN	; Negate FPREG if negative
    3711/    4A29 : AF                  	XOR	A		; Zero A
    3712/    4A2A : F5                  	PUSH	AF		; Save it
    3713/    4A2B : CD DB 4A            	CALL	RNGTST		; Test number is in range
    3714/    4A2E : 01 43 91            SIXDIG: LD	BC,9143H	; BCDE - 99999.9
    3715/    4A31 : 11 F8 4F            	LD	DE,4FF8H
    3716/    4A34 : CD E7 48            	CALL	CMPNUM		; Compare numbers
    3717/    4A37 : B7                  	OR	A
    3718/    4A38 : E2 4C 4A            	JP	PO,INRNG	; > 99999.9 - Sort it out
    3719/    4A3B : F1                  	POP	AF		; Restore count
    3720/    4A3C : CD C9 49            	CALL	MULTEN		; Multiply by ten
    3721/    4A3F : F5                  	PUSH	AF		; Re-save count
    3722/    4A40 : C3 2E 4A            	JP	SIXDIG		; Test it again
    3723/    4A43 :                     ;
    3724/    4A43 : CD B4 47            GTSIXD: CALL	DIV10		; Divide by 10
    3725/    4A46 : F1                  	POP	AF		; Get count
    3726/    4A47 : 3C                  	INC	A		; Count divides
    3727/    4A48 : F5                  	PUSH	AF		; Re-save count
    3728/    4A49 : CD DB 4A            	CALL	RNGTST		; Test number is in range
    3729/    4A4C : CD 14 46            INRNG:	CALL	ROUND		; Add 0.5 to FPREG
    3730/    4A4F : 3C                  	INC	A
    3731/    4A50 : CD 14 49            	CALL	FPINT		; F.P to integer
    3732/    4A53 : CD AD 48            	CALL	FPBCDE		; Move BCDE to FPREG
    3733/    4A56 : 01 06 03            	LD	BC,0306H	; 1E+06 to 1E-03 range
    3734/    4A59 : F1                  	POP	AF		; Restore count
    3735/    4A5A : 81                  	ADD	A,C		; 6 digits before point
    3736/    4A5B : 3C                  	INC	A		; Add one
    3737/    4A5C : FA 68 4A            	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
    3738/    4A5F : FE 08               	CP	6+1+1		; More than 999999 ?
    3739/    4A61 : D2 68 4A            	JP	NC,MAKNUM	; Yes - Do it in 'E' form
    3740/    4A64 : 3C                  	INC	A		; Adjust for exponent
    3741/    4A65 : 47                  	LD	B,A		; Exponent of number
    3742/    4A66 : 3E 02               	LD	A,2		; Make it zero after
    3743/    4A68 :                     ;
    3744/    4A68 : 3D                  MAKNUM: DEC	A		; Adjust for digits to do
    3745/    4A69 : 3D                  	DEC	A
    3746/    4A6A : E1                  	POP	HL		; Restore buffer address
    3747/    4A6B : F5                  	PUSH	AF		; Save count
    3748/    4A6C : 11 EE 4A            	LD	DE,POWERS	; Powers of ten
    3749/    4A6F : 05                  	DEC	B		; Count digits before point
    3750/    4A70 : C2 79 4A            	JP	NZ,DIGTXT	; Not zero - Do number
    3751/    4A73 : 36 2E               	LD	(HL),'.'	; Save point
    3752/    4A75 : 23                  	INC	HL		; Move on
    3753/    4A76 : 36 30               	LD	(HL),'0'	; Save zero
    3754/    4A78 : 23                  	INC	HL		; Move on
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 64 - 12/29/2022 20:41:36


    3755/    4A79 : 05                  DIGTXT: DEC	B		; Count digits before point
    3756/    4A7A : 36 2E               	LD	(HL),'.'	; Save point in case
    3757/    4A7C : CC C2 48            	CALL	Z,INCHL		; Last digit - move on
    3758/    4A7F : C5                  	PUSH	BC		; Save digits before point
    3759/    4A80 : E5                  	PUSH	HL		; Save buffer address
    3760/    4A81 : D5                  	PUSH	DE		; Save powers of ten
    3761/    4A82 : CD B8 48            	CALL	BCDEFP		; Move FPREG to BCDE
    3762/    4A85 : E1                  	POP	HL		; Powers of ten table
    3763/    4A86 : 06 2F               	LD	B, '0'-1	; ASCII '0' - 1
    3764/    4A88 : 04                  TRYAGN: INC	B		; Count subtractions
    3765/    4A89 : 7B                  	LD	A,E		; Get LSB
    3766/    4A8A : 96                  	SUB	(HL)		; Subtract LSB
    3767/    4A8B : 5F                  	LD	E,A		; Save LSB
    3768/    4A8C : 23                  	INC	HL
    3769/    4A8D : 7A                  	LD	A,D		; Get NMSB
    3770/    4A8E : 9E                  	SBC	A,(HL)		; Subtract NMSB
    3771/    4A8F : 57                  	LD	D,A		; Save NMSB
    3772/    4A90 : 23                  	INC	HL
    3773/    4A91 : 79                  	LD	A,C		; Get MSB
    3774/    4A92 : 9E                  	SBC	A,(HL)		; Subtract MSB
    3775/    4A93 : 4F                  	LD	C,A		; Save MSB
    3776/    4A94 : 2B                  	DEC	HL		; Point back to start
    3777/    4A95 : 2B                  	DEC	HL
    3778/    4A96 : D2 88 4A            	JP	NC,TRYAGN	; No overflow - Try again
    3779/    4A99 : CD CB 46            	CALL	PLUCDE		; Restore number
    3780/    4A9C : 23                  	INC	HL		; Start of next number
    3781/    4A9D : CD AD 48            	CALL	FPBCDE		; Move BCDE to FPREG
    3782/    4AA0 : EB                  	EX	DE,HL		; Save point in table
    3783/    4AA1 : E1                  	POP	HL		; Restore buffer address
    3784/    4AA2 : 70                  	LD	(HL),B		; Save digit in buffer
    3785/    4AA3 : 23                  	INC	HL		; And move on
    3786/    4AA4 : C1                  	POP	BC		; Restore digit count
    3787/    4AA5 : 0D                  	DEC	C		; Count digits
    3788/    4AA6 : C2 79 4A            	JP	NZ,DIGTXT	; More - Do them
    3789/    4AA9 : 05                  	DEC	B		; Any decimal part?
    3790/    4AAA : CA B9 4A            	JP	Z,DOEBIT	; No - Do 'E' bit
    3791/    4AAD : 2B                  SUPTLZ: DEC	HL		; Move back through buffer
    3792/    4AAE : 7E                  	LD	A,(HL)		; Get character
    3793/    4AAF : FE 30               	CP	'0'		; '0' character?
    3794/    4AB1 : CA AD 4A            	JP	Z,SUPTLZ	; Yes - Look back for more
    3795/    4AB4 : FE 2E               	CP	'.'		; A decimal point?
    3796/    4AB6 : C4 C2 48            	CALL	NZ,INCHL	; Move back over digit
    3797/    4AB9 :                     ;
    3798/    4AB9 : F1                  DOEBIT: POP	AF		; Get 'E' flag
    3799/    4ABA : CA D8 4A            	JP	Z,NOENED	; No 'E' needed - End buffer
    3800/    4ABD : 36 45               	LD	(HL),'E'	; Put 'E' in buffer
    3801/    4ABF : 23                  	INC	HL		; And move on
    3802/    4AC0 : 36 2B               	LD	(HL),'+'	; Put '+' in buffer
    3803/    4AC2 : F2 C9 4A            	JP	P,OUTEXP	; Positive - Output exponent
    3804/    4AC5 : 36 2D               	LD	(HL),'-'	; Put '-' in buffer
    3805/    4AC7 : 2F                  	CPL			; Negate exponent
    3806/    4AC8 : 3C                  	INC	A
    3807/    4AC9 : 06 2F               OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
    3808/    4ACB : 04                  EXPTEN: INC	B		; Count subtractions
    3809/    4ACC : D6 0A               	SUB	10		; Tens digit
    3810/    4ACE : D2 CB 4A            	JP	NC,EXPTEN	; More to do
    3811/    4AD1 : C6 3A               	ADD	A,'0'+10	; Restore and make ASCII
    3812/    4AD3 : 23                  	INC	HL		; Move on
    3813/    4AD4 : 70                  	LD	(HL),B		; Save MSB of exponent
    3814/    4AD5 : 23                  JSTZER: INC	HL		;
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 65 - 12/29/2022 20:41:36


    3815/    4AD6 : 77                  	LD	(HL),A		; Save LSB of exponent
    3816/    4AD7 : 23                  	INC	HL
    3817/    4AD8 : 71                  NOENED: LD	(HL),C		; Mark end of buffer
    3818/    4AD9 : E1                  	POP	HL		; Restore code string address
    3819/    4ADA : C9                  	RET
    3820/    4ADB :                     ;
    3821/    4ADB : 01 74 94            RNGTST: LD	BC,9474H	; BCDE = 999999.
    3822/    4ADE : 11 F7 23            	LD	DE,23F7H
    3823/    4AE1 : CD E7 48            	CALL	CMPNUM		; Compare numbers
    3824/    4AE4 : B7                  	OR	A
    3825/    4AE5 : E1                  	POP	HL		; Return address to HL
    3826/    4AE6 : E2 43 4A            	JP	PO,GTSIXD	; Too big - Divide by ten
    3827/    4AE9 : E9                  	JP	(HL)		; Otherwise return to caller
    3828/    4AEA :                     ;
    3829/    4AEA : 00 00 00 80         HALF:	DB	00H,00H,00H,80H	; 0.5
    3830/    4AEE :                     ;
    3831/    4AEE : A0 86 01            POWERS: DB	0A0H,086H,001H	; 100000
    3832/    4AF1 : 10 27 00            	DB	010H,027H,000H	; 10000
    3833/    4AF4 : E8 03 00            	DB	0E8H,003H,000H	; 1000
    3834/    4AF7 : 64 00 00            	DB	064H,000H,000H	; 100
    3835/    4AFA : 0A 00 00            	DB	00AH,000H,000H	; 10
    3836/    4AFD : 01 00 00            	DB	001H,000H,000H	; 1
    3837/    4B00 :                     ;
    3838/    4B00 : 21 95 48            NEGAFT: LD	HL,INVSGN	; Negate result
    3839/    4B03 : E3                  	EX	(SP),HL		; To be done after caller
    3840/    4B04 : E9                  	JP	(HL)		; Return to caller
    3841/    4B05 :                     ;
    3842/    4B05 : CD 9D 48            SQR:	CALL	STAKFP		; Put value on stack
    3843/    4B08 : 21 EA 4A            	LD	HL,HALF		; Set power to 1/2
    3844/    4B0B : CD AA 48            	CALL	PHLTFP		; Move 1/2 to FPREG
    3845/    4B0E :                     ;
    3846/    4B0E : C1                  POWER:	POP	BC		; Get base
    3847/    4B0F : D1                  	POP	DE
    3848/    4B10 : CD 6C 48            	CALL	TSTSGN		; Test sign of power
    3849/    4B13 : 78                  	LD	A,B		; Get exponent of base
    3850/    4B14 : CA 53 4B            	JP	Z,EXP		; Make result 1 if zero
    3851/    4B17 : F2 1E 4B            	JP	P,POWER1	; Positive base - Ok
    3852/    4B1A : B7                  	OR	A		; Zero to negative power?
    3853/    4B1B : CA BD 35            	JP	Z,DZERR		; Yes - ?/0 Error
    3854/    4B1E : B7                  POWER1: OR	A		; Base zero?
    3855/    4B1F : CA 8D 46            	JP	Z,SAVEXP	; Yes - Return zero
    3856/    4B22 : D5                  	PUSH	DE		; Save base
    3857/    4B23 : C5                  	PUSH	BC
    3858/    4B24 : 79                  	LD	A,C		; Get MSB of base
    3859/    4B25 : F6 7F               	OR	01111111B	; Get sign status
    3860/    4B27 : CD B8 48            	CALL	BCDEFP		; Move power to BCDE
    3861/    4B2A : F2 3B 4B            	JP	P,POWER2	; Positive base - Ok
    3862/    4B2D : D5                  	PUSH	DE		; Save power
    3863/    4B2E : C5                  	PUSH	BC
    3864/    4B2F : CD 3F 49            	CALL	INT		; Get integer of power
    3865/    4B32 : C1                  	POP	BC		; Restore power
    3866/    4B33 : D1                  	POP	DE
    3867/    4B34 : F5                  	PUSH	AF		; MSB of base
    3868/    4B35 : CD E7 48            	CALL	CMPNUM		; Power an integer?
    3869/    4B38 : E1                  	POP	HL		; Restore MSB of base
    3870/    4B39 : 7C                  	LD	A,H		; but don't affect flags
    3871/    4B3A : 1F                  	RRA			; Exponent odd or even?
    3872/    4B3B : E1                  POWER2: POP	HL		; Restore MSB and exponent
    3873/    4B3C : 22 2B 81            	LD	(FPREG+2),HL	; Save base in FPREG
    3874/    4B3F : E1                  	POP	HL		; LSBs of base
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 66 - 12/29/2022 20:41:36


    3875/    4B40 : 22 29 81            	LD	(FPREG),HL	; Save in FPREG
    3876/    4B43 : DC 00 4B            	CALL	C,NEGAFT	; Odd power - Negate result
    3877/    4B46 : CC 95 48            	CALL	Z,INVSGN	; Negative base - Negate it
    3878/    4B49 : D5                  	PUSH	DE		; Save power
    3879/    4B4A : C5                  	PUSH	BC
    3880/    4B4B : CD 20 47            	CALL	LOG		; Get LOG of base
    3881/    4B4E : C1                  	POP	BC		; Restore power
    3882/    4B4F : D1                  	POP	DE
    3883/    4B50 : CD 61 47            	CALL	FPMULT		; Multiply LOG by power
    3884/    4B53 :                     ;
    3885/    4B53 : CD 9D 48            EXP:	CALL	STAKFP		; Put value on stack
    3886/    4B56 : 01 38 81            	LD	BC,08138H	; BCDE = 1/Ln(2)
    3887/    4B59 : 11 3B AA            	LD	DE,0AA3BH
    3888/    4B5C : CD 61 47            	CALL	FPMULT		; Multiply value by 1/LN(2)
    3889/    4B5F : 3A 2C 81            	LD	A,(FPEXP)	; Get exponent
    3890/    4B62 : FE 88               	CP	80H+8		; Is it in range?
    3891/    4B64 : D2 48 48            	JP	NC,OVTST1	; No - Test for overflow
    3892/    4B67 : CD 3F 49            	CALL	INT		; Get INT of FPREG
    3893/    4B6A : C6 80               	ADD	A,80H		; For excess 128
    3894/    4B6C : C6 02               	ADD	A,2		; Exponent > 126?
    3895/    4B6E : DA 48 48            	JP	C,OVTST1	; Yes - Test for overflow
    3896/    4B71 : F5                  	PUSH	AF		; Save scaling factor
    3897/    4B72 : 21 0F 47            	LD	HL,UNITY	; Point to 1.
    3898/    4B75 : CD 17 46            	CALL	ADDPHL		; Add 1 to FPREG
    3899/    4B78 : CD 58 47            	CALL	MULLN2		; Multiply by LN(2)
    3900/    4B7B : F1                  	POP	AF		; Restore scaling factor
    3901/    4B7C : C1                  	POP	BC		; Restore exponent
    3902/    4B7D : D1                  	POP	DE
    3903/    4B7E : F5                  	PUSH	AF		; Save scaling factor
    3904/    4B7F : CD 23 46            	CALL	SUBCDE		; Subtract exponent from FPREG
    3905/    4B82 : CD 95 48            	CALL	INVSGN		; Negate result
    3906/    4B85 : 21 93 4B            	LD	HL,EXPTAB	; Coefficient table
    3907/    4B88 : CD C3 4B            	CALL	SMSER1		; Sum the series
    3908/    4B8B : 11 00 00            	LD	DE,0		; Zero LSBs
    3909/    4B8E : C1                  	POP	BC		; Scaling factor
    3910/    4B8F : 4A                  	LD	C,D		; Zero MSB
    3911/    4B90 : C3 61 47            	JP	FPMULT		; Scale result to correct value
    3912/    4B93 :                     ;
    3913/    4B93 : 08                  EXPTAB: DB	8			; Table used by EXP
    3914/    4B94 : 40 2E 94 74         	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
    3915/    4B98 : 70 4F 2E 77         	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
    3916/    4B9C : 6E 02 88 7A         	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
    3917/    4BA0 : E6 A0 2A 7C         	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
    3918/    4BA4 : 50 AA AA 7E         	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
    3919/    4BA8 : FF FF 7F 7F         	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
    3920/    4BAC : 00 00 80 81         	DB	000H,000H,080H,081H	; -1/1! (-1/1)
    3921/    4BB0 : 00 00 00 81         	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
    3922/    4BB4 :                     ;
    3923/    4BB4 : CD 9D 48            SUMSER: CALL	STAKFP		; Put FPREG on stack
    3924/    4BB7 : 11 5F 47            	LD	DE,MULT		; Multiply by "X"
    3925/    4BBA : D5                  	PUSH	DE		; To be done after
    3926/    4BBB : E5                  	PUSH	HL		; Save address of table
    3927/    4BBC : CD B8 48            	CALL	BCDEFP		; Move FPREG to BCDE
    3928/    4BBF : CD 61 47            	CALL	FPMULT		; Square the value
    3929/    4BC2 : E1                  	POP	HL		; Restore address of table
    3930/    4BC3 : CD 9D 48            SMSER1: CALL	STAKFP		; Put value on stack
    3931/    4BC6 : 7E                  	LD	A,(HL)		; Get number of coefficients
    3932/    4BC7 : 23                  	INC	HL		; Point to start of table
    3933/    4BC8 : CD AA 48            	CALL	PHLTFP		; Move coefficient to FPREG
    3934/    4BCB : 06                  	DB	06H		; Skip "POP AF"
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 67 - 12/29/2022 20:41:36


    3935/    4BCC : F1                  SUMLP:	POP	AF		; Restore count
    3936/    4BCD : C1                  	POP	BC		; Restore number
    3937/    4BCE : D1                  	POP	DE
    3938/    4BCF : 3D                  	DEC	A		; Cont coefficients
    3939/    4BD0 : C8                  	RET	Z		; All done
    3940/    4BD1 : D5                  	PUSH	DE		; Save number
    3941/    4BD2 : C5                  	PUSH	BC
    3942/    4BD3 : F5                  	PUSH	AF		; Save count
    3943/    4BD4 : E5                  	PUSH	HL		; Save address in table
    3944/    4BD5 : CD 61 47            	CALL	FPMULT		; Multiply FPREG by BCDE
    3945/    4BD8 : E1                  	POP	HL		; Restore address in table
    3946/    4BD9 : CD BB 48            	CALL	LOADFP		; Number at HL to BCDE
    3947/    4BDC : E5                  	PUSH	HL		; Save address in table
    3948/    4BDD : CD 26 46            	CALL	FPADD		; Add coefficient to FPREG
    3949/    4BE0 : E1                  	POP	HL		; Restore address in table
    3950/    4BE1 : C3 CC 4B            	JP	SUMLP		; More coefficients
    3951/    4BE4 :                     ;
    3952/    4BE4 : CD 6C 48            RND:	CALL	TSTSGN		; Test sign of FPREG
    3953/    4BE7 : 21 5E 80            	LD	HL,SEED+2	; Random number seed
    3954/    4BEA : FA 45 4C            	JP	M,RESEED	; Negative - Re-seed
    3955/    4BED : 21 7F 80            	LD	HL,LSTRND	; Last random number
    3956/    4BF0 : CD AA 48            	CALL	PHLTFP		; Move last RND to FPREG
    3957/    4BF3 : 21 5E 80            	LD	HL,SEED+2	; Random number seed
    3958/    4BF6 : C8                  	RET	Z		; Return if RND(0)
    3959/    4BF7 : 86                  	ADD	A,(HL)		; Add (SEED)+2)
    3960/    4BF8 : E6 07               	AND	00000111B	; 0 to 7
    3961/    4BFA : 06 00               	LD	B,0
    3962/    4BFC : 77                  	LD	(HL),A		; Re-save seed
    3963/    4BFD : 23                  	INC	HL		; Move to coefficient table
    3964/    4BFE : 87                  	ADD	A,A		; 4 bytes
    3965/    4BFF : 87                  	ADD	A,A		; per entry
    3966/    4C00 : 4F                  	LD	C,A		; BC = Offset into table
    3967/    4C01 : 09                  	ADD	HL,BC		; Point to coefficient
    3968/    4C02 : CD BB 48            	CALL	LOADFP		; Coefficient to BCDE
    3969/    4C05 : CD 61 47            	CALL	FPMULT	;	; Multiply FPREG by coefficient
    3970/    4C08 : 3A 5D 80            	LD	A,(SEED+1)	; Get (SEED+1)
    3971/    4C0B : 3C                  	INC	A		; Add 1
    3972/    4C0C : E6 03               	AND	00000011B	; 0 to 3
    3973/    4C0E : 06 00               	LD	B,0
    3974/    4C10 : FE 01               	CP	1		; Is it zero?
    3975/    4C12 : 88                  	ADC	A,B		; Yes - Make it 1
    3976/    4C13 : 32 5D 80            	LD	(SEED+1),A	; Re-save seed
    3977/    4C16 : 21 49 4C            	LD	HL,RNDTAB-4	; Addition table
    3978/    4C19 : 87                  	ADD	A,A		; 4 bytes
    3979/    4C1A : 87                  	ADD	A,A		; per entry
    3980/    4C1B : 4F                  	LD	C,A		; BC = Offset into table
    3981/    4C1C : 09                  	ADD	HL,BC		; Point to value
    3982/    4C1D : CD 17 46            	CALL	ADDPHL		; Add value to FPREG
    3983/    4C20 : CD B8 48            RND1:	CALL	BCDEFP		; Move FPREG to BCDE
    3984/    4C23 : 7B                  	LD	A,E		; Get LSB
    3985/    4C24 : 59                  	LD	E,C		; LSB = MSB
    3986/    4C25 : EE 4F               	XOR	01001111B	; Fiddle around
    3987/    4C27 : 4F                  	LD	C,A		; New MSB
    3988/    4C28 : 36 80               	LD	(HL),80H	; Set exponent
    3989/    4C2A : 2B                  	DEC	HL		; Point to MSB
    3990/    4C2B : 46                  	LD	B,(HL)		; Get MSB
    3991/    4C2C : 36 80               	LD	(HL),80H	; Make value -0.5
    3992/    4C2E : 21 5C 80            	LD	HL,SEED		; Random number seed
    3993/    4C31 : 34                  	INC	(HL)		; Count seed
    3994/    4C32 : 7E                  	LD	A,(HL)		; Get seed
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 68 - 12/29/2022 20:41:36


    3995/    4C33 : D6 AB               	SUB	171		; Do it modulo 171
    3996/    4C35 : C2 3C 4C            	JP	NZ,RND2		; Non-zero - Ok
    3997/    4C38 : 77                  	LD	(HL),A		; Zero seed
    3998/    4C39 : 0C                  	INC	C		; Fillde about
    3999/    4C3A : 15                  	DEC	D		; with the
    4000/    4C3B : 1C                  	INC	E		; number
    4001/    4C3C : CD 77 46            RND2:	CALL	BNORM		; Normalise number
    4002/    4C3F : 21 7F 80            	LD	HL,LSTRND	; Save random number
    4003/    4C42 : C3 C4 48            	JP	FPTHL		; Move FPREG to last and return
    4004/    4C45 :                     ;
    4005/    4C45 : 77                  RESEED: LD	(HL),A		; Re-seed random numbers
    4006/    4C46 : 2B                  	DEC	HL
    4007/    4C47 : 77                  	LD	(HL),A
    4008/    4C48 : 2B                  	DEC	HL
    4009/    4C49 : 77                  	LD	(HL),A
    4010/    4C4A : C3 20 4C            	JP	RND1		; Return RND seed
    4011/    4C4D :                     ;
    4012/    4C4D : 68 B1 46 68         RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
    4013/    4C51 : 99 E9 92 69         	DB	099H,0E9H,092H,069H
    4014/    4C55 : 10 D1 75 68         	DB	010H,0D1H,075H,068H
    4015/    4C59 :                     ;
    4016/    4C59 : 21 A3 4C            COS:	LD	HL,HALFPI	; Point to PI/2
    4017/    4C5C : CD 17 46            	CALL	ADDPHL		; Add it to PPREG
    4018/    4C5F : CD 9D 48            SIN:	CALL	STAKFP		; Put angle on stack
    4019/    4C62 : 01 49 83            	LD	BC,8349H	; BCDE = 2 PI
    4020/    4C65 : 11 DB 0F            	LD	DE,0FDBH
    4021/    4C68 : CD AD 48            	CALL	FPBCDE		; Move 2 PI to FPREG
    4022/    4C6B : C1                  	POP	BC		; Restore angle
    4023/    4C6C : D1                  	POP	DE
    4024/    4C6D : CD C2 47            	CALL	DVBCDE		; Divide angle by 2 PI
    4025/    4C70 : CD 9D 48            	CALL	STAKFP		; Put it on stack
    4026/    4C73 : CD 3F 49            	CALL	INT		; Get INT of result
    4027/    4C76 : C1                  	POP	BC		; Restore number
    4028/    4C77 : D1                  	POP	DE
    4029/    4C78 : CD 23 46            	CALL	SUBCDE		; Make it 0 <= value < 1
    4030/    4C7B : 21 A7 4C            	LD	HL,QUARTR	; Point to 0.25
    4031/    4C7E : CD 1D 46            	CALL	SUBPHL		; Subtract value from 0.25
    4032/    4C81 : CD 6C 48            	CALL	TSTSGN		; Test sign of value
    4033/    4C84 : 37                  	SCF			; Flag positive
    4034/    4C85 : F2 8F 4C            	JP	P,SIN1		; Positive - Ok
    4035/    4C88 : CD 14 46            	CALL	ROUND		; Add 0.5 to value
    4036/    4C8B : CD 6C 48            	CALL	TSTSGN		; Test sign of value
    4037/    4C8E : B7                  	OR	A		; Flag negative
    4038/    4C8F : F5                  SIN1:	PUSH	AF		; Save sign
    4039/    4C90 : F4 95 48            	CALL	P,INVSGN	; Negate value if positive
    4040/    4C93 : 21 A7 4C            	LD	HL,QUARTR	; Point to 0.25
    4041/    4C96 : CD 17 46            	CALL	ADDPHL		; Add 0.25 to value
    4042/    4C99 : F1                  	POP	AF		; Restore sign
    4043/    4C9A : D4 95 48            	CALL	NC,INVSGN	; Negative - Make positive
    4044/    4C9D : 21 AB 4C            	LD	HL,SINTAB	; Coefficient table
    4045/    4CA0 : C3 B4 4B            	JP	SUMSER		; Evaluate sum of series
    4046/    4CA3 :                     ;
    4047/    4CA3 : DB 0F 49 81         HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
    4048/    4CA7 :                     ;
    4049/    4CA7 : 00 00 00 7F         QUARTR: DB	000H,000H,000H,07FH	; 0.25
    4050/    4CAB :                     ;
    4051/    4CAB : 05                  SINTAB: DB	5			; Table used by SIN
    4052/    4CAC : BA D7 1E 86         	DB	0BAH,0D7H,01EH,086H	; 39.711
    4053/    4CB0 : 64 26 99 87         	DB	064H,026H,099H,087H	;-76.575
    4054/    4CB4 : 58 34 23 87         	DB	058H,034H,023H,087H	; 81.602
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 69 - 12/29/2022 20:41:36


    4055/    4CB8 : E0 5D A5 86         	DB	0E0H,05DH,0A5H,086H	;-41.342
    4056/    4CBC : DA 0F 49 83         	DB	0DAH,00FH,049H,083H	; 6.2832
    4057/    4CC0 :                     ;
    4058/    4CC0 : CD 9D 48            TAN:	CALL	STAKFP		; Put angle on stack
    4059/    4CC3 : CD 5F 4C            	CALL	SIN		; Get SIN of angle
    4060/    4CC6 : C1                  	POP	BC		; Restore angle
    4061/    4CC7 : E1                  	POP	HL
    4062/    4CC8 : CD 9D 48            	CALL	STAKFP		; Save SIN of angle
    4063/    4CCB : EB                  	EX	DE,HL		; BCDE = Angle
    4064/    4CCC : CD AD 48            	CALL	FPBCDE		; Angle to FPREG
    4065/    4CCF : CD 59 4C            	CALL	COS		; Get COS of angle
    4066/    4CD2 : C3 C0 47            	JP	DIV		; TAN = SIN / COS
    4067/    4CD5 :                     ;
    4068/    4CD5 : CD 6C 48            ATN:	CALL	TSTSGN		; Test sign of value
    4069/    4CD8 : FC 00 4B            	CALL	M,NEGAFT	; Negate result after if -ve
    4070/    4CDB : FC 95 48            	CALL	M,INVSGN	; Negate value if -ve
    4071/    4CDE : 3A 2C 81            	LD	A,(FPEXP)	; Get exponent
    4072/    4CE1 : FE 81               	CP	81H		; Number less than 1?
    4073/    4CE3 : DA F2 4C            	JP	C,ATN1		; Yes - Get arc tangnt
    4074/    4CE6 : 01 00 81            	LD	BC,8100H	; BCDE = 1
    4075/    4CE9 : 51                  	LD	D,C
    4076/    4CEA : 59                  	LD	E,C
    4077/    4CEB : CD C2 47            	CALL	DVBCDE		; Get reciprocal of number
    4078/    4CEE : 21 1D 46            	LD	HL,SUBPHL	; Sub angle from PI/2
    4079/    4CF1 : E5                  	PUSH	HL		; Save for angle > 1
    4080/    4CF2 : 21 FC 4C            ATN1:	LD	HL,ATNTAB	; Coefficient table
    4081/    4CF5 : CD B4 4B            	CALL	SUMSER		; Evaluate sum of series
    4082/    4CF8 : 21 A3 4C            	LD	HL,HALFPI	; PI/2 - angle in case > 1
    4083/    4CFB : C9                  	RET			; Number > 1 - Sub from PI/2
    4084/    4CFC :                     ;
    4085/    4CFC : 09                  ATNTAB: DB	9			; Table used by ATN
    4086/    4CFD : 4A D7 3B 78         	DB	04AH,0D7H,03BH,078H	; 1/17
    4087/    4D01 : 02 6E 84 7B         	DB	002H,06EH,084H,07BH	;-1/15
    4088/    4D05 : FE C1 2F 7C         	DB	0FEH,0C1H,02FH,07CH	; 1/13
    4089/    4D09 : 74 31 9A 7D         	DB	074H,031H,09AH,07DH	;-1/11
    4090/    4D0D : 84 3D 5A 7D         	DB	084H,03DH,05AH,07DH	; 1/9
    4091/    4D11 : C8 7F 91 7E         	DB	0C8H,07FH,091H,07EH	;-1/7
    4092/    4D15 : E4 BB 4C 7E         	DB	0E4H,0BBH,04CH,07EH	; 1/5
    4093/    4D19 : 6C AA AA 7F         	DB	06CH,0AAH,0AAH,07FH	;-1/3
    4094/    4D1D : 00 00 00 81         	DB	000H,000H,000H,081H	; 1/1
    4095/    4D21 :                     ;
    4096/    4D21 :                     
    4097/    4D21 : C9                  ARET:	RET			; A RETurn instruction
    4098/    4D22 :                     ;
    4099/    4D22 : D7                  GETINP: RST	10H		;input a character
    4100/    4D23 : C9                  	RET
    4101/    4D24 :                     ;
    4102/    4D24 :                     CLS: 
    4103/    4D24 : 3E 0C               	LD	A,CS		; ASCII Clear screen
    4104/    4D26 : C3 6D 4E            	JP	MONOUT		; Output character
    4105/    4D29 :                     ;
    4106/    4D29 : CD EB 45            WIDTH:	CALL	GETINT		; Get integer 0-255
    4107/    4D2C : 7B                  	LD	A,E		; Width to A
    4108/    4D2D : 32 87 80            	LD	(LWIDTH),A	; Set width
    4109/    4D30 : C9                  	RET
    4110/    4D31 :                     ;
    4111/    4D31 : CD 87 3E            LINES:	CALL	GETNUM		; Get a number
    4112/    4D34 : CD CC 3A            	CALL	DEINT		; Get integer -32768 to 32767
    4113/    4D37 :                     ;	LD	(LINESC),DE	; Set lines counter
    4114/    4D37 :                     ;	LD	(LINESN),DE	; Set lines number
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 70 - 12/29/2022 20:41:36


    4115/    4D37 : EB                  	EX	DE,HL		; REPLACE Z80 CODE
    4116/    4D38 : 22 8B 80                    LD      (LINESC),HL     ; REPLACE Z80 CODE
    4117/    4D3B : 22 8D 80                    LD      (LINESN),HL     ; REPLACE Z80 CODE
    4118/    4D3E : EB                  	EX	DE,HL		; REPLACE Z80 CODE
    4119/    4D3F : C9                  	RET
    4120/    4D40 :                     ;
    4121/    4D40 : CD CC 3A            DEEK:	CALL	DEINT		; Get integer -32768 to 32767
    4122/    4D43 : D5                  	PUSH	DE		; Save number
    4123/    4D44 : E1                  	POP	HL		; Number to HL
    4124/    4D45 : 46                  	LD	B,(HL)		; Get LSB of contents
    4125/    4D46 : 23                  	INC	HL
    4126/    4D47 : 7E                  	LD	A,(HL)		; Get MSB of contents
    4127/    4D48 : C3 43 42            	JP	ABPASS		; Return integer AB
    4128/    4D4B :                     ;
    4129/    4D4B : CD 87 3E            DOKE:	CALL	GETNUM		; Get a number
    4130/    4D4E : CD CC 3A            	CALL	DEINT		; Get integer -32768 to 32767
    4131/    4D51 : D5                  	PUSH	DE		; Save address
    4132/    4D52 : CD 88 38            	CALL	CHKSYN		; Make sure ',' follows
    4133/    4D55 : 2C                  	DB	','
    4134/    4D56 : CD 87 3E            	CALL	GETNUM		; Get a number
    4135/    4D59 : CD CC 3A            	CALL	DEINT		; Get integer -32768 to 32767
    4136/    4D5C : E3                  	EX	(SP),HL		; Save value,get address
    4137/    4D5D : 73                  	LD	(HL),E		; Save LSB of value
    4138/    4D5E : 23                  	INC	HL
    4139/    4D5F : 72                  	LD	(HL),D		; Save MSB of value
    4140/    4D60 : E1                  	POP	HL		; Restore code string address
    4141/    4D61 : C9                  	RET
    4142/    4D62 :                     ;
    4143/    4D62 :                     ; HEX$(nn) Convert 16 bit number to Hexadecimal string
    4144/    4D62 :                     ;
    4145/    4D62 : CD 8A 3E            HEX: 	CALL	TSTNUM		; Verify it's a number
    4146/    4D65 : CD CC 3A            	CALL	DEINT		; Get integer -32768 to 32767
    4147/    4D68 : C5                  	PUSH	BC		; Save contents of BC
    4148/    4D69 : 21 2E 81            	LD	HL,PBUFF
    4149/    4D6C : 7A                  	LD	A,D		; Get high order into A
    4150/    4D6D : FE 00               	CP	0
    4151/    4D6F : CA 7F 4D            	JP	Z,HEX2		; Skip output if both high digits are zero
    4152/    4D72 : CD 9E 4D            	CALL	BYT2ASC		; Convert D to ASCII
    4153/    4D75 : 78                  	LD	A,B
    4154/    4D76 : FE 30               	CP	'0'
    4155/    4D78 : CA 7D 4D            	JP	Z,HEX1		; Don't store high digit if zero
    4156/    4D7B : 70                  	LD	(HL),B		; Store it to PBUFF
    4157/    4D7C : 23                  	INC	HL		; Next location
    4158/    4D7D : 71                  HEX1:	LD	(HL),C		; Store C to PBUFF+1
    4159/    4D7E : 23                  	INC	HL		; Next location
    4160/    4D7F : 7B                  HEX2:	LD	A,E		; Get lower byte
    4161/    4D80 : CD 9E 4D            	CALL	BYT2ASC		; Convert E to ASCII
    4162/    4D83 : 7A                  	LD	A,D
    4163/    4D84 : FE 00               	CP	0
    4164/    4D86 : C2 8F 4D            	JP	NZ,HEX3		; If upper byte was not zero then always print lower byte
    4165/    4D89 : 78                  	LD	A,B
    4166/    4D8A : FE 30               	CP	'0'		; If high digit of lower byte is zero then don't print
    4167/    4D8C : CA 91 4D            	JP	Z,HEX4
    4168/    4D8F : 70                  HEX3:	LD	(HL),B		; to PBUFF+2
    4169/    4D90 : 23                  	INC	HL		; Next location
    4170/    4D91 : 71                  HEX4:	LD	(HL),C		; to PBUFF+3
    4171/    4D92 : 23                  	INC	HL		; PBUFF+4 to zero
    4172/    4D93 : AF                  	XOR	A		; Terminating character
    4173/    4D94 : 77                  	LD	(HL),A		; Store zero to terminate
    4174/    4D95 : 23                  	INC	HL		; Make sure PBUFF is terminated
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 71 - 12/29/2022 20:41:36


    4175/    4D96 : 77                  	LD	(HL),A		; Store the double zero there
    4176/    4D97 : C1                  	POP	BC		; Get BC back
    4177/    4D98 : 21 2E 81            	LD	HL,PBUFF	; Reset to start of PBUFF
    4178/    4D9B : C3 F1 42            	JP	STR1		; Convert the PBUFF to a string and return it
    4179/    4D9E :                     ;
    4180/    4D9E : 47                  BYT2ASC	LD	B,A		; Save original value
    4181/    4D9F : E6 0F               	AND	0FH		; Strip off upper nybble
    4182/    4DA1 : FE 0A               	CP	0AH		; 0-9?
    4183/    4DA3 : DA A8 4D            	JP	C,ADD30		; If A-F, add 7 more
    4184/    4DA6 : C6 07               	ADD	A,07H		; Bring value up to ASCII A-F
    4185/    4DA8 : C6 30               ADD30	ADD	A,30H		; And make ASCII
    4186/    4DAA : 4F                  	LD	C,A		; Save converted char to C
    4187/    4DAB : 78                  	LD	A,B		; Retrieve original value
    4188/    4DAC : 0F                  	RRCA			; and Rotate it right
    4189/    4DAD : 0F                  	RRCA
    4190/    4DAE : 0F                  	RRCA
    4191/    4DAF : 0F                  	RRCA
    4192/    4DB0 : E6 0F               	AND	0FH		; Mask off upper nybble
    4193/    4DB2 : FE 0A               	CP	0AH		; 0-9? < A hex?
    4194/    4DB4 : DA B9 4D            	JP	C,ADD301	; Skip Add 7
    4195/    4DB7 : C6 07               	ADD	A,07H		; Bring it up to ASCII A-F
    4196/    4DB9 : C6 30               ADD301	ADD	A,30H		; And make it full ASCII
    4197/    4DBB : 47                  	LD	B,A		; Store high order byte
    4198/    4DBC : C9                  	RET	
    4199/    4DBD :                     ;
    4200/    4DBD :                     ; Convert "&Hnnnn" to FPREG
    4201/    4DBD :                     ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
    4202/    4DBD :                     ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
    4203/    4DBD : EB                  HEXTFP	EX	DE,HL		; Move code string pointer to DE
    4204/    4DBE : 21 00 00            	LD	HL,0000H	; Zero out the value
    4205/    4DC1 : CD D9 4D            	CALL	GETHEX		; Check the number for valid hex
    4206/    4DC4 : DA FA 4D            	JP	C,HXERR		; First value wasn't hex, HX error
    4207/    4DC7 : C3 D0 4D            	JP	HEXLP1		; Convert first character
    4208/    4DCA : CD D9 4D            HEXLP	CALL	GETHEX		; Get second and addtional characters
    4209/    4DCD : DA F1 4D            	JP	C,HEXIT		; Exit if not a hex character
    4210/    4DD0 : 29                  HEXLP1	ADD	HL,HL		; Rotate 4 bits to the left
    4211/    4DD1 : 29                  	ADD	HL,HL
    4212/    4DD2 : 29                  	ADD	HL,HL
    4213/    4DD3 : 29                  	ADD	HL,HL
    4214/    4DD4 : B5                  	OR	L		; Add in D0-D3 into L
    4215/    4DD5 : 6F                  	LD	L,A		; Save new value
    4216/    4DD6 : C3 CA 4D            	JP	HEXLP		; And continue until all hex characters are in
    4217/    4DD9 :                     ;
    4218/    4DD9 : 13                  GETHEX	INC	DE		; Next location
    4219/    4DDA : 1A                  	LD	A,(DE)		; Load character at pointer
    4220/    4DDB : FE 20               	CP	' '
    4221/    4DDD : CA D9 4D            	JP	Z,GETHEX	; Skip spaces
    4222/    4DE0 : D6 30               	SUB	30H		; Get absolute value
    4223/    4DE2 : D8                  	RET	C		; < "0", error
    4224/    4DE3 : FE 0A               	CP	0AH
    4225/    4DE5 : DA ED 4D            	JP	C,NOSUB7	; Is already in the range 0-9
    4226/    4DE8 : D6 07               	SUB	07H		; Reduce to A-F
    4227/    4DEA : FE 0A               	CP	0AH		; Value should be $0A-$0F at this point
    4228/    4DEC : D8                  	RET	C		; CY set if was :		; < = > ? @
    4229/    4DED : FE 10               NOSUB7	CP	10H		; > Greater than "F"?
    4230/    4DEF : 3F                  	CCF
    4231/    4DF0 : C9                  	RET			; CY set if it wasn't valid hex
    4232/    4DF1 :                     	
    4233/    4DF1 : EB                  HEXIT	EX	DE,HL		; Value into DE, Code string into HL
    4234/    4DF2 : 7A                  	LD	A,D		; Load DE into AC
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 72 - 12/29/2022 20:41:36


    4235/    4DF3 : 4B                  	LD	C,E		; For prep to 
    4236/    4DF4 : E5                  	PUSH	HL
    4237/    4DF5 : CD 42 42            	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
    4238/    4DF8 : E1                  	POP	HL
    4239/    4DF9 : C9                  	RET
    4240/    4DFA :                     ;
    4241/    4DFA : 1E 26               HXERR:	LD	E,HX		; ?HEX Error
    4242/    4DFC : C3 CE 35            	JP	ERROR
    4243/    4DFF :                     ;
    4244/    4DFF :                     ; BIN$(NN) Convert integer to a 1-16 char binary string
    4245/    4DFF : CD 8A 3E            BIN:	CALL	TSTNUM		; Verify it's a number
    4246/    4E02 : CD CC 3A            	CALL	DEINT		; Get integer -32768 to 32767
    4247/    4E05 : C5                  BIN2:	PUSH	BC		; Save contents of BC
    4248/    4E06 : 21 2E 81            	LD	HL,PBUFF
    4249/    4E09 : 06 11               	LD	B,17		; One higher than max char count
    4250/    4E0B :                     ZEROSUP:			; Suppress leading zeros
    4251/    4E0B : 05                  	DEC	B		; Max 16 chars
    4252/    4E0C : 78                  	LD	A,B
    4253/    4E0D : FE 01               	CP	01H
    4254/    4E0F : CA 1E 4E            	JP	Z,BITOUT	; Always output at least one character
    4255/    4E12 :                     ;	RL	E
    4256/    4E12 :                     ;	RL	D
    4257/    4E12 : 7B                  	LD	A,E		; REPLACE Z80 CODE
    4258/    4E13 : 17                  	RLA			; REPLACE Z80 CODE
    4259/    4E14 : 5F                  	LD	E,A		; REPLACE Z80 CODE
    4260/    4E15 : 7A                  	LD	A,D		; REPLACE Z80 CODE
    4261/    4E16 : 17                  	RLA			; REPLACE Z80 CODE
    4262/    4E17 : 57                  	LD	D,A		; REPLACE Z80 CODE
    4263/    4E18 : D2 0B 4E            	JP	NC,ZEROSUP
    4264/    4E1B : C3 24 4E            	JP	BITOUT2
    4265/    4E1E :                     BITOUT:	
    4266/    4E1E :                     ;	RL	E
    4267/    4E1E :                     ;	RL	D		; Top bit now in carry
    4268/    4E1E : 7B                  	LD	A,E		; REPLACE Z80 CODE
    4269/    4E1F : 17                  	RLA			; REPLACE Z80 CODE
    4270/    4E20 : 5F                  	LD	E,A		; REPLACE Z80 CODE
    4271/    4E21 : 7A                  	LD	A,D		; REPLACE Z80 CODE
    4272/    4E22 : 17                  	RLA			; REPLACE Z80 CODE
    4273/    4E23 : 57                  	LD	D,A		; REPLACE Z80 CODE
    4274/    4E24 :                     BITOUT2:
    4275/    4E24 : 3E 30               	LD	A,'0'		; Char for '0'
    4276/    4E26 : CE 00               	ADC	A,0		; If carry set then '0' --> '1'
    4277/    4E28 : 77                  	LD	(HL),A
    4278/    4E29 : 23                  	INC	HL
    4279/    4E2A : 05                  	DEC	B
    4280/    4E2B : C2 1E 4E            	JP	NZ,BITOUT
    4281/    4E2E : AF                  	XOR	A		; Terminating character
    4282/    4E2F : 77                  	LD	(HL),A		; Store zero to terminate
    4283/    4E30 : 23                  	INC	HL		; Make sure PBUFF is terminated
    4284/    4E31 : 77                  	LD	(HL),A		; Store the double zero there
    4285/    4E32 : C1                  	POP	BC
    4286/    4E33 : 21 2E 81            	LD	HL,PBUFF
    4287/    4E36 : C3 F1 42            	JP	STR1
    4288/    4E39 :                     ;
    4289/    4E39 :                     ; Convert "&Bnnnn" to FPREG
    4290/    4E39 :                     ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
    4291/    4E39 : EB                  BINTFP: EX	DE,HL		; Move code string pointer to DE
    4292/    4E3A : 21 00 00            	LD	HL,0000H	; Zero out the value
    4293/    4E3D : CD 57 4E            	CALL	CHKBIN		; Check the number for valid bin
    4294/    4E40 : DA 65 4E            	JP	C,BINERR	; First value wasn't bin, HX error
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 73 - 12/29/2022 20:41:36


    4295/    4E43 : D6 30               BINIT:	SUB	'0'
    4296/    4E45 : 29                  	ADD	HL,HL		; Rotate HL left
    4297/    4E46 : B5                  	OR	L
    4298/    4E47 : 6F                  	LD	L,A
    4299/    4E48 : CD 57 4E            	CALL	CHKBIN		; Get second and addtional characters
    4300/    4E4B : D2 43 4E            	JP	NC,BINIT	; Process if a bin character
    4301/    4E4E : EB                  	EX	DE,HL		; Value into DE, Code string into HL
    4302/    4E4F : 7A                  	LD	A,D		; Load DE into AC
    4303/    4E50 : 4B                  	LD	C,E		; For prep to 
    4304/    4E51 : E5                  	PUSH	HL
    4305/    4E52 : CD 42 42            	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
    4306/    4E55 : E1                  	POP	HL
    4307/    4E56 : C9                  	RET
    4308/    4E57 :                     ;
    4309/    4E57 :                     ; Char is in A, NC if char is 0 or 1
    4310/    4E57 : 13                  CHKBIN: INC	DE
    4311/    4E58 : 1A                  	LD	A,(DE)
    4312/    4E59 : FE 20               	CP	' '
    4313/    4E5B : CA 57 4E            	JP	Z,CHKBIN	; Skip spaces
    4314/    4E5E : FE 30               	CP	'0'		; Set C if < '0'
    4315/    4E60 : D8                  	RET	C
    4316/    4E61 : FE 32               	CP	'2'
    4317/    4E63 : 3F                  	CCF			; Set C if > '1'
    4318/    4E64 : C9                  	RET
    4319/    4E65 :                     ;
    4320/    4E65 : 1E 28               BINERR: LD	E,BN		; ?BIN Error
    4321/    4E67 : C3 CE 35            	JP	ERROR
    4322/    4E6A :                     ;
    4323/    4E6A : C3 0D 32            JJUMP1: JP	CSTART		; Go and initialise
    4324/    4E6D :                     ;
    4325/    4E6D : C3 08 00            MONOUT: JP	0008H		; output a char
    4326/    4E70 :                     ;
    4327/    4E70 :                     MONITR: ;JP	0000H		; Restart (Normally Monitor Start)
    4328/    4E70 : 0E 01               	ld	c, 1
    4329/    4E72 : F7                  	rst	30h
    4330/    4E73 : C9                  	ret
    4331/    4E74 :                     
    4332/    4E74 : 3E 00               INITST: LD	A,0		; Clear break flag
    4333/    4E76 : 32 92 80            	LD	(BRKFLG),A
    4334/    4E79 : C3 14 32            	JP	INIT
    4335/    4E7C :                     ;
    4336/    4E7C : F5                  TSTBIT: PUSH	AF		; Save bit mask
    4337/    4E7D : A0                  	AND	B		; Get common bits
    4338/    4E7E : C1                  	POP	BC		; Restore bit mask
    4339/    4E7F : B8                  	CP	B		; Same bit set?
    4340/    4E80 : 3E 00               	LD	A,0		; Return 0 in A
    4341/    4E82 : C9                  	RET
    4342/    4E83 :                     ;
    4343/    4E83 : CD 93 38            OUTNCR: CALL	OUTC		; Output character in A
    4344/    4E86 : C3 C2 3C            	JP	PRCRLF		; Output CRLF
    4345/    4E89 :                     
    4346/    4E89 : FF FF FF FF FF FF   	db	5400H - $ dup(0FFH)
             4E8F : FF FF FF FF FF FF 
             4E95 : FF FF FF FF FF FF 
             4E9B : FF FF FF FF FF FF 
             4EA1 : FF FF FF FF FF FF 
             4EA7 : FF FF FF FF FF FF 
             4EAD : FF FF FF FF FF FF 
             4EB3 : FF FF FF FF FF FF 
             4EB9 : FF FF FF FF FF FF 
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 74 - 12/29/2022 20:41:36


             4EBF : FF FF FF FF FF FF 
             4EC5 : FF FF FF FF FF FF 
             4ECB : FF FF FF FF FF FF 
             4ED1 : FF FF FF FF FF FF 
             4ED7 : FF FF FF FF FF FF 
             4EDD : FF FF FF FF FF FF 
             4EE3 : FF FF FF FF FF FF 
             4EE9 : FF FF FF FF FF FF 
             4EEF : FF FF FF FF FF FF 
             4EF5 : FF FF FF FF FF FF 
             4EFB : FF FF FF FF FF FF 
             4F01 : FF FF FF FF FF FF 
             4F07 : FF FF FF FF FF FF 
             4F0D : FF FF FF FF FF FF 
             4F13 : FF FF FF FF FF FF 
             4F19 : FF FF FF FF FF FF 
             4F1F : FF FF FF FF FF FF 
             4F25 : FF FF FF FF FF FF 
             4F2B : FF FF FF FF FF FF 
             4F31 : FF FF FF FF FF FF 
             4F37 : FF FF FF FF FF FF 
             4F3D : FF FF FF FF FF FF 
             4F43 : FF FF FF FF FF FF 
             4F49 : FF FF FF FF FF FF 
             4F4F : FF FF FF FF FF FF 
             4F55 : FF FF FF FF FF FF 
             4F5B : FF FF FF FF FF FF 
             4F61 : FF FF FF FF FF FF 
             4F67 : FF FF FF FF FF FF 
             4F6D : FF FF FF FF FF FF 
             4F73 : FF FF FF FF FF FF 
             4F79 : FF FF FF FF FF FF 
             4F7F : FF FF FF FF FF FF 
             4F85 : FF FF FF FF FF FF 
             4F8B : FF FF FF FF FF FF 
             4F91 : FF FF FF FF FF FF 
             4F97 : FF FF FF FF FF FF 
             4F9D : FF FF FF FF FF FF 
             4FA3 : FF FF FF FF FF FF 
             4FA9 : FF FF FF FF FF FF 
             4FAF : FF FF FF FF FF FF 
             4FB5 : FF FF FF FF FF FF 
             4FBB : FF FF FF FF FF FF 
             4FC1 : FF FF FF FF FF FF 
             4FC7 : FF FF FF FF FF FF 
             4FCD : FF FF FF FF FF FF 
             4FD3 : FF FF FF FF FF FF 
             4FD9 : FF FF FF FF FF FF 
             4FDF : FF FF FF FF FF FF 
             4FE5 : FF FF FF FF FF FF 
             4FEB : FF FF FF FF FF FF 
             4FF1 : FF FF FF FF FF FF 
             4FF7 : FF FF FF FF FF FF 
             4FFD : FF FF FF FF FF FF 
             5003 : FF FF FF FF FF FF 
             5009 : FF FF FF FF FF FF 
             500F : FF FF FF FF FF FF 
             5015 : FF FF FF FF FF FF 
             501B : FF FF FF FF FF FF 
             5021 : FF FF FF FF FF FF 
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 75 - 12/29/2022 20:41:36


             5027 : FF FF FF FF FF FF 
             502D : FF FF FF FF FF FF 
             5033 : FF FF FF FF FF FF 
             5039 : FF FF FF FF FF FF 
             503F : FF FF FF FF FF FF 
             5045 : FF FF FF FF FF FF 
             504B : FF FF FF FF FF FF 
             5051 : FF FF FF FF FF FF 
             5057 : FF FF FF FF FF FF 
             505D : FF FF FF FF FF FF 
             5063 : FF FF FF FF FF FF 
             5069 : FF FF FF FF FF FF 
             506F : FF FF FF FF FF FF 
             5075 : FF FF FF FF FF FF 
             507B : FF FF FF FF FF FF 
             5081 : FF FF FF FF FF FF 
             5087 : FF FF FF FF FF FF 
             508D : FF FF FF FF FF FF 
             5093 : FF FF FF FF FF FF 
             5099 : FF FF FF FF FF FF 
             509F : FF FF FF FF FF FF 
             50A5 : FF FF FF FF FF FF 
             50AB : FF FF FF FF FF FF 
             50B1 : FF FF FF FF FF FF 
             50B7 : FF FF FF FF FF FF 
             50BD : FF FF FF FF FF FF 
             50C3 : FF FF FF FF FF FF 
             50C9 : FF FF FF FF FF FF 
             50CF : FF FF FF FF FF FF 
             50D5 : FF FF FF FF FF FF 
             50DB : FF FF FF FF FF FF 
             50E1 : FF FF FF FF FF FF 
             50E7 : FF FF FF FF FF FF 
             50ED : FF FF FF FF FF FF 
             50F3 : FF FF FF FF FF FF 
             50F9 : FF FF FF FF FF FF 
             50FF : FF FF FF FF FF FF 
             5105 : FF FF FF FF FF FF 
             510B : FF FF FF FF FF FF 
             5111 : FF FF FF FF FF FF 
             5117 : FF FF FF FF FF FF 
             511D : FF FF FF FF FF FF 
             5123 : FF FF FF FF FF FF 
             5129 : FF FF FF FF FF FF 
             512F : FF FF FF FF FF FF 
             5135 : FF FF FF FF FF FF 
             513B : FF FF FF FF FF FF 
             5141 : FF FF FF FF FF FF 
             5147 : FF FF FF FF FF FF 
             514D : FF FF FF FF FF FF 
             5153 : FF FF FF FF FF FF 
             5159 : FF FF FF FF FF FF 
             515F : FF FF FF FF FF FF 
             5165 : FF FF FF FF FF FF 
             516B : FF FF FF FF FF FF 
             5171 : FF FF FF FF FF FF 
             5177 : FF FF FF FF FF FF 
             517D : FF FF FF FF FF FF 
             5183 : FF FF FF FF FF FF 
             5189 : FF FF FF FF FF FF 
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 76 - 12/29/2022 20:41:36


             518F : FF FF FF FF FF FF 
             5195 : FF FF FF FF FF FF 
             519B : FF FF FF FF FF FF 
             51A1 : FF FF FF FF FF FF 
             51A7 : FF FF FF FF FF FF 
             51AD : FF FF FF FF FF FF 
             51B3 : FF FF FF FF FF FF 
             51B9 : FF FF FF FF FF FF 
             51BF : FF FF FF FF FF FF 
             51C5 : FF FF FF FF FF FF 
             51CB : FF FF FF FF FF FF 
             51D1 : FF FF FF FF FF FF 
             51D7 : FF FF FF FF FF FF 
             51DD : FF FF FF FF FF FF 
             51E3 : FF FF FF FF FF FF 
             51E9 : FF FF FF FF FF FF 
             51EF : FF FF FF FF FF FF 
             51F5 : FF FF FF FF FF FF 
             51FB : FF FF FF FF FF FF 
             5201 : FF FF FF FF FF FF 
             5207 : FF FF FF FF FF FF 
             520D : FF FF FF FF FF FF 
             5213 : FF FF FF FF FF FF 
             5219 : FF FF FF FF FF FF 
             521F : FF FF FF FF FF FF 
             5225 : FF FF FF FF FF FF 
             522B : FF FF FF FF FF FF 
             5231 : FF FF FF FF FF FF 
             5237 : FF FF FF FF FF FF 
             523D : FF FF FF FF FF FF 
             5243 : FF FF FF FF FF FF 
             5249 : FF FF FF FF FF FF 
             524F : FF FF FF FF FF FF 
             5255 : FF FF FF FF FF FF 
             525B : FF FF FF FF FF FF 
             5261 : FF FF FF FF FF FF 
             5267 : FF FF FF FF FF FF 
             526D : FF FF FF FF FF FF 
             5273 : FF FF FF FF FF FF 
             5279 : FF FF FF FF FF FF 
             527F : FF FF FF FF FF FF 
             5285 : FF FF FF FF FF FF 
             528B : FF FF FF FF FF FF 
             5291 : FF FF FF FF FF FF 
             5297 : FF FF FF FF FF FF 
             529D : FF FF FF FF FF FF 
             52A3 : FF FF FF FF FF FF 
             52A9 : FF FF FF FF FF FF 
             52AF : FF FF FF FF FF FF 
             52B5 : FF FF FF FF FF FF 
             52BB : FF FF FF FF FF FF 
             52C1 : FF FF FF FF FF FF 
             52C7 : FF FF FF FF FF FF 
             52CD : FF FF FF FF FF FF 
             52D3 : FF FF FF FF FF FF 
             52D9 : FF FF FF FF FF FF 
             52DF : FF FF FF FF FF FF 
             52E5 : FF FF FF FF FF FF 
             52EB : FF FF FF FF FF FF 
             52F1 : FF FF FF FF FF FF 
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 77 - 12/29/2022 20:41:36


             52F7 : FF FF FF FF FF FF 
             52FD : FF FF FF FF FF FF 
             5303 : FF FF FF FF FF FF 
             5309 : FF FF FF FF FF FF 
             530F : FF FF FF FF FF FF 
             5315 : FF FF FF FF FF FF 
             531B : FF FF FF FF FF FF 
             5321 : FF FF FF FF FF FF 
             5327 : FF FF FF FF FF FF 
             532D : FF FF FF FF FF FF 
             5333 : FF FF FF FF FF FF 
             5339 : FF FF FF FF FF FF 
             533F : FF FF FF FF FF FF 
             5345 : FF FF FF FF FF FF 
             534B : FF FF FF FF FF FF 
             5351 : FF FF FF FF FF FF 
             5357 : FF FF FF FF FF FF 
             535D : FF FF FF FF FF FF 
             5363 : FF FF FF FF FF FF 
             5369 : FF FF FF FF FF FF 
             536F : FF FF FF FF FF FF 
             5375 : FF FF FF FF FF FF 
             537B : FF FF FF FF FF FF 
             5381 : FF FF FF FF FF FF 
             5387 : FF FF FF FF FF FF 
             538D : FF FF FF FF FF FF 
             5393 : FF FF FF FF FF FF 
             5399 : FF FF FF FF FF FF 
             539F : FF FF FF FF FF FF 
             53A5 : FF FF FF FF FF FF 
             53AB : FF FF FF FF FF FF 
             53B1 : FF FF FF FF FF FF 
             53B7 : FF FF FF FF FF FF 
             53BD : FF FF FF FF FF FF 
             53C3 : FF FF FF FF FF FF 
             53C9 : FF FF FF FF FF FF 
             53CF : FF FF FF FF FF FF 
             53D5 : FF FF FF FF FF FF 
             53DB : FF FF FF FF FF FF 
             53E1 : FF FF FF FF FF FF 
             53E7 : FF FF FF FF FF FF 
             53ED : FF FF FF FF FF FF 
             53F3 : FF FF FF FF FF FF 
             53F9 : FF FF FF FF FF FF 
             53FF : FF                
    4347/    5400 :                     
    4348/    5400 :                     	END
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 78 - 12/29/2022 20:41:36


  Symbol Table (* = unused):
  --------------------------

 ABPASS :                      4243 C |  ABS :                         4891 C |
*ACCSUM :                      3AAB C |  ACPASS :                      4242 C |
 ADD30 :                       4DA8 C |  ADD301 :                      4DB9 C |
 ADDEXP :                      482A C |  ADDIG :                       49D0 C |
 ADDPHL :                      4617 C |  ALLFOL :                      4511 C |
 ANTVLU :                      3DAB C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
*ARET :                        4D21 C |  ARLDSV :                      4163 C |
 ARREND :                      811F - |  ARRLP :                       43DC C |
 ASC :                         44E2 C |  ASCTFP :                      4973 C |
 ASPCS :                       3D0D C |  ATN :                         4CD5 C |
 ATN1 :                        4CF2 C |  ATNTAB :                      4CFC C |
 ATOH :                        3AE6 C |  BADINP :                      3D32 C |
 BAKSTK :                      3563 C |  BAKTMP :                      44C2 C |
 BASTXT :                      80A3 - |  BCDEFP :                      48B8 C |
 BFREE :                       328D C |  BIN :                         4DFF C |
*BIN2 :                        4E05 C |  BINERR :                      4E65 C |
 BINIT :                       4E43 C |  BINTFP :                      4E39 C |
 BITOUT :                      4E1E C |  BITOUT2 :                     4E24 C |
 BKSP :                           8 - |  BN :                            28 - |
 BNORM :                       4677 C |  BNRMLP :                      467A C |
 BRK :                         3A5D C |  BRKFLG :                      8092 - |
 BRKLIN :                      8113 - |  BRKMSG :                      355D C |
 BRKRET :                      327E C |  BS :                            10 - |
 BSERR :                       4196 C |  BUFFER :                      80A6 - |
 BYT2ASC :                     4D9E C |  BYTSFT :                      47AF C |
*CASESENSITIVE :                  0 - |  CFEVAL :                      40F9 C |
 CHARTY :                      40A7 C |  CHEKFN :                      42DA C |
 CHKBIN :                      4E57 C |  CHKLTR :                      3AB8 C |
 CHKSTK :                      3597 C |  CHKSUM :                      808F - |
 CHKSYN :                      3888 C |  CHKTYP :                      3E8C C |
 CHR :                         44F3 C |  CLEAR :                       3B0B C |
 CLOTST :                      38BD C |  CLREG :                       36EC C |
 CLRPTR :                      36C7 C |  CLS :                         4D24 C |
 CMPFP :                       4901 C |  CMPLG1 :                      400D C |
 CMPLOG :                      400B C |  CMPNUM :                      48E7 C |
 CMPRES :                      404F C |  CMPSTR :                      4037 C |
 CN :                            20 - |  CNVNUM :                      497F C |
*COLD :                        3200 C |  COMMAN :                      8088 - |
 COMPL :                       46D7 C | *COMPMODE :                       0 - |
 CONCAT :                      4457 C |  CONEXP :                      49AF C |
 CONPOS :                      4674 C | *CONSTPI :        3.141592653589793 - |
 CONT :                        3A90 C |  CONTAD :                      8119 - |
 CONVAR :                      3F78 C |  COPY :                        321C C |
 COS :                         4C59 C |  COUNT :                       392D C |
 CPDEHL :                      3882 C |  CPYLIT :                      37BE C |
 CR :                            0D - |  CRARLP :                      41B6 C |
 CREARY :                      419B C |  CRESTR :                      3C0A C |
 CRNCLP :                      371F C |  CRTMST :                      4313 C |
 CRTST :                       431F C |  CRTSTE :                      4335 C |
 CRUNCH :                      3716 C |  CS :                            0C - |
 CSTART :                      320D C |  CTLOFG :                      808A - |
 CTRLC :                          3 - |  CTRLG :                          7 - |
 CTRLO :                         0F - |  CTRLQ :                         11 - |
 CTRLR :                         12 - |  CTRLS :                         13 - |
 CTRLU :                         15 - |  CUROPR :                      810A - |
 CURPOS :                      80F0 - |  DATA :                        3BB1 C |
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 79 - 12/29/2022 20:41:36


*DATE :                "12/29/2022" - |  DATFLG :                      80F3 - |
 DATLIN :                      810E - |  DATSNR :                      35B4 C |
 DCBCDE :                      4938 C |  DDERR :                       35C3 C |
 DEEK :                        4D40 C |  DEF :                         4257 C |
 DEFSIZ :                      41BE C |  DEINT :                       3ACC C |
 DEL :                           7F - |  DELCHR :                      37EE C |
 DEPINT :                      3AC6 C |  DETHL4 :                      48C7 C |
 DETHLB :                      48C9 C |  DIGTXT :                      4A79 C |
 DIM :                         4079 C |  DIMRET :                      4070 C |
 DINPOS :                      38B7 C |  DIV :                         47C0 C |
 DIV1 :                        804F - |  DIV10 :                       47B4 C |
 DIV2 :                        8053 - |  DIV3 :                        8057 - |
 DIV4 :                        805A - |  DIVLP :                       47E7 C |
 DIVSUP :                      804E - |  DOAGN :                       3705 C |
 DOCOM :                       3CDE C |  DODEL :                       37CE C |
 DOEBIT :                      4AB9 C |  DOFN :                        4284 C |
 DOKE :                        4D4B C |  DONULL :                      3CCC C |
 DOSPC :                       3D08 C |  DOTAB :                       3CF5 C |
 DPOINT :                      49AB C |  DTSTR :                       4323 C |
 DVBCDE :                      47C2 C |  DZ :                            14 - |
 DZERR :                       35BD C |  ECHDEL :                      37E2 C |
 EDIGIT :                      49F2 C |  ENDBUF :                      37C5 C |
 ENDCON :                      49BE C |  ENDDIM :                      421D C |
 ENDINP :                      3CBD C |  ENDNAM :                      409B C |
 ENDPRG :                      3A6C C |  ENFMEM :                      35A0 C |
 ERRIN :                       35EE C |  ERRLIN :                      8117 - |
 ERRMSG :                      354B C |  ERROR :                       35CE C |
 ERRORS :                      34C1 C |  ESC :                           1B - |
 EVAL :                        3E99 C |  EVAL1 :                       3E9C C |
 EVAL2 :                       3EA5 C |  EVAL3 :                       3EA8 C |
 EVLPAR :                      3F5F C |  EVNOT :                       4059 C |
 EXCUTE :                      39F6 C |  EXP :                         4B53 C |
 EXPLP :                       499D C |  EXPTAB :                      4B93 C |
 EXPTEN :                      4ACB C |  EXTIG :                       3E07 C |
*FALSE :                          0 - |  FANDT :                       3E31 C |
 FC :                             8 - |  FCERR :                       3AE1 C |
 FDTLP :                       3E18 C |  FINDEL :                      41F9 C |
 FLGDIF :                      4877 C |  FLGREL :                      487E C |
 FNARG :                       8125 - |  FNCTAB :                      330B C |
 FNDARY :                      4169 C |  FNDELP :                      41FE C |
 FNDEND :                      369A C |  FNDNUM :                      45E8 C |
 FNDTOK :                      390C C |  FNDVAR :                      40E0 C |
 FNDWRD :                      3749 C |  FNOFST :                      3F89 C |
 FNRGNM :                      8123 - |  FNTHR :                       40EE C |
 FNVAL :                       3FB0 C |  FOPRND :                      3ED1 C |
 FOR :                         395D C |  FORFLG :                      8110 - |
 FORFND :                      398D C |  FORSLP :                      3971 C |
 FPADD :                       4626 C |  FPBCDE :                      48AD C |
 FPEXP :                       812C - |  FPINT :                       4914 C |
 FPMULT :                      4761 C |  FPREG :                       8129 - |
 FPROND :                      46BE C |  FPSINT :                      3AC0 C |
 FPTHL :                       48C4 C |  FRE :                         4221 C |
 FRENUM :                      423D C |  FRMEVL :                      3F7B C |
*FULLPMMU :                       1 - |  GARBGE :                      43A4 C |
 GARBLP :                      43A7 C |  GETCHR :                      3A16 C |
 GETCMD :                      3612 C |  GETHEX :                      4DD9 C |
 GETINP :                      4D22 C |  GETINT :                      45EB C |
 GETLEN :                      44D7 C |  GETLIN :                      37FF C |
 GETLN :                       3AE7 C |  GETNUM :                      3E87 C |
 GETNXT :                      3764 C |  GETSTR :                      44A1 C |
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 80 - 12/29/2022 20:41:36


 GETVAR :                      407E C |  GNXARY :                      43DB C |
 GOFUNC :                      3FB8 C |  GOSUB :                       3B5D C |
 GOTO :                        3B6E C |  GRBARY :                      43FB C |
 GRBDON :                      437C C |  GRBLP :                       43B5 C |
 GSTRCU :                      44A4 C |  GSTRDE :                      44A8 C |
 GSTRHL :                      44A7 C | *GTFLNM :                      44E6 C |
 GTFNAM :                      4083 C |  GTLNLP :                      3AEA C |
 GTSIXD :                      4A43 C |  GTVLUS :                      3D83 C |
 HALF :                        4AEA C |  HALFPI :                      4CA3 C |
*HAS64 :                          0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HEX :                         4D62 C |
 HEX1 :                        4D7D C |  HEX2 :                        4D7F C |
 HEX3 :                        4D8F C |  HEX4 :                        4D91 C |
 HEXIT :                       4DF1 C |  HEXLP :                       4DCA C |
 HEXLP1 :                      4DD0 C |  HEXTFP :                      4DBD C |
 HX :                            26 - |  HXERR :                       4DFA C |
 ID :                            16 - |  IDTEST :                      42CC C |
 IF :                          3C40 C |  IFGO :                        3C4E C |
 IFJMP :                       39FD C |  INCHL :                       48C2 C |
 INCLEN :                      38B3 C |  INDFND :                      357D C |
 INEWLN :                      3662 C |  INIT :                        3214 C |
 INITAB :                      34EB C |  INITBE :                      354B C |
 INITST :                      4E74 C |  INMSG :                       3552 C |
 INP :                         45A8 C |  INPBIN :                      3DD5 C |
 INPBRK :                      3A69 C |  INPORT :                      8084 - |
 INPSUB :                      8083 - |  INPUT :                       3D43 C |
 INRNG :                       4A4C C | *INSUPMODE :                      0 - |
 INT :                         493F C |  INTVAR :                      36D6 C |
 INVSGN :                      4895 C |  ITMSEP :                      3DC6 C |
*JJUMP1 :                      4E6A C |  JSTZER :                      4AD5 C |
 KILFOR :                      3E77 C |  KILIN :                       37F9 C |
 LCRFLG :                      80F1 - |  LEFT :                        4503 C |
 LEN :                         44D3 C |  LET :                         3BC8 C |
 LETNUM :                      3C1B C |  LETSTR :                      3BE3 C |
 LF :                            0A - |  LFRGNM :                      459E C |
 LINEAT :                      80A1 - |  LINEIN :                      49FE C |
 LINES :                       4D31 C |  LINESC :                      808B - |
 LINESN :                      808D - |  LINFND :                      364B C |
 LIST :                        38CE C |  LISTLP :                      38DA C |
*LISTON :                         1 - |  LOADFP :                      48BB C |
 LOG :                         4720 C |  LOGTAB :                      4713 C |
 LOKFOR :                      3567 C |  LOOPST :                      810C - |
 LS :                            1C - |  LSTBIN :                      8111 - |
 LSTLP2 :                      38FA C |  LSTLP3 :                      38FD C |
 LSTRAM :                      80F4 - |  LSTRND :                      807F - |
 LTSTND :                      3DE0 C |  LWIDTH :                      8087 - |
*MACEXP :                         7 - |  MAKINT :                      45EE C |
 MAKNUM :                      4A68 C |  MANLP :                       4987 C |
 MATCH :                       3796 C |  MEMMSG :                      32D9 C |
 MID :                         453D C |  MID1 :                        4509 C |
 MIDNUM :                      45A3 C |  MINCDE :                      4666 C |
 MINUS :                       3F67 C |  MKTMST :                      4310 C |
 MLDBLP :                      4960 C |  MLDEBC :                      4958 C |
 MLOOP :                       3234 C |  MLSP10 :                      4855 C |
 MO :                            24 - | *MOMCPU :                        80 - |
*MOMCPUNAME :                 "Z80" - |  MONITR :                      4E70 C |
 MONOUT :                      4E6D C |  MORDT :                       3DEC C |
 MORINP :                      3808 C |  MOVBUF :                      3681 C |
 MOVDIR :                      379E C |  MOVLP :                       358C C |
 MOVSTR :                      3589 C |  MOVUP :                       3586 C |
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 81 - 12/29/2022 20:41:36


 MRPRNT :                      3C60 C | *MSIZE :                       3231 C |
 MUL8LP :                      478C C |  MULLN2 :                      4758 C |
 MULT :                        475F C |  MULT8 :                       4783 C |
 MULTEN :                      49C9 C |  MULVAL :                      813B - |
 MVSTPT :                      3C12 C |  NEDMOR :                      3D7F C |
 NEGAFT :                      4B00 C |  NEMEM :                       3284 C |
*NESTMAX :                      100 - |  NEW :                         36C6 C |
 NEXITM :                      3D18 C |  NEXT :                        3E3C C |
 NEXT1 :                       3E3F C |  NF :                             0 - |
 NFERR :                       35C0 C | *NMIFLG :                      8091 - |
 NOCHNG :                      378E C |  NOENED :                      4AD8 C |
 NOLIN :                       3A7F C |  NOMADD :                      479D C |
 NOMLAD :                      496E C |  NOPMPT :                      3D5D C |
 NORMAL :                      4691 C |  NOSPC :                       3785 C |
 NOSUB7 :                      4DED C |  NOSWAP :                      4640 C |
 NOTAMP :                      3F3C C |  NOTSTR :                      40B6 C |
 NOXOR :                       45CE C |  NSCFOR :                      40C6 C |
 NULFLG :                      8089 - |  NULL :                        3AA3 C |
 NULLP :                       3CD3 C |  NULLS :                       8086 - |
 NUMASC :                      4A11 C |  NXTARY :                      417D C |
 NXTBYT :                      3774 C |  NXTCHR :                      37B5 C |
 NXTDAT :                      8121 - |  NXTDTA :                      3BB0 C |
 NXTITM :                      3D77 C |  NXTOPR :                      8115 - |
 NXTSTL :                      3BB7 C |  NXTSTT :                      3BBA C |
 OD :                             6 - |  OKMSG :                       3557 C |
 OM :                            0C - |  OMERR :                       35AF C |
 ON :                          3C22 C |  ONGO :                        3C31 C |
 ONGOLP :                      3C32 C |  ONJMP :                       39FE C |
 OPNPAR :                      3E95 C |  OPRND :                       3F10 C |
 OS :                            1A - |  OTKLN :                       37F6 C |
 OTPORT :                      804C - |  OUTC :                        3893 C |
 OUTEXP :                      4AC9 C |  OUTIT :                       3874 C |
 OUTNBS :                      387A C |  OUTNCR :                      4E83 C |
 OUTSUB :                      804B - |  OUTWRD :                      3916 C |
 OV :                            0A - |  OVERR :                       35C9 C |
 OVTST1 :                      4848 C |  OVTST2 :                      484D C |
 OVTST3 :                      484E C |  PADD :                        49ED C |
*PADDING :                        1 - |  PAND :                        3FD2 C |
 PASSA :                       4252 C |  PBUFF :                       812E - |
 PEEK :                        45FC C |  PEND :                        3A64 C |
 PHLTFP :                      48AA C |  PLUCDE :                      46CB C |
 PNORM :                       4699 C |  POINT :                       8096 - |
 POKE :                        4603 C |  POPAF :                       4396 C |
 POPHL :                       44C0 C |  POPHRT :                      47AD C |
 POPNOK :                      3604 C |  POR :                         3FD1 C |
 POR1 :                        3FF4 C |  POS :                         424F C |
 POSINT :                      3AC3 C |  POUT :                        45B4 C |
 POWER :                       4B0E C |  POWER1 :                      4B1E C |
 POWER2 :                      4B3B C |  POWERS :                      4AEE C |
 PRCRLF :                      3CC2 C |  PRINT :                       3C64 C |
 PRITAB :                      34AC C |  PRNTHL :                      4A06 C |
 PRNTLP :                      3C67 C |  PRNTNB :                      3CAA C |
 PRNTOK :                      3605 C |  PRNTST :                      3CAE C |
 PRNUMS :                      4360 C |  PROCES :                      3821 C |
 PROGND :                      811B - |  PROGST :                      813E - |
 PROMPT :                      3709 C |  PRS :                         4361 C |
 PRS1 :                        4364 C |  PRSLP :                       436B C |
 PSET :                        8099 - |  PSUB :                        4621 C |
 PTRLP :                       368E C |  PUTBUF :                      3860 C |
 PUTCTL :                      3865 C |  PUTFID :                      39D2 C |
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 82 - 12/29/2022 20:41:36


 QTSTLP :                      4326 C |  QTSTR :                       4320 C |
 QUARTR :                      4CA7 C |  RD :                            12 - |
 READ :                        3D72 C |  READFG :                      8112 - |
 REDO :                        3D1F C | *RELAXED :                        0 - |
 REM :                         3BB3 C |  RESDIV :                      47FA C |
 RESEED :                      4C45 C |  RESET :                       809C - |
 RESTNL :                      3A3B C |  RESTOR :                      3A26 C |
 RESZER :                      468C C |  RETADR :                      412D C |
 RETINT :                      4883 C |  RETLIN :                      3BAB C |
 RETNAD :                      379A C |  RETNUL :                      4130 C |
 RETNUM :                      3F73 C |  RETREL :                      4875 C |
 RETURN :                      3B8C C |  RG :                             4 - |
 RIGHT :                       4533 C |  RIGHT1 :                      4507 C |
 RINPUT :                      8093 - |  RLTLP :                       3EB5 C |
 RND :                         4BE4 C |  RND1 :                        4C20 C |
 RND2 :                        4C3C C |  RNDTAB :                      4C4D C |
 RNGTST :                      4ADB C |  RONDB :                       46AD C |
 RONDUP :                      46AC C |  ROUND :                       4614 C |
 RSCALE :                      49E7 C |  RSLNBK :                      3954 C |
 RSTSTR :                      4556 C |  RUN :                         3B51 C |
 RUNCNT :                      39D6 C |  RUNFST :                      36D2 C |
 RUNLIN :                      3B6D C |  SAVEXP :                      468D C |
 SAVSTP :                      39C9 C |  SAVSTR :                      42FB C |
 SBSCPT :                      413B C |  SCALE :                       46EB C |
 SCALLP :                      46ED C |  SCALMI :                      49B2 C |
 SCALPL :                      49C8 C |  SCNEND :                      4432 C |
 SCPTLP :                      4141 C |  SEARCH :                      3762 C |
 SEED :                        805C - |  SETIO :                       45D8 C |
 SETLIN :                      3924 C |  SETLIT :                      37AC C |
 SETPTR :                      3689 C |  SETTOP :                      3243 C |
 SFTPRG :                      3653 C |  SGN :                         487B C |
 SGNEXP :                      3FC1 C |  SGNRES :                      812D - |
 SHRITE :                      46FA C |  SHRLP :                       46FD C |
 SHRT1 :                       4701 C |  SIGNON :                      329C C |
 SIGNS :                       48D2 C |  SIN :                         4C5F C |
 SIN1 :                        4C8F C |  SINTAB :                      4CAB C |
 SIXDIG :                      4A2E C |  SMPVAR :                      43C6 C |
 SMSER1 :                      4BC3 C |  SN :                             2 - |
 SNERR :                       35BA C |  SPCFST :                      4A1F C |
 SPCLP :                       3D11 C |  SQR :                         4B05 C |
 SRCHLN :                      36A6 C |  SRCHLP :                      36A9 C |
 SSTSA :                       448E C |  ST :                            1E - |
 STACK :                       80AB - |  STAKFP :                      489D C |
 STALL :                       3A51 C |  STARTB :                      3206 C |
 STKTHS :                      3EF9 C |  STLOOK :                      81A2 - |
 STOP :                        3A62 C |  STORED :                      3B2E C |
 STPOOL :                      4409 C |  STR :                         42EB C |
 STR1 :                        42F1 C |  STRADD :                      440C C |
 STRBOT :                      8108 - |  STRENT :                      3DC9 C |
 STRSPC :                      809F - |  STTLIN :                      3CB5 C |
 SUBCDE :                      4623 C |  SUBPHL :                      461D C |
 SUMLP :                       4BCC C |  SUMSER :                      4BB4 C |
 SUPTLZ :                      4AAD C |  SVNAM2 :                      409A C |
 SVSTAD :                      4319 C |  TAN :                         4CC0 C |
 TESTOS :                      4398 C |  TESTR :                       437A C |
*TIME :                  "20:41:36" - |  TM :                            18 - |
 TMERR :                       35CC C |  TMPSTR :                      8104 - |
 TMSTPL :                      80F8 - |  TMSTPT :                      80F6 - |
 TOPOOL :                      44FF C |  TOSTRA :                      4497 C |
*TRUE :                           1 - |  TRYAGN :                      4A88 C |
 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 83 - 12/29/2022 20:41:36


 TSALP :                       4498 C | *TSTBIT :                      4E7C C |
 TSTBRK :                      3A41 C |  TSTNUM :                      3E8A C |
 TSTOPL :                      4341 C |  TSTRED :                      3FF9 C |
 TSTREM :                      37AF C |  TSTSGN :                      486C C |
 TSTSTR :                      3E8B C |  TTYLIN :                      37FF C |
 TYPE :                        80F2 - |  UF :                            22 - |
 UFERR :                       35C6 C |  UL :                            0E - |
 ULERR :                       3B87 C |  UNITY :                       470F C |
 UPDATA :                      3A3C C |  USR :                         8048 - |
 VAL :                         456D C |  VAL1 :                        458C C |
 VAL2 :                        4597 C |  VAL3 :                        459A C |
 VAREND :                      811D - | *VERSION :                     142F - |
 WAIT :                        45BA C |  WAITLP :                      45CF C |
*WARM :                        3203 C |  WARMST :                      327B C |
 WIDTH :                       4D29 C |  WORDS :                       3343 C |
 WORDTB :                      3462 C |  WRKSPC :                      8045 - |
 XXXXX :                       328A C |  ZDATA :                         83 - |
*ZDIV :                         0AF - |  ZEND :                          80 - |
 ZEQUAL :                       0B4 - |  ZERARY :                      41DC C |
 ZERBYT :                      3556 - |  ZEROLP :                      411F C |
 ZEROSUP :                     4E0B C |  ZFN :                          0A7 - |
 ZFOR :                          81 - |  ZGOSUB :                        8C - |
 ZGOTO :                         88 - |  ZGTR :                         0B3 - |
 ZLEFT :                        0CF - |  ZLTH :                         0B5 - |
 ZMINUS :                       0AD - |  ZNEW :                         0A4 - |
 ZNOT :                         0AA - |  ZONELP :                      3CEC C |
 ZOR :                          0B2 - |  ZPLUS :                        0AC - |
*ZPOINT :                       0C7 - |  ZPRINT :                        9E - |
 ZREM :                          8E - |  ZSGN :                         0B6 - |
 ZSPC :                         0A8 - |  ZSTEP :                        0AB - |
 ZTAB :                         0A5 - |  ZTHEN :                        0A9 - |
*ZTIMES :                       0AE - |  ZTO :                          0A6 - |

    656 symbols
     34 unused symbols

 AS V1.42 Beta [Bld 232] - Source File MSBAS80_3200.asm - Page 84 - 12/29/2022 20:41:36


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.11 seconds assembly time

   4349 lines source file
      2 passes
      0 errors
      0 warnings
